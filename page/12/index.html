<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="永远不要说你知道本质，更别说真相了。">
<meta property="og:type" content="website">
<meta property="og:title" content="简">
<meta property="og:url" content="https://huyunshun.com/page/12/index.html">
<meta property="og:site_name" content="简">
<meta property="og:description" content="永远不要说你知道本质，更别说真相了。">
<meta property="article:author" content="初晨">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="开发">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://huyunshun.com/page/12/"/>





  <title>简</title>
  








  <script type="text/javascript" src="/js/src/love.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

  <!-- 看板娘 -->
    
        <script async src="/live2d-widget/autoload.js"></script>
    
 <!-- 飘动的彩带） -->
  <script src="/js/src/piao.js" type="text/javascript"></script>
<meta name="generator" content="Hexo 4.2.1"></head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">简</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">人生短暂，学海无边，而大道至简。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2019/01/20/IOC%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/20/IOC%E5%9B%9E%E9%A1%BE/" itemprop="url">IOC回顾</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-20T22:24:29+08:00">
                2019-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）</p>
<h3 id="spring实现IOC的思路和方法"><a href="#spring实现IOC的思路和方法" class="headerlink" title="spring实现IOC的思路和方法"></a>spring实现IOC的思路和方法</h3><p>spring实现IOC的思路是提供一些配置信息用来描述类之间的依赖关系，然后由容器去解析这些配置信息，继而维护好对象之间的依赖关系。</p>
<p>spring实现IOC的思路大致可以拆分成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">应用程序中提供类和类的依赖关系（属性或者构造方法）</span><br><span class="line">把需要容器管理的对象通过配置信息告诉容器（xml、annotation，javaconfig）</span><br><span class="line">把各个类之间的依赖关系通过配置信息告诉容器</span><br></pre></td></tr></table></figure>
<p>配置这些信息的方法有三种分别是xml，annotation和javaconfig，容器维护这些类和对象的过程称为自动注入，自动注入的方法有两种：构造方法和setter注入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schemal-based-------xml</span><br><span class="line">annotation-based-----annotation</span><br><span class="line">java-based----java Configuration</span><br></pre></td></tr></table></figure>
<p>spring注入详细配置（字符串、数组等）参考文档：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed</a></p>
<h4 id="Constructor-based-Dependency-Injection"><a href="#Constructor-based-Dependency-Injection" class="headerlink" title="Constructor-based Dependency Injection"></a>Constructor-based Dependency Injection</h4><p>构造方法注入参考文档：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThingOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThingOne</span><span class="params">(ThingTwo thingTwo, ThingThree thingThree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingOne"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"beanTwo"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"beanThree"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanTwo"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingTwo"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanThree"</span> <span class="attr">class</span>=<span class="string">"x.y.ThingThree"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Setter-based-Dependency-Injection"><a href="#Setter-based-Dependency-Injection" class="headerlink" title="Setter-based Dependency Injection"></a>Setter-based Dependency Injection</h4><p>参考文档：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanOne</span><span class="params">(AnotherBean beanOne)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanOne = beanOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanTwo</span><span class="params">(YetAnotherBean beanTwo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanTwo = beanTwo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntegerProperty</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- setter injection using the nested ref element --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanOne"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanTwo"</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integerProperty"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>IOC的注入需要提供的依赖关系，一是类的定义体现依赖关系，二是在配置文件中描述依赖关系。自动装配则把配置文件中描述依赖关系取消了，只要提供好类的依赖关系就可以把对象交给容器管理完成注入。</p>
<p>在实际开发中，描述类之间的依赖关系通常是大篇幅的，如果使用自动装配则省去了很多配置，并且如果对象的依赖发生更新我们可以不需要去更新配置，但是也带来了一定的缺点。</p>
<p>自动装配的优点参考文档：<br><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>
<p>缺点参考文档：<br><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions</a></p>
<p>自动装配的方法有四种：no/byName/byType/constructor</p>
<p>自动装配的方式参考文档：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a></p>
<p><img src="https://img.huyunshun.com/img/20200420222616.png" alt="20200420222616"></p>
<p><strong>从自动装配中排除Bean</strong></p>
<p>在每个bean的基础上，您可以从自动装配中排除一个bean。使用Spring的XML格式，将元素的autowire-candidate属性设置<bean/>为false。容器使特定的bean定义对自动装配基础结构不可用（包括注释样式配置，例如@Autowired）。</p>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lazy"</span> <span class="attr">class</span>=<span class="string">"com.something.ExpensiveToCreateBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"not.lazy"</span> <span class="attr">class</span>=<span class="string">"com.something.AnotherBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>或注解形式@Lazy</p>
<h3 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h3><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes</a></p>
<p><img src="https://img.huyunshun.com/img/20200420222645.png" alt="20200420222645"></p>
<p>xml方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.something.DefaultAccountService"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者直接使用注解方式。</p>
<h3 id="Spring的方法注入可分为两种"><a href="#Spring的方法注入可分为两种" class="headerlink" title="Spring的方法注入可分为两种"></a>Spring的方法注入可分为两种</h3><p>查找方法注入：用于注入方法返回结果，也就是说能通过配置方式替换方法返回结果。即我们通常所说的lookup-method注入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单例模式的bean只会被创建一次，IoC容器会缓存该bean实例以供下次使用；原型模式的bean每次都会创建一个全新的bean，IoC容器不会缓存该bean的实例。</span><br><span class="line">那么如果现在有一个单例模式的bean引用了一个原型模式的bean呢？如果无特殊处理，则被引用的原型模式的bean也会被缓存，这就违背了原型模式的初衷，这时使用lookup-method注入可以解决该问题。</span><br></pre></td></tr></table></figure>
<p>替换方法注入：可以实现方法主体或返回结果的替换，即我们通常所说的replaced-method注入。</p>
<h4 id="lookup-method注入-Lookup"><a href="#lookup-method注入-Lookup" class="headerlink" title="lookup-method注入   @Lookup"></a>lookup-method注入   @Lookup</h4><p>** 在Singleton 当中引用了一个Prototype的bean的时候引发的问题: **</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在Spring的诸多应用场景中bean都是单例形式，当一个单利bean需要和一个非单利bean组合使用或者一个非单利bean和另一个非单利bean组合使用时，我们通常都是将依赖以属性的方式放到bean中来引用，然后以@Autowired来标记需要注入的属性。</span><br><span class="line">但是这种方式在bean的生命周期不同时将会出现很明显的问题，假设单利bean A需要一个非单利bean B（原型），我们在A中注入bean B，每次调用bean A中的方法时都会用到bean B，</span><br><span class="line">我们知道Spring Ioc容器只在容器初始化时执行一次，也就是bean A中的依赖bean B只有一次注入的机会，但是实际上bean B我们需要的是每次调用方法时都获取一个新的对象（原型）</span><br><span class="line">所以问题明显就是：我们需要bean B是一个原型bean，而事实上bean B的依赖只注入了一次变成了事实上的单利bean。</span><br></pre></td></tr></table></figure>
<p>解决方式：去找 或者赋值</p>
<p>1、Method Injection </p>
<p>继承ApplicationContextAware 每次调用方法时用上下文的getBean(name,class)方法去重新获取bean B的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring-API imports</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// notice the Spring API dependency!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationContext.getBean(<span class="string">"command"</span>, Command<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、Lookup Method Injection</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个注解或xml配置实现</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCommand"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"myCommand"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        MyCommand command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以写成 @Lookup("prototypeBean") 来指定需要注入的bean</span></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者不用抽象类</span></span><br><span class="line"><span class="meta">@Lookup</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MyCommand <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="replaced-method注入"><a href="#replaced-method注入" class="headerlink" title="replaced-method注入"></a>replaced-method注入</h4><p>主要作用就是替换方法体及其返回值，其实现也比较简单</p>
<p>replace-method注入需实现MethodReplacer接口，并重写reimplement方法。</p>
<h3 id="Lifecycle-Callbacks-生命周期回调"><a href="#Lifecycle-Callbacks-生命周期回调" class="headerlink" title="Lifecycle Callbacks 生命周期回调"></a>Lifecycle Callbacks 生命周期回调</h3><h4 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h4><p>实现接口org.springframework.beans.factory.InitializingBean  指定一个方法： void afterPropertiesSet() throws Exception;</p>
<p>或者是配置文件中直接一个初始化方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h4><p>org.springframework.beans.factory.DisposableBean当包含该接口的容器被销毁时，实现该接口可使Bean获得回调 public void destroy() 。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>注解方式实现：从Spring 2.5开始，可以使用三种方式来控制Bean生命周期行为：</p>
<p>1、在InitializingBean（初始化bean之后）和 DisposableBean回调接口</p>
<p>2、配置init()和destroy()方法</p>
<p>3、在@PostConstruct（初始化bean之前）和@PreDestroy 注释。您可以结合使用这些机制来控制给定的bean。</p>
<p>如果同一个bean配置的具有不同初始化方法的顺序为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用注释的方法 @PostConstruct</span><br><span class="line">afterPropertiesSet()由InitializingBean回调接口定义</span><br><span class="line">定制配置的init()方法</span><br><span class="line"></span><br><span class="line">销毁方法的调用顺序相同：</span><br><span class="line">用注释的方法 @PreDestroy</span><br><span class="line">destroy()由DisposableBean回调接口定义</span><br><span class="line">定制配置的destroy()方法</span><br></pre></td></tr></table></figure>

<h3 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常 </span><br><span class="line">@Qualifier：限定符    @Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用</span><br><span class="line">例子：</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(注入的类)</span><br></pre></td></tr></table></figure>

<h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends-on"></a>depends-on</h3><p>如果 bean 是另一个的依赖关系，则需要首先注入这个类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager,accountDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"manager"</span> <span class="attr">ref</span>=<span class="string">"manager"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生成候选组件的索引"><a href="#生成候选组件的索引" class="headerlink" title="生成候选组件的索引"></a>生成候选组件的索引</h3><p>当有很多个类需要扫描，会比较慢，使用如下包来在编译的时候就加入到索引，按照索引的方式去扫描就会很快。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context-indexer&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>java也有一套注解，可以用来开发spring。</p>
<p><img src="https://img.huyunshun.com/img/20200420222714.png" alt="20200420222714"></p>

          
        
      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2019/01/20/AOP%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/20/AOP%E5%9B%9E%E9%A1%BE/" itemprop="url">AOP回顾</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-20T22:24:29+08:00">
                2019-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Aop"><a href="#Aop" class="headerlink" title="Aop"></a>Aop</h3><p>与OOP对比，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，但是这些问题和业务关系不大，也不会影响主逻辑，但是会散落到代码的各个部分，难以维护。而AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。</p>
<p>应用场景：日志记录、权限验证、效率检查、事务管理、exception。</p>
<table>
<thead>
<tr>
<th></th>
<th>JDK动态代理</th>
<th>CGLIB代理</th>
</tr>
</thead>
<tbody><tr>
<td>编译时期的织入还是运行时期的织入?</td>
<td>运行时期织入</td>
<td>运行时期织入</td>
</tr>
<tr>
<td>初始化时期织入还是获取对象时期织入？</td>
<td>初始化时期织入</td>
<td>初始化时期织入</td>
</tr>
</tbody></table>
<h3 id="SpringAop和AspectJ的关系"><a href="#SpringAop和AspectJ的关系" class="headerlink" title="SpringAop和AspectJ的关系"></a>SpringAop和AspectJ的关系</h3><p>Aop是一种概念，springAop、AspectJ都是Aop的实现，SpringAop有自己的语法，但是语法复杂，所以SpringAop借助了AspectJ的注解，但是底层实现还是自己的。</p>
<p>spring AOP提供两种编程风格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@AspectJ support        利用aspectj的注解</span><br><span class="line">Schema-based AOP support          xml aop:config 命名空间</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Aop的概念"><a href="#Spring-Aop的概念" class="headerlink" title="Spring Aop的概念"></a>Spring Aop的概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aspect：一定要给spring去管理  </span><br><span class="line">pointcut：切点，表示连接点的集合</span><br><span class="line">Joinpoint：连接点   目标对象中的方法 </span><br><span class="line">Weaving：织入，把代理逻辑加入到目标对象上的过程</span><br><span class="line">target：目标对象 原始对象</span><br><span class="line">aop Proxy 代理对象  包含了原始对象的代码和增加后的代码的那个对象，如果是cglib则都一致。</span><br><span class="line">advice：通知</span><br></pre></td></tr></table></figure>

<h4 id="advice通知类型"><a href="#advice通知类型" class="headerlink" title="advice通知类型"></a>advice通知类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Before 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常</span><br><span class="line">After  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出</span><br><span class="line">After throwing  执行抛出异常的时候</span><br><span class="line">After (finally)  无论连接点是正常退出还是异常退出，都会执行</span><br><span class="line">Around advice: 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</span><br><span class="line"></span><br><span class="line">@DeclareParents：其是一种Introduction类型的模型，在属性声明上使用，主要用于为指定的业务模块添加新的接口和相应的实现。</span><br></pre></td></tr></table></figure>

<h4 id="Proceedingjoinpoint-和JoinPoint的区别"><a href="#Proceedingjoinpoint-和JoinPoint的区别" class="headerlink" title="Proceedingjoinpoint 和JoinPoint的区别"></a>Proceedingjoinpoint 和JoinPoint的区别</h4><p>Proceedingjoinpoint 继承了JoinPoint，并扩充实现了proceed()方法，用于继续执行连接点。JoinPoint仅能获取相关参数，无法执行连接点。</p>
<p>JoinPoint的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表； </span><br><span class="line">2.Signature getSignature() ：获取连接点的方法签名对象； </span><br><span class="line">3.java.lang.Object getTarget() ：获取连接点所在的目标对象； </span><br><span class="line">4.java.lang.Object getThis() ：获取代理对象本身；</span><br><span class="line">proceed()有重载,有个带参数的方法,可以修改目标方法的的参数</span><br></pre></td></tr></table></figure>

<h4 id="Introductions"><a href="#Introductions" class="headerlink" title="Introductions"></a>Introductions</h4><p>通过将需要添加的新的行为逻辑，以新的接口定义增加到目标对象上。以@Aspect声明一个实列变量，它的类型对应的是新增加的接口类型，然后通过DeclareParents对其进行标注。通过@DeclareParents指定新接口定义的实现类以及将要加诸其上的目标对象。简单来说就是可以扩展原有的目标对象。</p>
<p>例如，给定名为的接口UsageTracked和名为的接口的实现DefaultUsageTracked，新声明服务接口的所有实现者也都实现该UsageTracked接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageTracking</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeclareParents</span>(value=<span class="string">"com.xzy.myapp.service.*+"</span>, defaultImpl=DefaultUsageTracked<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">UsageTracked</span> <span class="title">mixin</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordUsage</span><span class="params">(UsageTracked usageTracked)</span> </span>&#123;</span><br><span class="line">        usageTracked.incrementUseCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="string">"myService"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="切面模型-perthis"><a href="#切面模型-perthis" class="headerlink" title="切面模型 perthis"></a>切面模型 perthis</h4><p>perthis：每个切入点表达式匹配的连接点对应的AOP对象都会创建一个新的切面实例，使用@Aspect(“perthis(切入点表达式)”)指定切入点表达式；默认的情况下多个连接点对应的切面对象是一个。</p>
<p>使用方式如下：</p>
<p>@Aspect(“perthis(com.xyz.myapp.SystemArchitecture.businessService())”)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. AspectJ对象的注入类型为prototype</span><br><span class="line">2. 目标对象也必须是prototype的</span><br></pre></td></tr></table></figure>
<p>原因：只有目标对象是原型模式的，每次getBean得到的对象才是不一样的，由此针对每个对象就会产生新的切面对象，才能产生不同的切面结果。</p>
<h3 id="SpringAop支持AspectJ"><a href="#SpringAop支持AspectJ" class="headerlink" title="SpringAop支持AspectJ"></a>SpringAop支持AspectJ</h3><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-aspectj-support" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-aspectj-support</a></p>
<h4 id="启用-AspectJ支持"><a href="#启用-AspectJ支持" class="headerlink" title="启用@AspectJ支持"></a>启用@AspectJ支持</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XML配置启用@AspectJ支持：<a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a></p>
<h4 id="声明一个Aspect"><a href="#声明一个Aspect" class="headerlink" title="声明一个Aspect"></a>声明一个Aspect</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAspect</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="声明切点pointCut"><a href="#声明切点pointCut" class="headerlink" title="声明切点pointCut"></a>声明切点pointCut</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* transfer(..))"</span>)<span class="comment">// 切入点表达式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">// 切入点签名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 申明切入点，匹配UserDao所有方法调用</span></span><br><span class="line"><span class="comment">     * execution匹配方法执行连接点</span></span><br><span class="line"><span class="comment">     * within:将匹配限制为特定类型中的连接点</span></span><br><span class="line"><span class="comment">     * args：参数</span></span><br><span class="line"><span class="comment">     * target：目标对象</span></span><br><span class="line"><span class="comment">     * this：代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.yao.dao.UserDao.*(..))"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Advice通知"><a href="#Advice通知" class="headerlink" title="Advice通知"></a>Advice通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AspectJ切入点指示符（PCD）："><a href="#AspectJ切入点指示符（PCD）：" class="headerlink" title="AspectJ切入点指示符（PCD）："></a>AspectJ切入点指示符（PCD）：</h4><h5 id="execution"><a href="#execution" class="headerlink" title="execution"></a>execution</h5><p>用于匹配方法执行的连接点。这是使用Spring AOP时要使用的主要切入点指示符。最小粒度方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</span><br><span class="line"></span><br><span class="line">这里问号表示当前项可以有也可以没有，其中各项的语义如下</span><br><span class="line">modifiers-pattern：方法的可见性，如public，protected；</span><br><span class="line">ret-type-pattern：方法的返回值类型，如int，void等；</span><br><span class="line">declaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect；</span><br><span class="line">name-pattern：方法名类型，如buisinessService()；</span><br><span class="line">param-pattern：方法的参数类型，如java.lang.String；</span><br><span class="line">throws-pattern：方法抛出的异常类型，如java.lang.Exception；</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">@Pointcut(&quot;execution(* com.chenss.dao.*.*(..))&quot;)&#x2F;&#x2F;匹配com.chenss.dao包下的任意接口和类的任意方法</span><br><span class="line">@Pointcut(&quot;execution(public * com.chenss.dao.*.*(..))&quot;)&#x2F;&#x2F;匹配com.chenss.dao包下的任意接口和类的public方法</span><br><span class="line">@Pointcut(&quot;execution(public * com.chenss.dao.*.*())&quot;)&#x2F;&#x2F;匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法</span><br><span class="line">@Pointcut(&quot;execution(* com.chenss.dao.*.*(java.lang.String, ..))&quot;)&#x2F;&#x2F;匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法</span><br><span class="line">@Pointcut(&quot;execution(* com.chenss.dao.*.*(java.lang.String))&quot;)&#x2F;&#x2F;匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span><br><span class="line">@Pointcut(&quot;execution(* com.chenss.dao.*.*(java.lang.String))&quot;)&#x2F;&#x2F;匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span><br><span class="line">@Pointcut(&quot;execution(public * *(..))&quot;)&#x2F;&#x2F;匹配任意的public方法</span><br><span class="line">@Pointcut(&quot;execution(* te*(..))&quot;)&#x2F;&#x2F;匹配任意的以te开头的方法</span><br><span class="line">@Pointcut(&quot;execution(* com.chenss.dao.IndexDao.*(..))&quot;)&#x2F;&#x2F;匹配com.chenss.dao.IndexDao接口中任意的方法</span><br><span class="line">@Pointcut(&quot;execution(* com.chenss.dao..*.*(..))&quot;)&#x2F;&#x2F;匹配com.chenss.dao包及其子包中任意的方法</span><br></pre></td></tr></table></figure>
<h5 id="within"><a href="#within" class="headerlink" title="within"></a>within</h5><p>将匹配限制为某些类型内的连接点（使用Spring AOP时，在匹配类型内声明的方法的执行）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等</span><br><span class="line">@Pointcut(&quot;within(com.chenss.dao.*)&quot;)&#x2F;&#x2F;匹配com.chenss.dao包中的任意方法</span><br><span class="line">@Pointcut(&quot;within(com.chenss.dao..*)&quot;)&#x2F;&#x2F;匹配com.chenss.dao包及其子包中的任意方法</span><br></pre></td></tr></table></figure>
<h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>限制匹配到连接点（使用Spring AOP时方法的执行）的匹配，其中bean引用（Spring AOP代理）是给定类型的实例。</p>
<p>JDK代理时，指向接口和代理类proxy，cglib代理时 指向接口和子类(不使用proxy)</p>
<h5 id="target"><a href="#target" class="headerlink" title="target"></a>target</h5><p>在目标对象（代理的应用程序对象）是给定类型的实例的情况下，将匹配限制为连接点（使用Spring AOP时方法的执行）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果配置设置proxyTargetClass&#x3D;false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理</span><br><span class="line"> JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。</span><br><span class="line"> </span><br><span class="line">而CGLIB继承被代理的类来实现。</span><br><span class="line"> 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。</span><br><span class="line"> 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。</span><br><span class="line"></span><br><span class="line">@Pointcut(&quot;target(com.chenss.dao.IndexDaoImpl)&quot;)&#x2F;&#x2F;目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类</span><br><span class="line">@Pointcut(&quot;this(com.chenss.dao.IndexDaoImpl)&quot;)&#x2F;&#x2F;当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个</span><br><span class="line">@Pointcut(&quot;@target(com.chenss.anno.Chenss)&quot;)&#x2F;&#x2F;具有@Chenss的目标对象中的任意方法</span><br><span class="line">@Pointcut(&quot;@within(com.chenss.anno.Chenss)&quot;)&#x2F;&#x2F;等同于@targ</span><br></pre></td></tr></table></figure>
<h5 id="args"><a href="#args" class="headerlink" title="args"></a>args</h5><p>在参数为给定类型的实例的情况下，将匹配指定参数类型和指定参数数量的方法，与包名和类名无关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * args同execution不同的地方在于：</span><br><span class="line"> * args匹配的是运行时传递给方法的参数类型</span><br><span class="line"> * execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Pointcut(&quot;args(java.io.Serializable)&quot;)&#x2F;&#x2F;匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配</span><br><span class="line">@Pointcut(&quot;@args(com.chenss.anno.Chenss)&quot;)&#x2F;&#x2F;接受一个参数，并且传递的参数的运行时类型具有@Classified</span><br></pre></td></tr></table></figure>
<h5 id="target-1"><a href="#target-1" class="headerlink" title="@target"></a>@target</h5><p>在执行对象的类具有给定类型的注释的情况下，将匹配限制为连接点（使用Spring AOP时方法的执行）。</p>
<h5 id="args-1"><a href="#args-1" class="headerlink" title="@args"></a>@args</h5><p>限制匹配的连接点（使用Spring AOP时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注释。</p>
<h5 id="within-1"><a href="#within-1" class="headerlink" title="@within"></a>@within</h5><p>将匹配限制为具有给定注释的类型内的连接点（使用Spring AOP时，使用给定注释的类型中声明的方法的执行）。</p>
<h5 id="annotation"><a href="#annotation" class="headerlink" title="@annotation"></a>@annotation</h5><p>将匹配限制在连接点的主题（Spring AOP中正在执行的方法）具有给定注释的连接点上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">作用方法级别 上述所有表达式都有@ 比如@Target(里面是一个注解类xx，表示所有加了xx注解的类，和包名无关)</span><br><span class="line"></span><br><span class="line">注意:上述所有的表达式可以混合使用,|| &amp;&amp; !</span><br><span class="line"></span><br><span class="line">@Pointcut(&quot; @annotation(org.springframework.transaction.annotation.Transactional)&quot;)&#x2F;&#x2F;匹配带有org.springframework.transaction.annotation.Transactional注解的方法</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2019/01/11/Redisson%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/11/Redisson%E8%AF%A6%E8%A7%A3/" itemprop="url">Redisson详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T00:00:00+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。</p>
<p>Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><h3 id="1、程序配置方式"><a href="#1、程序配置方式" class="headerlink" title="1、程序配置方式"></a>1、程序配置方式</h3><p>通过类代码来构建配置：通过构建Config对象实例来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.setTransportMode(TransportMode.EPOLL);</span><br><span class="line">config.useClusterServers()</span><br><span class="line">      <span class="comment">//可以用"rediss://"来启用SSL连接</span></span><br><span class="line">      .addNodeAddress(<span class="string">"redis://127.0.0.1:7181"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2、配置文件方式"><a href="#2、配置文件方式" class="headerlink" title="2、配置文件方式"></a>2、配置文件方式</h3><p>Redisson的配置文件可以是JSON格式或YAML格式。 可以通过调用Config.fromJSON方法并指定一个File实例来实现读取JSON格式的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Config config &#x3D; Config.fromJSON(new File(&quot;config-file.json&quot;));</span><br><span class="line">RedissonClient redisson &#x3D; Redisson.create(config);</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Config config &#x3D; Config.fromYAML(new File(&quot;config-file.yaml&quot;));</span><br><span class="line">RedissonClient redisson &#x3D; Redisson.create(config);</span><br></pre></td></tr></table></figure>
<p> 通过Spring XML命名空间配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client&gt;</span><br><span class="line">    &lt;redisson:single-server ... &#x2F;&gt;</span><br><span class="line">    &lt;!-- 或者 --&gt;</span><br><span class="line">    &lt;redisson:master-slave-servers ... &#x2F;&gt;</span><br><span class="line">    &lt;!-- 或者 --&gt;</span><br><span class="line">    &lt;redisson:sentinel-servers ... &#x2F;&gt;</span><br><span class="line">    &lt;!-- 或者 --&gt;</span><br><span class="line">    &lt;redisson:cluster-servers ... &#x2F;&gt;</span><br><span class="line">    &lt;!-- 或者 --&gt;</span><br><span class="line">    &lt;redisson:replicated-servers ... &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3、常用设置"><a href="#3、常用设置" class="headerlink" title="3、常用设置"></a>3、常用设置</h3><p>以下是关于org.redisson.Config类的配置参数，它适用于所有Redis组态模式（单机，集群和哨兵）</p>
<h4 id="codec（编码）"><a href="#codec（编码）" class="headerlink" title="codec（编码）"></a>codec（编码）</h4><p>默认值: org.redisson.codec.JsonJacksonCodec</p>
<p>可选：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">编码类名称	说明</span><br><span class="line">org.redisson.codec.JsonJacksonCodec	Jackson JSON 编码 默认编码</span><br><span class="line">org.redisson.codec.AvroJacksonCodec	Avro 一个二进制的JSON编码</span><br><span class="line">org.redisson.codec.SmileJacksonCodec	Smile 另一个二进制的JSON编码</span><br><span class="line">org.redisson.codec.CborJacksonCodec	CBOR 又一个二进制的JSON编码</span><br><span class="line">org.redisson.codec.MsgPackJacksonCodec	MsgPack 再来一个二进制的JSON编码</span><br><span class="line">org.redisson.codec.IonJacksonCodec	Amazon Ion 亚马逊的Ion编码，格式与JSON类似</span><br><span class="line">org.redisson.codec.KryoCodec	Kryo 二进制对象序列化编码</span><br><span class="line">org.redisson.codec.SerializationCodec	JDK序列化编码</span><br><span class="line">org.redisson.codec.FstCodec	FST 10倍于JDK序列化性能而且100%兼容的编码</span><br><span class="line">org.redisson.codec.LZ4Codec	LZ4 压缩型序列化对象编码</span><br><span class="line">org.redisson.codec.SnappyCodec	Snappy 另一个压缩型序列化对象编码</span><br><span class="line">org.redisson.client.codec.JsonJacksonMapCodec	基于Jackson的映射类使用的编码。可用于避免序列化类的信息，以及用于解决使用byte[]遇到的问题。</span><br><span class="line">org.redisson.client.codec.StringCodec	纯字符串编码（无转换）</span><br><span class="line">org.redisson.client.codec.LongCodec	纯整长型数字编码（无转换）</span><br><span class="line">org.redisson.client.codec.ByteArrayCodec	字节数组编码</span><br><span class="line">org.redisson.codec.CompositeCodec	用来组合多种不同编码在一起</span><br></pre></td></tr></table></figure>
<h4 id="threads（线程池数量）"><a href="#threads（线程池数量）" class="headerlink" title="threads（线程池数量）"></a>threads（线程池数量）</h4><p>默认值: 当前处理核数量 * 2</p>
<p>这个线程池数量被所有RTopic对象监听器，RRemoteService调用者和RExecutorService任务共同共享。</p>
<h4 id="nettyThreads-（Netty线程池数量）"><a href="#nettyThreads-（Netty线程池数量）" class="headerlink" title="nettyThreads （Netty线程池数量）"></a>nettyThreads （Netty线程池数量）</h4><p>默认值: 当前处理核数量 * 2</p>
<p>这个线程池数量是在一个Redisson实例内，被其创建的所有分布式数据类型和服务，以及底层客户端所一同共享的线程池里保存的线程数量。</p>
<h4 id="executor（线程池）"><a href="#executor（线程池）" class="headerlink" title="executor（线程池）"></a>executor（线程池）</h4><p>单独提供一个用来执行所有RTopic对象监听器，RRemoteService调用者和RExecutorService任务的线程池（ExecutorService）实例。</p>
<h4 id="eventLoopGroup"><a href="#eventLoopGroup" class="headerlink" title="eventLoopGroup"></a>eventLoopGroup</h4><p>用于特别指定一个EventLoopGroup. EventLoopGroup是用来处理所有通过Netty与Redis服务之间的连接发送和接受的消息。每一个Redisson都会在默认情况下自己创建管理一个EventLoopGroup实例。因此，如果在同一个JVM里面可能存在多个Redisson实例的情况下，采取这个配置实现多个Redisson实例共享一个EventLoopGroup的目的。</p>
<p>只有io.netty.channel.epoll.EpollEventLoopGroup或io.netty.channel.nio.NioEventLoopGroup才是允许的类型。</p>
<h4 id="transportMode（传输模式）"><a href="#transportMode（传输模式）" class="headerlink" title="transportMode（传输模式）"></a>transportMode（传输模式）</h4><p>默认值：TransportMode.NIO</p>
<p>可选参数：<br>TransportMode.NIO,<br>TransportMode.EPOLL - 需要依赖里有netty-transport-native-epoll包（Linux） TransportMode.KQUEUE - 需要依赖里有 netty-transport-native-kqueue包（macOS）</p>
<h4 id="lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）"><a href="#lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）" class="headerlink" title="lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）"></a>lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）</h4><p>默认值：30000</p>
<p>监控锁的看门狗超时时间单位为毫秒。该参数只适用于分布式锁的加锁请求中未明确使用leaseTimeout参数的情况。如果该看门口未使用lockWatchdogTimeout去重新调整一个分布式锁的lockWatchdogTimeout超时，那么这个锁将变为失效状态。这个参数可以用来避免由Redisson客户端节点宕机或其他原因造成死锁的情况。</p>
<h4 id="keepPubSubOrder（保持订阅发布顺序）"><a href="#keepPubSubOrder（保持订阅发布顺序）" class="headerlink" title="keepPubSubOrder（保持订阅发布顺序）"></a>keepPubSubOrder（保持订阅发布顺序）</h4><p>默认值：true</p>
<p>通过该参数来修改是否按订阅发布消息的接收顺序出来消息，如果选否将对消息实行并行处理，该参数只适用于订阅发布消息的情况。</p>
<h4 id="performanceMode（高性能模式）"><a href="#performanceMode（高性能模式）" class="headerlink" title="performanceMode（高性能模式）"></a>performanceMode（高性能模式）</h4><p>默认值：HIGHER_THROUGHPUT</p>
<p>用来指定高性能引擎的行为。由于该变量值的选用与使用场景息息相关（NORMAL除外）我们建议对每个参数值都进行尝试。</p>
<p>该参数仅限于Redisson PRO版本。</p>
<p>可选模式：<br>HIGHER_THROUGHPUT - 将高性能引擎切换到 高通量 模式。 LOWER_LATENCY_AUTO - 将高性能引擎切换到 低延时 模式并自动探测最佳设定。 LOWER_LATENCY_MODE_1 - 将高性能引擎切换到 低延时 模式并调整到预设模式1。 LOWER_LATENCY_MODE_2 - 将高性能引擎切换到 低延时 模式并调整到预设模式2。 NORMAL - 将高性能引擎切换到 普通 模式</p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><h3 id="1、程序方式"><a href="#1、程序方式" class="headerlink" title="1、程序方式"></a>1、程序方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useClusterServers()</span><br><span class="line">    .setScanInterval(<span class="number">2000</span>) <span class="comment">// 集群状态扫描间隔时间，单位是毫秒</span></span><br><span class="line">    <span class="comment">//可以用"rediss://"来启用SSL连接</span></span><br><span class="line">    .addNodeAddress(<span class="string">"redis://127.0.0.1:7000"</span>, <span class="string">"redis://127.0.0.1:7001"</span>)</span><br><span class="line">    .addNodeAddress(<span class="string">"redis://127.0.0.1:7002"</span>);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br></pre></td></tr></table></figure>
<h3 id="2、通过文件配置集群模式"><a href="#2、通过文件配置集群模式" class="headerlink" title="2、通过文件配置集群模式"></a>2、通过文件配置集群模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;clusterServersConfig&quot;:&#123;</span><br><span class="line">      &quot;idleConnectionTimeout&quot;:10000,</span><br><span class="line">      &quot;pingTimeout&quot;:1000,</span><br><span class="line">      &quot;connectTimeout&quot;:10000,</span><br><span class="line">      &quot;timeout&quot;:3000,</span><br><span class="line">      &quot;retryAttempts&quot;:3,</span><br><span class="line">      &quot;retryInterval&quot;:1500,</span><br><span class="line">      &quot;reconnectionTimeout&quot;:3000,</span><br><span class="line">      &quot;failedAttempts&quot;:3,</span><br><span class="line">      &quot;password&quot;:null,</span><br><span class="line">      &quot;subscriptionsPerConnection&quot;:5,</span><br><span class="line">      &quot;clientName&quot;:null,</span><br><span class="line">      &quot;loadBalancer&quot;:&#123;</span><br><span class="line">         &quot;class&quot;:&quot;org.redisson.connection.balancer.RoundRobinLoadBalancer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;slaveSubscriptionConnectionMinimumIdleSize&quot;:1,</span><br><span class="line">      &quot;slaveSubscriptionConnectionPoolSize&quot;:50,</span><br><span class="line">      &quot;slaveConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;slaveConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;masterConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;masterConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;readMode&quot;:&quot;SLAVE&quot;,</span><br><span class="line">      &quot;nodeAddresses&quot;:[</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:7004&quot;,</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:7001&quot;,</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:7000&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;scanInterval&quot;:1000</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;threads&quot;:0,</span><br><span class="line">   &quot;nettyThreads&quot;: 0,</span><br><span class="line">   &quot;codec&quot;:&#123;</span><br><span class="line">      &quot;class&quot;:&quot;org.redisson.codec.JsonJacksonCodec&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;transportMode&quot;:&quot;NIO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">clusterServersConfig:</span><br><span class="line">  idleConnectionTimeout: 10000</span><br><span class="line">  pingTimeout: 1000</span><br><span class="line">  connectTimeout: 10000</span><br><span class="line">  timeout: 3000</span><br><span class="line">  retryAttempts: 3</span><br><span class="line">  retryInterval: 1500</span><br><span class="line">  reconnectionTimeout: 3000</span><br><span class="line">  failedAttempts: 3</span><br><span class="line">  password: null</span><br><span class="line">  subscriptionsPerConnection: 5</span><br><span class="line">  clientName: null</span><br><span class="line">  loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; &#123;&#125;</span><br><span class="line">  slaveSubscriptionConnectionMinimumIdleSize: 1</span><br><span class="line">  slaveSubscriptionConnectionPoolSize: 50</span><br><span class="line">  slaveConnectionMinimumIdleSize: 32</span><br><span class="line">  slaveConnectionPoolSize: 64</span><br><span class="line">  masterConnectionMinimumIdleSize: 32</span><br><span class="line">  masterConnectionPoolSize: 64</span><br><span class="line">  readMode: &quot;SLAVE&quot;</span><br><span class="line">  nodeAddresses:</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:7004&quot;</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:7001&quot;</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:7000&quot;</span><br><span class="line">  scanInterval: 1000</span><br><span class="line">threads: 0</span><br><span class="line">nettyThreads: 0</span><br><span class="line">codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;</span><br><span class="line">&quot;transportMode&quot;:&quot;NIO&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client</span><br><span class="line">    id&#x3D;&quot;redisson&quot;</span><br><span class="line">    name&#x3D;&quot;redisson1,redisson2&quot;</span><br><span class="line">    threads&#x3D;&quot;0&quot;</span><br><span class="line">    netty-threads&#x3D;&quot;0&quot;</span><br><span class="line">    codec-ref&#x3D;&quot;myCodec&quot; </span><br><span class="line">    transport-mode&#x3D;&quot;NIO&quot;</span><br><span class="line">    redisson-reference-enabled&#x3D;&quot;true&quot;</span><br><span class="line">    codec-provider-ref&#x3D;&quot;myCodecProvider&quot;</span><br><span class="line">    resolver-provider-ref&#x3D;&quot;myResolverProvider&quot;</span><br><span class="line">    executor-ref&#x3D;&quot;myExecutor&quot;</span><br><span class="line">    event-loop-group-ref&#x3D;&quot;myEventLoopGroup&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    这里的name属性和qualifier子元素不能同时使用。</span><br><span class="line"></span><br><span class="line">    id和name的属性都可以被用来作为qualifier的备选值。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--&lt;qualifier value&#x3D;&quot;redisson3&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    &lt;redisson:cluster-servers</span><br><span class="line">        idle-connection-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        ping-timeout&#x3D;&quot;1000&quot;</span><br><span class="line">        connect-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        retry-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        retry-interval&#x3D;&quot;1500&quot;</span><br><span class="line">        reconnection-timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        failed-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        password&#x3D;&quot;do_not_use_if_it_is_not_set&quot;</span><br><span class="line">        subscriptions-per-connection&#x3D;&quot;5&quot;</span><br><span class="line">        client-name&#x3D;&quot;none&quot;</span><br><span class="line">        load-balancer-ref&#x3D;&quot;myLoadBalancer&quot;</span><br><span class="line">        subscription-connection-minimum-idle-size&#x3D;&quot;1&quot;</span><br><span class="line">        subscription-connection-pool-size&#x3D;&quot;50&quot;</span><br><span class="line">        slave-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        slave-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        master-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        master-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        read-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        subscription-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        scan-interval&#x3D;&quot;1000&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;redisson:cluster-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最基本配置 --&gt;</span><br><span class="line">&lt;redisson:client&gt;</span><br><span class="line">    &lt;redisson:cluster-servers&gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;&#x2F;redisson:cluster-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3、设置"><a href="#3、设置" class="headerlink" title="3、设置"></a>3、设置</h3><p>Redis集群组态的最低要求是必须有三个主节点。Redisson的集群模式的使用方法如下：ClusterServersConfig clusterConfig = config.useClusterServers();</p>
<p>ClusterServersConfig 类的设置参数如下：</p>
<h4 id="nodeAddresses（添加节点地址）"><a href="#nodeAddresses（添加节点地址）" class="headerlink" title="nodeAddresses（添加节点地址）"></a>nodeAddresses（添加节点地址）</h4><p>可以通过host:port的格式来添加Redis集群节点的地址。多个节点可以一次性批量添加。</p>
<h4 id="scanInterval（集群扫描间隔时间）"><a href="#scanInterval（集群扫描间隔时间）" class="headerlink" title="scanInterval（集群扫描间隔时间）"></a>scanInterval（集群扫描间隔时间）</h4><p>默认值： 1000</p>
<p>对Redis集群节点状态扫描的时间间隔。单位是毫秒。</p>
<h4 id="slots（分片数量）"><a href="#slots（分片数量）" class="headerlink" title="slots（分片数量）"></a>slots（分片数量）</h4><p>默认值： 231 用于指定数据分片过程中的分片数量。支持数据分片/框架结构有：集（Set）、映射（Map）、BitSet、Bloom filter, Spring Cache和Hibernate Cache等.</p>
<h4 id="readMode（读取操作的负载均衡模式）"><a href="#readMode（读取操作的负载均衡模式）" class="headerlink" title="readMode（读取操作的负载均衡模式）"></a>readMode（读取操作的负载均衡模式）</h4><p>默认值： SLAVE（只在从服务节点里读取）</p>
<p>注：在从服务节点里读取的数据说明已经至少有两个节点保存了该数据，确保了数据的高可用性。</p>
<p>设置读取操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里读取。 MASTER - 只在主服务节点里读取。 MASTER_SLAVE - 在主从服务节点里都可以读取。</p>
<h4 id="subscriptionMode（订阅操作的负载均衡模式）"><a href="#subscriptionMode（订阅操作的负载均衡模式）" class="headerlink" title="subscriptionMode（订阅操作的负载均衡模式）"></a>subscriptionMode（订阅操作的负载均衡模式）</h4><p>默认值：SLAVE（只在从服务节点里订阅）</p>
<p>设置订阅操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里订阅。 MASTER - 只在主服务节点里订阅。</p>
<h4 id="loadBalancer（负载均衡算法类的选择）"><a href="#loadBalancer（负载均衡算法类的选择）" class="headerlink" title="loadBalancer（负载均衡算法类的选择）"></a>loadBalancer（负载均衡算法类的选择）</h4><p>默认值： org.redisson.connection.balancer.RoundRobinLoadBalancer</p>
<p>在多Redis服务节点的环境里，可以选用以下几种负载均衡方式选择一个节点： org.redisson.connection.balancer.WeightedRoundRobinBalancer - 权重轮询调度算法 org.redisson.connection.balancer.RoundRobinLoadBalancer - 轮询调度算法 org.redisson.connection.balancer.RandomLoadBalancer - 随机调度算法</p>
<h4 id="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）"><a href="#subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）" class="headerlink" title="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）"></a>subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）</h4><p>默认值：1</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。</p>
<h4 id="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）"><a href="#subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）" class="headerlink" title="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）"></a>subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）</h4><p>默认值：50</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）"><a href="#slaveConnectionMinimumIdleSize（从节点最小空闲连接数）" class="headerlink" title="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）"></a>slaveConnectionMinimumIdleSize（从节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时读取反映速度。</p>
<h4 id="slaveConnectionPoolSize（从节点连接池大小）"><a href="#slaveConnectionPoolSize（从节点连接池大小）" class="headerlink" title="slaveConnectionPoolSize（从节点连接池大小）"></a>slaveConnectionPoolSize（从节点连接池大小）</h4><p>默认值：64</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="masterConnectionMinimumIdleSize（主节点最小空闲连接数）"><a href="#masterConnectionMinimumIdleSize（主节点最小空闲连接数）" class="headerlink" title="masterConnectionMinimumIdleSize（主节点最小空闲连接数）"></a>masterConnectionMinimumIdleSize（主节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多节点的环境里，每个 主节点的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。</p>
<h4 id="masterConnectionPoolSize（主节点连接池大小）"><a href="#masterConnectionPoolSize（主节点连接池大小）" class="headerlink" title="masterConnectionPoolSize（主节点连接池大小）"></a>masterConnectionPoolSize（主节点连接池大小）</h4><p>默认值：64</p>
<p>多主节点的环境里，每个 主节点的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="idleConnectionTimeout（连接空闲超时，单位：毫秒）"><a href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）" class="headerlink" title="idleConnectionTimeout（连接空闲超时，单位：毫秒）"></a>idleConnectionTimeout（连接空闲超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>如果当前连接池里的连接数量超过了最小空闲连接数，而同时有连接空闲时间超过了该数值，那么这些连接将会自动被关闭，并从连接池里去掉。时间单位是毫秒。</p>
<h4 id="connectTimeout（连接超时，单位：毫秒）"><a href="#connectTimeout（连接超时，单位：毫秒）" class="headerlink" title="connectTimeout（连接超时，单位：毫秒）"></a>connectTimeout（连接超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>同任何节点建立连接时的等待超时。时间单位是毫秒。</p>
<h4 id="timeout（命令等待超时，单位：毫秒）"><a href="#timeout（命令等待超时，单位：毫秒）" class="headerlink" title="timeout（命令等待超时，单位：毫秒）"></a>timeout（命令等待超时，单位：毫秒）</h4><p>默认值：3000</p>
<p>等待节点回复命令的时间。该时间从命令发送成功时开始计时。</p>
<h4 id="retryAttempts（命令失败重试次数）"><a href="#retryAttempts（命令失败重试次数）" class="headerlink" title="retryAttempts（命令失败重试次数）"></a>retryAttempts（命令失败重试次数）</h4><p>默认值：3</p>
<p>如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。</p>
<h4 id="retryInterval（命令重试发送时间间隔，单位：毫秒）"><a href="#retryInterval（命令重试发送时间间隔，单位：毫秒）" class="headerlink" title="retryInterval（命令重试发送时间间隔，单位：毫秒）"></a>retryInterval（命令重试发送时间间隔，单位：毫秒）</h4><p>默认值：1500</p>
<p>在一条命令发送失败以后，等待重试发送的时间间隔。时间单位是毫秒。</p>
<h4 id="reconnectionTimeout（重新连接时间间隔，单位：毫秒）"><a href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）" class="headerlink" title="reconnectionTimeout（重新连接时间间隔，单位：毫秒）"></a>reconnectionTimeout（重新连接时间间隔，单位：毫秒）</h4><p>默认值：3000</p>
<p>当与某个节点的连接断开时，等待与其重新建立连接的时间间隔。时间单位是毫秒。</p>
<h4 id="failedAttempts（执行失败最大次数）"><a href="#failedAttempts（执行失败最大次数）" class="headerlink" title="failedAttempts（执行失败最大次数）"></a>failedAttempts（执行失败最大次数）</h4><p>默认值：3</p>
<p>在某个节点执行相同或不同命令时，连续 失败 failedAttempts（执行失败最大次数） 时，该节点将被从可用节点列表里清除，直到 reconnectionTimeout（重新连接时间间隔） 超时以后再次尝试。</p>
<h4 id="password（密码）"><a href="#password（密码）" class="headerlink" title="password（密码）"></a>password（密码）</h4><p>默认值：null</p>
<p>用于节点身份验证的密码。</p>
<h4 id="subscriptionsPerConnection（单个连接最大订阅数量）"><a href="#subscriptionsPerConnection（单个连接最大订阅数量）" class="headerlink" title="subscriptionsPerConnection（单个连接最大订阅数量）"></a>subscriptionsPerConnection（单个连接最大订阅数量）</h4><p>默认值：5</p>
<p>每个连接的最大订阅数量。</p>
<h4 id="clientName（客户端名称）"><a href="#clientName（客户端名称）" class="headerlink" title="clientName（客户端名称）"></a>clientName（客户端名称）</h4><p>默认值：null</p>
<p>在Redis节点里显示的客户端名称。</p>
<h4 id="sslEnableEndpointIdentification（启用SSL终端识别）"><a href="#sslEnableEndpointIdentification（启用SSL终端识别）" class="headerlink" title="sslEnableEndpointIdentification（启用SSL终端识别）"></a>sslEnableEndpointIdentification（启用SSL终端识别）</h4><p>默认值：true</p>
<p>开启SSL终端识别能力。</p>
<h4 id="sslProvider（SSL实现方式）"><a href="#sslProvider（SSL实现方式）" class="headerlink" title="sslProvider（SSL实现方式）"></a>sslProvider（SSL实现方式）</h4><p>默认值：JDK</p>
<p>确定采用哪种方式（JDK或OPENSSL）来实现SSL连接。</p>
<h4 id="sslTruststore（SSL信任证书库路径）"><a href="#sslTruststore（SSL信任证书库路径）" class="headerlink" title="sslTruststore（SSL信任证书库路径）"></a>sslTruststore（SSL信任证书库路径）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的路径。</p>
<h4 id="sslTruststorePassword（SSL信任证书库密码）"><a href="#sslTruststorePassword（SSL信任证书库密码）" class="headerlink" title="sslTruststorePassword（SSL信任证书库密码）"></a>sslTruststorePassword（SSL信任证书库密码）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的密码。</p>
<h4 id="sslKeystore（SSL钥匙库路径）"><a href="#sslKeystore（SSL钥匙库路径）" class="headerlink" title="sslKeystore（SSL钥匙库路径）"></a>sslKeystore（SSL钥匙库路径）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的路径。</p>
<h4 id="sslKeystorePassword（SSL钥匙库密码）"><a href="#sslKeystorePassword（SSL钥匙库密码）" class="headerlink" title="sslKeystorePassword（SSL钥匙库密码）"></a>sslKeystorePassword（SSL钥匙库密码）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的密码。</p>
<h2 id="单Redis节点模式"><a href="#单Redis节点模式" class="headerlink" title="单Redis节点模式"></a>单Redis节点模式</h2><h3 id="1、程序化配置"><a href="#1、程序化配置" class="headerlink" title="1、程序化配置"></a>1、程序化配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认连接地址 127.0.0.1:6379</span></span><br><span class="line">RedissonClient redisson = Redisson.create();</span><br><span class="line"></span><br><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">"myredisserver:6379"</span>);</span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br></pre></td></tr></table></figure>
<h3 id="2、单节点设置"><a href="#2、单节点设置" class="headerlink" title="2、单节点设置"></a>2、单节点设置</h3><p>SingleServerConfig 类的设置参数如下：</p>
<h4 id="address（节点地址）"><a href="#address（节点地址）" class="headerlink" title="address（节点地址）"></a>address（节点地址）</h4><p>可以通过host:port的格式来指定节点地址。</p>
<h4 id="subscriptionConnectionMinimumIdleSize（发布和订阅连接的最小空闲连接数）"><a href="#subscriptionConnectionMinimumIdleSize（发布和订阅连接的最小空闲连接数）" class="headerlink" title="subscriptionConnectionMinimumIdleSize（发布和订阅连接的最小空闲连接数）"></a>subscriptionConnectionMinimumIdleSize（发布和订阅连接的最小空闲连接数）</h4><p>默认值：1</p>
<p>用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。</p>
<h4 id="subscriptionConnectionPoolSize（发布和订阅连接池大小）"><a href="#subscriptionConnectionPoolSize（发布和订阅连接池大小）" class="headerlink" title="subscriptionConnectionPoolSize（发布和订阅连接池大小）"></a>subscriptionConnectionPoolSize（发布和订阅连接池大小）</h4><p>默认值：50</p>
<p>用于发布和订阅连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="connectionMinimumIdleSize（最小空闲连接数）"><a href="#connectionMinimumIdleSize（最小空闲连接数）" class="headerlink" title="connectionMinimumIdleSize（最小空闲连接数）"></a>connectionMinimumIdleSize（最小空闲连接数）</h4><p>默认值：32</p>
<p>最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。</p>
<h4 id="connectionPoolSize（连接池大小）"><a href="#connectionPoolSize（连接池大小）" class="headerlink" title="connectionPoolSize（连接池大小）"></a>connectionPoolSize（连接池大小）</h4><p>默认值：64</p>
<p>连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="dnsMonitoring（是否启用DNS监测）"><a href="#dnsMonitoring（是否启用DNS监测）" class="headerlink" title="dnsMonitoring（是否启用DNS监测）"></a>dnsMonitoring（是否启用DNS监测）</h4><p>默认值：false</p>
<p>在启用该功能以后，Redisson将会监测DNS的变化情况。</p>
<h4 id="dnsMonitoringInterval（DNS监测时间间隔，单位：毫秒）"><a href="#dnsMonitoringInterval（DNS监测时间间隔，单位：毫秒）" class="headerlink" title="dnsMonitoringInterval（DNS监测时间间隔，单位：毫秒）"></a>dnsMonitoringInterval（DNS监测时间间隔，单位：毫秒）</h4><p>默认值：5000</p>
<p>监测DNS的变化情况的时间间隔。</p>
<h4 id="idleConnectionTimeout（连接空闲超时，单位：毫秒）-1"><a href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）-1" class="headerlink" title="idleConnectionTimeout（连接空闲超时，单位：毫秒）"></a>idleConnectionTimeout（连接空闲超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>如果当前连接池里的连接数量超过了最小空闲连接数，而同时有连接空闲时间超过了该数值，那么这些连接将会自动被关闭，并从连接池里去掉。时间单位是毫秒。</p>
<h4 id="connectTimeout（连接超时，单位：毫秒）-1"><a href="#connectTimeout（连接超时，单位：毫秒）-1" class="headerlink" title="connectTimeout（连接超时，单位：毫秒）"></a>connectTimeout（连接超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>同节点建立连接时的等待超时。时间单位是毫秒。</p>
<h4 id="timeout（命令等待超时，单位：毫秒）-1"><a href="#timeout（命令等待超时，单位：毫秒）-1" class="headerlink" title="timeout（命令等待超时，单位：毫秒）"></a>timeout（命令等待超时，单位：毫秒）</h4><p>默认值：3000</p>
<p>等待节点回复命令的时间。该时间从命令发送成功时开始计时。</p>
<h4 id="retryAttempts（命令失败重试次数）-1"><a href="#retryAttempts（命令失败重试次数）-1" class="headerlink" title="retryAttempts（命令失败重试次数）"></a>retryAttempts（命令失败重试次数）</h4><p>默认值：3</p>
<p>如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。</p>
<h4 id="retryInterval（命令重试发送时间间隔，单位：毫秒）-1"><a href="#retryInterval（命令重试发送时间间隔，单位：毫秒）-1" class="headerlink" title="retryInterval（命令重试发送时间间隔，单位：毫秒）"></a>retryInterval（命令重试发送时间间隔，单位：毫秒）</h4><p>默认值：1500</p>
<p>在一条命令发送失败以后，等待重试发送的时间间隔。时间单位是毫秒。</p>
<h4 id="reconnectionTimeout（重新连接时间间隔，单位：毫秒）-1"><a href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）-1" class="headerlink" title="reconnectionTimeout（重新连接时间间隔，单位：毫秒）"></a>reconnectionTimeout（重新连接时间间隔，单位：毫秒）</h4><p>默认值：3000</p>
<p>当与某个节点的连接断开时，等待与其重新建立连接的时间间隔。时间单位是毫秒。</p>
<h4 id="failedAttempts（执行失败最大次数）-1"><a href="#failedAttempts（执行失败最大次数）-1" class="headerlink" title="failedAttempts（执行失败最大次数）"></a>failedAttempts（执行失败最大次数）</h4><p>默认值：3</p>
<p>在某个节点执行相同或不同命令时，连续 失败 failedAttempts（执行失败最大次数） 时，该节点将被从可用节点列表里清除，直到 reconnectionTimeout（重新连接时间间隔） 超时以后再次尝试。</p>
<h4 id="database（数据库编号）"><a href="#database（数据库编号）" class="headerlink" title="database（数据库编号）"></a>database（数据库编号）</h4><p>默认值：0</p>
<p>尝试连接的数据库编号。</p>
<h4 id="password（密码）-1"><a href="#password（密码）-1" class="headerlink" title="password（密码）"></a>password（密码）</h4><p>默认值：null</p>
<p>用于节点身份验证的密码。</p>
<h4 id="subscriptionsPerConnection（单个连接最大订阅数量）-1"><a href="#subscriptionsPerConnection（单个连接最大订阅数量）-1" class="headerlink" title="subscriptionsPerConnection（单个连接最大订阅数量）"></a>subscriptionsPerConnection（单个连接最大订阅数量）</h4><p>默认值：5</p>
<p>每个连接的最大订阅数量。</p>
<h4 id="clientName（客户端名称）-1"><a href="#clientName（客户端名称）-1" class="headerlink" title="clientName（客户端名称）"></a>clientName（客户端名称）</h4><p>默认值：null</p>
<p>在Redis节点里显示的客户端名称。</p>
<h4 id="sslEnableEndpointIdentification（启用SSL终端识别）-1"><a href="#sslEnableEndpointIdentification（启用SSL终端识别）-1" class="headerlink" title="sslEnableEndpointIdentification（启用SSL终端识别）"></a>sslEnableEndpointIdentification（启用SSL终端识别）</h4><p>默认值：true</p>
<p>开启SSL终端识别能力。</p>
<h4 id="sslProvider（SSL实现方式）-1"><a href="#sslProvider（SSL实现方式）-1" class="headerlink" title="sslProvider（SSL实现方式）"></a>sslProvider（SSL实现方式）</h4><p>默认值：JDK</p>
<p>确定采用哪种方式（JDK或OPENSSL）来实现SSL连接。</p>
<h4 id="sslTruststore（SSL信任证书库路径）-1"><a href="#sslTruststore（SSL信任证书库路径）-1" class="headerlink" title="sslTruststore（SSL信任证书库路径）"></a>sslTruststore（SSL信任证书库路径）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的路径。</p>
<h4 id="sslTruststorePassword（SSL信任证书库密码）-1"><a href="#sslTruststorePassword（SSL信任证书库密码）-1" class="headerlink" title="sslTruststorePassword（SSL信任证书库密码）"></a>sslTruststorePassword（SSL信任证书库密码）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的密码。</p>
<h4 id="sslKeystore（SSL钥匙库路径）-1"><a href="#sslKeystore（SSL钥匙库路径）-1" class="headerlink" title="sslKeystore（SSL钥匙库路径）"></a>sslKeystore（SSL钥匙库路径）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的路径。</p>
<h4 id="sslKeystorePassword（SSL钥匙库密码）-1"><a href="#sslKeystorePassword（SSL钥匙库密码）-1" class="headerlink" title="sslKeystorePassword（SSL钥匙库密码）"></a>sslKeystorePassword（SSL钥匙库密码）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的密码。</p>
<h3 id="3、配置文件"><a href="#3、配置文件" class="headerlink" title="3、配置文件"></a>3、配置文件</h3><p>配置单节点模式可以通过指定一个JSON格式的文件来实现。以下是JSON格式的配置文件样本。文件中的字段名称必须与SingleServerConfig和Config对象里的字段名称相符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;singleServerConfig&quot;:&#123;</span><br><span class="line">      &quot;idleConnectionTimeout&quot;:10000,</span><br><span class="line">      &quot;pingTimeout&quot;:1000,</span><br><span class="line">      &quot;connectTimeout&quot;:10000,</span><br><span class="line">      &quot;timeout&quot;:3000,</span><br><span class="line">      &quot;retryAttempts&quot;:3,</span><br><span class="line">      &quot;retryInterval&quot;:1500,</span><br><span class="line">      &quot;reconnectionTimeout&quot;:3000,</span><br><span class="line">      &quot;failedAttempts&quot;:3,</span><br><span class="line">      &quot;password&quot;:null,</span><br><span class="line">      &quot;subscriptionsPerConnection&quot;:5,</span><br><span class="line">      &quot;clientName&quot;:null,</span><br><span class="line">      &quot;address&quot;: &quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;,</span><br><span class="line">      &quot;subscriptionConnectionMinimumIdleSize&quot;:1,</span><br><span class="line">      &quot;subscriptionConnectionPoolSize&quot;:50,</span><br><span class="line">      &quot;connectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;connectionPoolSize&quot;:64,</span><br><span class="line">      &quot;database&quot;:0,</span><br><span class="line">      &quot;dnsMonitoring&quot;:false,</span><br><span class="line">      &quot;dnsMonitoringInterval&quot;:5000</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;threads&quot;:0,</span><br><span class="line">   &quot;nettyThreads&quot;:0,</span><br><span class="line">   &quot;codec&quot;:&#123;</span><br><span class="line">      &quot;class&quot;:&quot;org.redisson.codec.JsonJacksonCodec&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;transportMode&quot;:&quot;NIO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">singleServerConfig:</span><br><span class="line">  idleConnectionTimeout: 10000</span><br><span class="line">  pingTimeout: 1000</span><br><span class="line">  connectTimeout: 10000</span><br><span class="line">  timeout: 3000</span><br><span class="line">  retryAttempts: 3</span><br><span class="line">  retryInterval: 1500</span><br><span class="line">  reconnectionTimeout: 3000</span><br><span class="line">  failedAttempts: 3</span><br><span class="line">  password: null</span><br><span class="line">  subscriptionsPerConnection: 5</span><br><span class="line">  clientName: null</span><br><span class="line">  address: &quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;</span><br><span class="line">  subscriptionConnectionMinimumIdleSize: 1</span><br><span class="line">  subscriptionConnectionPoolSize: 50</span><br><span class="line">  connectionMinimumIdleSize: 32</span><br><span class="line">  connectionPoolSize: 64</span><br><span class="line">  database: 0</span><br><span class="line">  dnsMonitoring: false</span><br><span class="line">  dnsMonitoringInterval: 5000</span><br><span class="line">threads: 0</span><br><span class="line">nettyThreads: 0</span><br><span class="line">codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;</span><br><span class="line">&quot;transportMode&quot;:&quot;NIO&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client</span><br><span class="line">    id&#x3D;&quot;redisson&quot;</span><br><span class="line">    name&#x3D;&quot;redisson1,redisson2&quot;</span><br><span class="line">    threads&#x3D;&quot;0&quot;</span><br><span class="line">    netty-threads&#x3D;&quot;0&quot;</span><br><span class="line">    codec-ref&#x3D;&quot;myCodec&quot; </span><br><span class="line">    transport-mode&#x3D;&quot;NIO&quot;</span><br><span class="line">    redisson-reference-enabled&#x3D;&quot;true&quot;</span><br><span class="line">    codec-provider-ref&#x3D;&quot;myCodecProvider&quot;</span><br><span class="line">    resolver-provider-ref&#x3D;&quot;myResolverProvider&quot;</span><br><span class="line">    executor-ref&#x3D;&quot;myExecutor&quot;</span><br><span class="line">    event-loop-group-ref&#x3D;&quot;myEventLoopGroup&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    这里的name属性和qualifier子元素不能同时使用。</span><br><span class="line"></span><br><span class="line">    id和name的属性都可以被用来作为qualifier的备选值。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--&lt;qualifier value&#x3D;&quot;redisson3&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    &lt;redisson:single-server</span><br><span class="line">        idle-connection-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        ping-timeout&#x3D;&quot;1000&quot;</span><br><span class="line">        connect-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        retry-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        retry-interval&#x3D;&quot;1500&quot;</span><br><span class="line">        reconnection-timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        failed-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        password&#x3D;&quot;do_not_use_if_it_is_not_set&quot;</span><br><span class="line">        subscriptions-per-connection&#x3D;&quot;5&quot;</span><br><span class="line">        client-name&#x3D;&quot;none&quot;            </span><br><span class="line">        address&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;</span><br><span class="line">        subscription-connection-minimum-idle-size&#x3D;&quot;1&quot;</span><br><span class="line">        subscription-connection-pool-size&#x3D;&quot;50&quot;</span><br><span class="line">        connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        database&#x3D;&quot;0&quot;</span><br><span class="line">        dns-monitoring&#x3D;&quot;false&quot;</span><br><span class="line">        dns-monitoring-interval&#x3D;&quot;5000&quot;</span><br><span class="line">    &#x2F;&gt;            </span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最基本配置 --&gt;</span><br><span class="line">&lt;!-- 默认地址是 127.0.0.1:6379 --&gt;</span><br><span class="line">&lt;redisson:client&gt;</span><br><span class="line">    &lt;redisson:single-server&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><h3 id="1、程序化配置-1"><a href="#1、程序化配置-1" class="headerlink" title="1、程序化配置"></a>1、程序化配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSentinelServers()</span><br><span class="line">    .setMasterName(<span class="string">"mymaster"</span>)</span><br><span class="line">    <span class="comment">//可以用"rediss://"来启用SSL连接</span></span><br><span class="line">    .addSentinelAddress(<span class="string">"127.0.0.1:26389"</span>, <span class="string">"127.0.0.1:26379"</span>)</span><br><span class="line">    .addSentinelAddress(<span class="string">"127.0.0.1:26319"</span>);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br></pre></td></tr></table></figure>
<h3 id="2、设置"><a href="#2、设置" class="headerlink" title="2、设置"></a>2、设置</h3><p>SentinelServersConfig 类的设置参数如下：</p>
<h4 id="dnsMonitoringInterval（DNS监控间隔，单位：毫秒）"><a href="#dnsMonitoringInterval（DNS监控间隔，单位：毫秒）" class="headerlink" title="dnsMonitoringInterval（DNS监控间隔，单位：毫秒）"></a>dnsMonitoringInterval（DNS监控间隔，单位：毫秒）</h4><p>默认值：5000</p>
<p>用来指定检查节点DNS变化的时间间隔。使用的时候应该确保JVM里的DNS数据的缓存时间保持在足够低的范围才有意义。用-1来禁用该功能。</p>
<h4 id="masterName（主服务器的名称）"><a href="#masterName（主服务器的名称）" class="headerlink" title="masterName（主服务器的名称）"></a>masterName（主服务器的名称）</h4><p>主服务器的名称是哨兵进程中用来监测主从服务切换情况的。</p>
<h4 id="addSentinelAddress（添加哨兵节点地址）"><a href="#addSentinelAddress（添加哨兵节点地址）" class="headerlink" title="addSentinelAddress（添加哨兵节点地址）"></a>addSentinelAddress（添加哨兵节点地址）</h4><p>可以通过host:port的格式来指定哨兵节点的地址。多个节点可以一次性批量添加。</p>
<h4 id="readMode（读取操作的负载均衡模式）-1"><a href="#readMode（读取操作的负载均衡模式）-1" class="headerlink" title="readMode（读取操作的负载均衡模式）"></a>readMode（读取操作的负载均衡模式）</h4><p>默认值： SLAVE（只在从服务节点里读取）</p>
<p>注：在从服务节点里读取的数据说明已经至少有两个节点保存了该数据，确保了数据的高可用性。</p>
<p>设置读取操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里读取。 MASTER - 只在主服务节点里读取。 MASTER_SLAVE - 在主从服务节点里都可以读取。</p>
<h4 id="subscriptionMode（订阅操作的负载均衡模式）-1"><a href="#subscriptionMode（订阅操作的负载均衡模式）-1" class="headerlink" title="subscriptionMode（订阅操作的负载均衡模式）"></a>subscriptionMode（订阅操作的负载均衡模式）</h4><p>默认值：SLAVE（只在从服务节点里订阅）</p>
<p>设置订阅操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里订阅。 MASTER - 只在主服务节点里订阅。</p>
<h4 id="loadBalancer（负载均衡算法类的选择）-1"><a href="#loadBalancer（负载均衡算法类的选择）-1" class="headerlink" title="loadBalancer（负载均衡算法类的选择）"></a>loadBalancer（负载均衡算法类的选择）</h4><p>默认值： org.redisson.connection.balancer.RoundRobinLoadBalancer</p>
<p>在使用多个Redis服务节点的环境里，可以选用以下几种负载均衡方式选择一个节点： org.redisson.connection.balancer.WeightedRoundRobinBalancer - 权重轮询调度算法 org.redisson.connection.balancer.RoundRobinLoadBalancer - 轮询调度算法 org.redisson.connection.balancer.RandomLoadBalancer - 随机调度算法</p>
<h4 id="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）-1"><a href="#subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）-1" class="headerlink" title="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）"></a>subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）</h4><p>默认值：1</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。</p>
<h4 id="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）-1"><a href="#subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）-1" class="headerlink" title="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）"></a>subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）</h4><p>默认值：50</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）-1"><a href="#slaveConnectionMinimumIdleSize（从节点最小空闲连接数）-1" class="headerlink" title="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）"></a>slaveConnectionMinimumIdleSize（从节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时读取反映速度。</p>
<h4 id="slaveConnectionPoolSize（从节点连接池大小）-1"><a href="#slaveConnectionPoolSize（从节点连接池大小）-1" class="headerlink" title="slaveConnectionPoolSize（从节点连接池大小）"></a>slaveConnectionPoolSize（从节点连接池大小）</h4><p>默认值：64</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="masterConnectionMinimumIdleSize（主节点最小空闲连接数）-1"><a href="#masterConnectionMinimumIdleSize（主节点最小空闲连接数）-1" class="headerlink" title="masterConnectionMinimumIdleSize（主节点最小空闲连接数）"></a>masterConnectionMinimumIdleSize（主节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多从节点的环境里，每个 主节点的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。</p>
<h4 id="masterConnectionPoolSize（主节点连接池大小）-1"><a href="#masterConnectionPoolSize（主节点连接池大小）-1" class="headerlink" title="masterConnectionPoolSize（主节点连接池大小）"></a>masterConnectionPoolSize（主节点连接池大小）</h4><p>默认值：64</p>
<p>主节点的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="idleConnectionTimeout（连接空闲超时，单位：毫秒）-2"><a href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）-2" class="headerlink" title="idleConnectionTimeout（连接空闲超时，单位：毫秒）"></a>idleConnectionTimeout（连接空闲超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>如果当前连接池里的连接数量超过了最小空闲连接数，而同时有连接空闲时间超过了该数值，那么这些连接将会自动被关闭，并从连接池里去掉。时间单位是毫秒。</p>
<h4 id="connectTimeout（连接超时，单位：毫秒）-2"><a href="#connectTimeout（连接超时，单位：毫秒）-2" class="headerlink" title="connectTimeout（连接超时，单位：毫秒）"></a>connectTimeout（连接超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>同任何节点建立连接时的等待超时。时间单位是毫秒。</p>
<h4 id="timeout（命令等待超时，单位：毫秒）-2"><a href="#timeout（命令等待超时，单位：毫秒）-2" class="headerlink" title="timeout（命令等待超时，单位：毫秒）"></a>timeout（命令等待超时，单位：毫秒）</h4><p>默认值：3000</p>
<p>等待节点回复命令的时间。该时间从命令发送成功时开始计时。</p>
<h4 id="retryAttempts（命令失败重试次数）-2"><a href="#retryAttempts（命令失败重试次数）-2" class="headerlink" title="retryAttempts（命令失败重试次数）"></a>retryAttempts（命令失败重试次数）</h4><p>默认值：3</p>
<p>如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。</p>
<h4 id="retryInterval（命令重试发送时间间隔，单位：毫秒）-2"><a href="#retryInterval（命令重试发送时间间隔，单位：毫秒）-2" class="headerlink" title="retryInterval（命令重试发送时间间隔，单位：毫秒）"></a>retryInterval（命令重试发送时间间隔，单位：毫秒）</h4><p>默认值：1500</p>
<p>在一条命令发送失败以后，等待重试发送的时间间隔。时间单位是毫秒。</p>
<h4 id="reconnectionTimeout（重新连接时间间隔，单位：毫秒）-2"><a href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）-2" class="headerlink" title="reconnectionTimeout（重新连接时间间隔，单位：毫秒）"></a>reconnectionTimeout（重新连接时间间隔，单位：毫秒）</h4><p>默认值：3000</p>
<p>当与某个节点的连接断开时，等待与其重新建立连接的时间间隔。时间单位是毫秒。</p>
<h4 id="failedAttempts（执行失败最大次数）-2"><a href="#failedAttempts（执行失败最大次数）-2" class="headerlink" title="failedAttempts（执行失败最大次数）"></a>failedAttempts（执行失败最大次数）</h4><p>默认值：3</p>
<p>在某个节点执行相同或不同命令时，连续 失败 failedAttempts（执行失败最大次数） 时，该节点将被从可用节点列表里清除，直到 reconnectionTimeout（重新连接时间间隔） 超时以后再次尝试。</p>
<h4 id="database（数据库编号）-1"><a href="#database（数据库编号）-1" class="headerlink" title="database（数据库编号）"></a>database（数据库编号）</h4><p>默认值：0</p>
<p>尝试连接的数据库编号。</p>
<h4 id="password（密码）-2"><a href="#password（密码）-2" class="headerlink" title="password（密码）"></a>password（密码）</h4><p>默认值：null</p>
<p>用于节点身份验证的密码。</p>
<h4 id="subscriptionsPerConnection（单个连接最大订阅数量）-2"><a href="#subscriptionsPerConnection（单个连接最大订阅数量）-2" class="headerlink" title="subscriptionsPerConnection（单个连接最大订阅数量）"></a>subscriptionsPerConnection（单个连接最大订阅数量）</h4><p>默认值：5</p>
<p>每个连接的最大订阅数量。</p>
<h4 id="clientName（客户端名称）-2"><a href="#clientName（客户端名称）-2" class="headerlink" title="clientName（客户端名称）"></a>clientName（客户端名称）</h4><p>默认值：null</p>
<p>在Redis节点里显示的客户端名称。</p>
<h4 id="sslEnableEndpointIdentification（启用SSL终端识别）-2"><a href="#sslEnableEndpointIdentification（启用SSL终端识别）-2" class="headerlink" title="sslEnableEndpointIdentification（启用SSL终端识别）"></a>sslEnableEndpointIdentification（启用SSL终端识别）</h4><p>默认值：true</p>
<p>开启SSL终端识别能力。</p>
<h4 id="sslProvider（SSL实现方式）-2"><a href="#sslProvider（SSL实现方式）-2" class="headerlink" title="sslProvider（SSL实现方式）"></a>sslProvider（SSL实现方式）</h4><p>默认值：JDK</p>
<p>确定采用哪种方式（JDK或OPENSSL）来实现SSL连接。</p>
<h4 id="sslTruststore（SSL信任证书库路径）-2"><a href="#sslTruststore（SSL信任证书库路径）-2" class="headerlink" title="sslTruststore（SSL信任证书库路径）"></a>sslTruststore（SSL信任证书库路径）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的路径。</p>
<h4 id="sslTruststorePassword（SSL信任证书库密码）-2"><a href="#sslTruststorePassword（SSL信任证书库密码）-2" class="headerlink" title="sslTruststorePassword（SSL信任证书库密码）"></a>sslTruststorePassword（SSL信任证书库密码）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的密码。</p>
<h4 id="sslKeystore（SSL钥匙库路径）-2"><a href="#sslKeystore（SSL钥匙库路径）-2" class="headerlink" title="sslKeystore（SSL钥匙库路径）"></a>sslKeystore（SSL钥匙库路径）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的路径。</p>
<h4 id="sslKeystorePassword（SSL钥匙库密码）-2"><a href="#sslKeystorePassword（SSL钥匙库密码）-2" class="headerlink" title="sslKeystorePassword（SSL钥匙库密码）"></a>sslKeystorePassword（SSL钥匙库密码）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的密码。</p>
<h3 id="3、配置文件-1"><a href="#3、配置文件-1" class="headerlink" title="3、配置文件"></a>3、配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;sentinelServersConfig&quot;:&#123;</span><br><span class="line">      &quot;idleConnectionTimeout&quot;:10000,</span><br><span class="line">      &quot;pingTimeout&quot;:1000,</span><br><span class="line">      &quot;connectTimeout&quot;:10000,</span><br><span class="line">      &quot;timeout&quot;:3000,</span><br><span class="line">      &quot;retryAttempts&quot;:3,</span><br><span class="line">      &quot;retryInterval&quot;:1500,</span><br><span class="line">      &quot;reconnectionTimeout&quot;:3000,</span><br><span class="line">      &quot;failedAttempts&quot;:3,</span><br><span class="line">      &quot;password&quot;:null,</span><br><span class="line">      &quot;subscriptionsPerConnection&quot;:5,</span><br><span class="line">      &quot;clientName&quot;:null,</span><br><span class="line">      &quot;loadBalancer&quot;:&#123;</span><br><span class="line">         &quot;class&quot;:&quot;org.redisson.connection.balancer.RoundRobinLoadBalancer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;slaveSubscriptionConnectionMinimumIdleSize&quot;:1,</span><br><span class="line">      &quot;slaveSubscriptionConnectionPoolSize&quot;:50,</span><br><span class="line">      &quot;slaveConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;slaveConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;masterConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;masterConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;readMode&quot;:&quot;SLAVE&quot;,</span><br><span class="line">      &quot;sentinelAddresses&quot;:[</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:26379&quot;,</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:26389&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;masterName&quot;:&quot;mymaster&quot;,</span><br><span class="line">      &quot;database&quot;:0</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;threads&quot;:0,</span><br><span class="line">   &quot;nettyThreads&quot;:0,</span><br><span class="line">   &quot;codec&quot;:&#123;</span><br><span class="line">      &quot;class&quot;:&quot;org.redisson.codec.JsonJacksonCodec&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;transportMode&quot;:&quot;NIO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sentinelServersConfig:</span><br><span class="line">  idleConnectionTimeout: 10000</span><br><span class="line">  pingTimeout: 1000</span><br><span class="line">  connectTimeout: 10000</span><br><span class="line">  timeout: 3000</span><br><span class="line">  retryAttempts: 3</span><br><span class="line">  retryInterval: 1500</span><br><span class="line">  reconnectionTimeout: 3000</span><br><span class="line">  failedAttempts: 3</span><br><span class="line">  password: null</span><br><span class="line">  subscriptionsPerConnection: 5</span><br><span class="line">  clientName: null</span><br><span class="line">  loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; &#123;&#125;</span><br><span class="line">  slaveSubscriptionConnectionMinimumIdleSize: 1</span><br><span class="line">  slaveSubscriptionConnectionPoolSize: 50</span><br><span class="line">  slaveConnectionMinimumIdleSize: 32</span><br><span class="line">  slaveConnectionPoolSize: 64</span><br><span class="line">  masterConnectionMinimumIdleSize: 32</span><br><span class="line">  masterConnectionPoolSize: 64</span><br><span class="line">  readMode: &quot;SLAVE&quot;</span><br><span class="line">  sentinelAddresses:</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:26379&quot;</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:26389&quot;</span><br><span class="line">  masterName: &quot;mymaster&quot;</span><br><span class="line">  database: 0</span><br><span class="line">threads: 0</span><br><span class="line">nettyThreads: 0</span><br><span class="line">codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;</span><br><span class="line">&quot;transportMode&quot;:&quot;NIO&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client</span><br><span class="line">    id&#x3D;&quot;redisson&quot;</span><br><span class="line">    name&#x3D;&quot;redisson1,redisson2&quot;</span><br><span class="line">    threads&#x3D;&quot;0&quot;</span><br><span class="line">    netty-threads&#x3D;&quot;0&quot;</span><br><span class="line">    codec-ref&#x3D;&quot;myCodec&quot; </span><br><span class="line">    transport-mode&#x3D;&quot;NIO&quot;</span><br><span class="line">    redisson-reference-enabled&#x3D;&quot;true&quot;</span><br><span class="line">    codec-provider-ref&#x3D;&quot;myCodecProvider&quot;</span><br><span class="line">    resolver-provider-ref&#x3D;&quot;myResolverProvider&quot;</span><br><span class="line">    executor-ref&#x3D;&quot;myExecutor&quot;</span><br><span class="line">    event-loop-group-ref&#x3D;&quot;myEventLoopGroup&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    这里的name属性和qualifier子元素不能同时使用。</span><br><span class="line"></span><br><span class="line">    id和name的属性都可以被用来作为qualifier的备选值。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--&lt;qualifier value&#x3D;&quot;redisson3&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    &lt;redisson:sentinel-servers</span><br><span class="line">        idle-connection-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        ping-timeout&#x3D;&quot;1000&quot;</span><br><span class="line">        connect-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        retry-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        retry-interval&#x3D;&quot;1500&quot;</span><br><span class="line">        reconnection-timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        failed-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        password&#x3D;&quot;do_not_use_if_it_is_not_set&quot;</span><br><span class="line">        subscriptions-per-connection&#x3D;&quot;5&quot;</span><br><span class="line">        client-name&#x3D;&quot;none&quot;</span><br><span class="line">        load-balancer-ref&#x3D;&quot;myLoadBalancer&quot;</span><br><span class="line">        subscription-connection-minimum-idle-size&#x3D;&quot;1&quot;</span><br><span class="line">        subscription-connection-pool-size&#x3D;&quot;50&quot;</span><br><span class="line">        slave-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        slave-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        master-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        master-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        read-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        subscription-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        master-name&#x3D;&quot;myMaster&quot;</span><br><span class="line">        database&#x3D;&quot;0&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;redisson:sentinel-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:26379&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:sentinel-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:26380&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;redisson:sentinel-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最基本配置 --&gt;</span><br><span class="line">&lt;redisson:client&gt;</span><br><span class="line">    &lt;redisson:sentinel-servers master-name&#x3D;&quot;myMaster&quot;&gt;</span><br><span class="line">        &lt;redisson:sentinel-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:26379&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:sentinel-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:26380&quot; &#x2F;&gt;</span><br><span class="line">        ....</span><br><span class="line">    &lt;&#x2F;redisson:sentinel-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><h3 id="1、程序化配置-2"><a href="#1、程序化配置-2" class="headerlink" title="1、程序化配置"></a>1、程序化配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Config config &#x3D; new Config();</span><br><span class="line">config.useMasterSlaveServers()</span><br><span class="line">    &#x2F;&#x2F;可以用&quot;rediss:&#x2F;&#x2F;&quot;来启用SSL连接</span><br><span class="line">    .setMasterAddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;)</span><br><span class="line">    .addSlaveAddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:6389&quot;, &quot;redis:&#x2F;&#x2F;127.0.0.1:6332&quot;, &quot;redis:&#x2F;&#x2F;127.0.0.1:6419&quot;)</span><br><span class="line">    .addSlaveAddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:6399&quot;);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson &#x3D; Redisson.create(config);</span><br></pre></td></tr></table></figure>
<h3 id="2、主从模式设置"><a href="#2、主从模式设置" class="headerlink" title="2、主从模式设置"></a>2、主从模式设置</h3><p>MasterSlaveServersConfig 类的设置参数如下：</p>
<h4 id="dnsMonitoringInterval（DNS监控间隔，单位：毫秒）-1"><a href="#dnsMonitoringInterval（DNS监控间隔，单位：毫秒）-1" class="headerlink" title="dnsMonitoringInterval（DNS监控间隔，单位：毫秒）"></a>dnsMonitoringInterval（DNS监控间隔，单位：毫秒）</h4><p>默认值：5000</p>
<p>用来指定检查节点DNS变化的时间间隔。使用的时候应该确保JVM里的DNS数据的缓存时间保持在足够低的范围才有意义。用-1来禁用该功能。</p>
<h4 id="masterAddress（主节点地址）"><a href="#masterAddress（主节点地址）" class="headerlink" title="masterAddress（主节点地址）"></a>masterAddress（主节点地址）</h4><p>可以通过host:port的格式来指定主节点地址。</p>
<h4 id="addSlaveAddress（添加从主节点地址）"><a href="#addSlaveAddress（添加从主节点地址）" class="headerlink" title="addSlaveAddress（添加从主节点地址）"></a>addSlaveAddress（添加从主节点地址）</h4><p>可以通过host:port的格式来指定从节点的地址。多个节点可以一次性批量添加。</p>
<h4 id="readMode（读取操作的负载均衡模式）-2"><a href="#readMode（读取操作的负载均衡模式）-2" class="headerlink" title="readMode（读取操作的负载均衡模式）"></a>readMode（读取操作的负载均衡模式）</h4><p>默认值： SLAVE（只在从服务节点里读取）</p>
<p>注：在从服务节点里读取的数据说明已经至少有两个节点保存了该数据，确保了数据的高可用性。</p>
<p>设置读取操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里读取。 MASTER - 只在主服务节点里读取。 MASTER_SLAVE - 在主从服务节点里都可以读取。</p>
<h4 id="subscriptionMode（订阅操作的负载均衡模式）-2"><a href="#subscriptionMode（订阅操作的负载均衡模式）-2" class="headerlink" title="subscriptionMode（订阅操作的负载均衡模式）"></a>subscriptionMode（订阅操作的负载均衡模式）</h4><p>默认值：SLAVE（只在从服务节点里订阅）</p>
<p>设置订阅操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里订阅。 MASTER - 只在主服务节点里订阅。</p>
<h4 id="loadBalancer（负载均衡算法类的选择）-2"><a href="#loadBalancer（负载均衡算法类的选择）-2" class="headerlink" title="loadBalancer（负载均衡算法类的选择）"></a>loadBalancer（负载均衡算法类的选择）</h4><p>默认值： org.redisson.connection.balancer.RoundRobinLoadBalancer</p>
<p>在使用多个Redis服务节点的环境里，可以选用以下几种负载均衡方式选择一个节点： org.redisson.connection.balancer.WeightedRoundRobinBalancer - 权重轮询调度算法 org.redisson.connection.balancer.RoundRobinLoadBalancer - 轮询调度算法 org.redisson.connection.balancer.RandomLoadBalancer - 随机调度算法</p>
<h4 id="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）-2"><a href="#subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）-2" class="headerlink" title="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）"></a>subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）</h4><p>默认值：1</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。</p>
<h4 id="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）-2"><a href="#subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）-2" class="headerlink" title="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）"></a>subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）</h4><p>默认值：50</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）-2"><a href="#slaveConnectionMinimumIdleSize（从节点最小空闲连接数）-2" class="headerlink" title="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）"></a>slaveConnectionMinimumIdleSize（从节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时读取反映速度。</p>
<h4 id="slaveConnectionPoolSize（从节点连接池大小）-2"><a href="#slaveConnectionPoolSize（从节点连接池大小）-2" class="headerlink" title="slaveConnectionPoolSize（从节点连接池大小）"></a>slaveConnectionPoolSize（从节点连接池大小）</h4><p>默认值：64</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="masterConnectionMinimumIdleSize（主节点最小空闲连接数）-2"><a href="#masterConnectionMinimumIdleSize（主节点最小空闲连接数）-2" class="headerlink" title="masterConnectionMinimumIdleSize（主节点最小空闲连接数）"></a>masterConnectionMinimumIdleSize（主节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多从节点的环境里，每个 主节点的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。</p>
<h4 id="masterConnectionPoolSize（主节点连接池大小）-2"><a href="#masterConnectionPoolSize（主节点连接池大小）-2" class="headerlink" title="masterConnectionPoolSize（主节点连接池大小）"></a>masterConnectionPoolSize（主节点连接池大小）</h4><p>默认值：64</p>
<p>主节点的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="idleConnectionTimeout（连接空闲超时，单位：毫秒）-3"><a href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）-3" class="headerlink" title="idleConnectionTimeout（连接空闲超时，单位：毫秒）"></a>idleConnectionTimeout（连接空闲超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>如果当前连接池里的连接数量超过了最小空闲连接数，而同时有连接空闲时间超过了该数值，那么这些连接将会自动被关闭，并从连接池里去掉。时间单位是毫秒。</p>
<h4 id="connectTimeout（连接超时，单位：毫秒）-3"><a href="#connectTimeout（连接超时，单位：毫秒）-3" class="headerlink" title="connectTimeout（连接超时，单位：毫秒）"></a>connectTimeout（连接超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>同任何节点建立连接时的等待超时。时间单位是毫秒。</p>
<h4 id="timeout（命令等待超时，单位：毫秒）-3"><a href="#timeout（命令等待超时，单位：毫秒）-3" class="headerlink" title="timeout（命令等待超时，单位：毫秒）"></a>timeout（命令等待超时，单位：毫秒）</h4><p>默认值：3000</p>
<p>等待节点回复命令的时间。该时间从命令发送成功时开始计时。</p>
<h4 id="retryAttempts（命令失败重试次数）-3"><a href="#retryAttempts（命令失败重试次数）-3" class="headerlink" title="retryAttempts（命令失败重试次数）"></a>retryAttempts（命令失败重试次数）</h4><p>默认值：3</p>
<p>如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。</p>
<h4 id="retryInterval（命令重试发送时间间隔，单位：毫秒）-3"><a href="#retryInterval（命令重试发送时间间隔，单位：毫秒）-3" class="headerlink" title="retryInterval（命令重试发送时间间隔，单位：毫秒）"></a>retryInterval（命令重试发送时间间隔，单位：毫秒）</h4><p>默认值：1500</p>
<p>在一条命令发送失败以后，等待重试发送的时间间隔。时间单位是毫秒。</p>
<h4 id="reconnectionTimeout（重新连接时间间隔，单位：毫秒）-3"><a href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）-3" class="headerlink" title="reconnectionTimeout（重新连接时间间隔，单位：毫秒）"></a>reconnectionTimeout（重新连接时间间隔，单位：毫秒）</h4><p>默认值：3000</p>
<p>当与某个节点的连接断开时，等待与其重新建立连接的时间间隔。时间单位是毫秒。</p>
<h4 id="failedAttempts（执行失败最大次数）-3"><a href="#failedAttempts（执行失败最大次数）-3" class="headerlink" title="failedAttempts（执行失败最大次数）"></a>failedAttempts（执行失败最大次数）</h4><p>默认值：3</p>
<p>在某个节点执行相同或不同命令时，连续 失败 failedAttempts（执行失败最大次数） 时，该节点将被从可用节点列表里清除，直到 reconnectionTimeout（重新连接时间间隔） 超时以后再次尝试。</p>
<h4 id="database（数据库编号）-2"><a href="#database（数据库编号）-2" class="headerlink" title="database（数据库编号）"></a>database（数据库编号）</h4><p>默认值：0</p>
<p>尝试连接的数据库编号。</p>
<h4 id="password（密码）-3"><a href="#password（密码）-3" class="headerlink" title="password（密码）"></a>password（密码）</h4><p>默认值：null</p>
<p>用于节点身份验证的密码。</p>
<h4 id="subscriptionsPerConnection（单个连接最大订阅数量）-3"><a href="#subscriptionsPerConnection（单个连接最大订阅数量）-3" class="headerlink" title="subscriptionsPerConnection（单个连接最大订阅数量）"></a>subscriptionsPerConnection（单个连接最大订阅数量）</h4><p>默认值：5</p>
<p>每个连接的最大订阅数量。</p>
<h4 id="clientName（客户端名称）-3"><a href="#clientName（客户端名称）-3" class="headerlink" title="clientName（客户端名称）"></a>clientName（客户端名称）</h4><p>默认值：null</p>
<p>在Redis节点里显示的客户端名称。</p>
<h4 id="sslEnableEndpointIdentification（启用SSL终端识别）-3"><a href="#sslEnableEndpointIdentification（启用SSL终端识别）-3" class="headerlink" title="sslEnableEndpointIdentification（启用SSL终端识别）"></a>sslEnableEndpointIdentification（启用SSL终端识别）</h4><p>默认值：true</p>
<p>开启SSL终端识别能力。</p>
<h4 id="sslProvider（SSL实现方式）-3"><a href="#sslProvider（SSL实现方式）-3" class="headerlink" title="sslProvider（SSL实现方式）"></a>sslProvider（SSL实现方式）</h4><p>默认值：JDK</p>
<p>确定采用哪种方式（JDK或OPENSSL）来实现SSL连接。</p>
<h4 id="sslTruststore（SSL信任证书库路径）-3"><a href="#sslTruststore（SSL信任证书库路径）-3" class="headerlink" title="sslTruststore（SSL信任证书库路径）"></a>sslTruststore（SSL信任证书库路径）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的路径。</p>
<h4 id="sslTruststorePassword（SSL信任证书库密码）-3"><a href="#sslTruststorePassword（SSL信任证书库密码）-3" class="headerlink" title="sslTruststorePassword（SSL信任证书库密码）"></a>sslTruststorePassword（SSL信任证书库密码）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的密码。</p>
<h4 id="sslKeystore（SSL钥匙库路径）-3"><a href="#sslKeystore（SSL钥匙库路径）-3" class="headerlink" title="sslKeystore（SSL钥匙库路径）"></a>sslKeystore（SSL钥匙库路径）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的路径。</p>
<h4 id="sslKeystorePassword（SSL钥匙库密码）-3"><a href="#sslKeystorePassword（SSL钥匙库密码）-3" class="headerlink" title="sslKeystorePassword（SSL钥匙库密码）"></a>sslKeystorePassword（SSL钥匙库密码）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的密码。</p>
<h3 id="3、文件配置主从模式"><a href="#3、文件配置主从模式" class="headerlink" title="3、文件配置主从模式"></a>3、文件配置主从模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;masterSlaveServersConfig&quot;:&#123;</span><br><span class="line">      &quot;idleConnectionTimeout&quot;:10000,</span><br><span class="line">      &quot;pingTimeout&quot;:1000,</span><br><span class="line">      &quot;connectTimeout&quot;:10000,</span><br><span class="line">      &quot;timeout&quot;:3000,</span><br><span class="line">      &quot;retryAttempts&quot;:3,</span><br><span class="line">      &quot;retryInterval&quot;:1500,</span><br><span class="line">      &quot;reconnectionTimeout&quot;:3000,</span><br><span class="line">      &quot;failedAttempts&quot;:3,</span><br><span class="line">      &quot;password&quot;:null,</span><br><span class="line">      &quot;subscriptionsPerConnection&quot;:5,</span><br><span class="line">      &quot;clientName&quot;:null,</span><br><span class="line">      &quot;loadBalancer&quot;:&#123;</span><br><span class="line">         &quot;class&quot;:&quot;org.redisson.connection.balancer.RoundRobinLoadBalancer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;slaveSubscriptionConnectionMinimumIdleSize&quot;:1,</span><br><span class="line">      &quot;slaveSubscriptionConnectionPoolSize&quot;:50,</span><br><span class="line">      &quot;slaveConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;slaveConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;masterConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;masterConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;readMode&quot;:&quot;SLAVE&quot;,</span><br><span class="line">      &quot;slaveAddresses&quot;:[</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot;,</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;masterAddress&quot;: &quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;,</span><br><span class="line">      &quot;database&quot;:0</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;threads&quot;:0,</span><br><span class="line">   &quot;nettyThreads&quot;:0,</span><br><span class="line">   &quot;codec&quot;:&#123;</span><br><span class="line">      &quot;class&quot;:&quot;org.redisson.codec.JsonJacksonCodec&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;transportMode&quot;:&quot;NIO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">masterSlaveServersConfig:</span><br><span class="line">  idleConnectionTimeout: 10000</span><br><span class="line">  pingTimeout: 1000</span><br><span class="line">  connectTimeout: 10000</span><br><span class="line">  timeout: 3000</span><br><span class="line">  retryAttempts: 3</span><br><span class="line">  retryInterval: 1500</span><br><span class="line">  reconnectionTimeout: 3000</span><br><span class="line">  failedAttempts: 3</span><br><span class="line">  password: null</span><br><span class="line">  subscriptionsPerConnection: 5</span><br><span class="line">  clientName: null</span><br><span class="line">  loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; &#123;&#125;</span><br><span class="line">  slaveSubscriptionConnectionMinimumIdleSize: 1</span><br><span class="line">  slaveSubscriptionConnectionPoolSize: 50</span><br><span class="line">  slaveConnectionMinimumIdleSize: 32</span><br><span class="line">  slaveConnectionPoolSize: 64</span><br><span class="line">  masterConnectionMinimumIdleSize: 32</span><br><span class="line">  masterConnectionPoolSize: 64</span><br><span class="line">  readMode: &quot;SLAVE&quot;</span><br><span class="line">  slaveAddresses:</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot;</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot;</span><br><span class="line">  masterAddress: &quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;</span><br><span class="line">  database: 0</span><br><span class="line">threads: 0</span><br><span class="line">nettyThreads: 0</span><br><span class="line">codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;</span><br><span class="line">&quot;transportMode&quot;:&quot;NIO&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client</span><br><span class="line">    id&#x3D;&quot;redisson&quot;</span><br><span class="line">    name&#x3D;&quot;redisson1,redisson2&quot;</span><br><span class="line">    threads&#x3D;&quot;0&quot;</span><br><span class="line">    netty-threads&#x3D;&quot;0&quot;</span><br><span class="line">    codec-ref&#x3D;&quot;myCodec&quot; </span><br><span class="line">    transport-mode&#x3D;&quot;NIO&quot;</span><br><span class="line">    redisson-reference-enabled&#x3D;&quot;true&quot;</span><br><span class="line">    codec-provider-ref&#x3D;&quot;myCodecProvider&quot;</span><br><span class="line">    resolver-provider-ref&#x3D;&quot;myResolverProvider&quot;</span><br><span class="line">    executor-ref&#x3D;&quot;myExecutor&quot;</span><br><span class="line">    event-loop-group-ref&#x3D;&quot;myEventLoopGroup&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    这里的name属性和qualifier子元素不能同时使用。</span><br><span class="line"></span><br><span class="line">    id和name的属性都可以被用来作为qualifier的备选值。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--&lt;qualifier value&#x3D;&quot;redisson3&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    &lt;redisson:master-slave-servers</span><br><span class="line">        idle-connection-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        ping-timeout&#x3D;&quot;1000&quot;</span><br><span class="line">        connect-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        retry-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        retry-interval&#x3D;&quot;1500&quot;</span><br><span class="line">        reconnection-timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        failed-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        password&#x3D;&quot;do_not_use_if_it_is_not_set&quot;</span><br><span class="line">        subscriptions-per-connection&#x3D;&quot;5&quot;</span><br><span class="line">        client-name&#x3D;&quot;none&quot;</span><br><span class="line">        load-balancer-ref&#x3D;&quot;myLoadBalancer&quot;</span><br><span class="line">        subscription-connection-minimum-idle-size&#x3D;&quot;1&quot;</span><br><span class="line">        subscription-connection-pool-size&#x3D;&quot;50&quot;</span><br><span class="line">        slave-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        slave-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        master-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        master-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        read-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        subscription-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        master-address&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;</span><br><span class="line">        database&#x3D;&quot;0&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;redisson:slave-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:slave-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;redisson:master-slave-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最基本配置 --&gt;</span><br><span class="line">&lt;redisson:client&gt;</span><br><span class="line">    &lt;redisson:master-slave-servers master-address&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;&gt;</span><br><span class="line">        &lt;redisson:slave-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:slave-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;&#x2F;redisson:master-slave-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>
<h1 id="三、程序接口调用方式"><a href="#三、程序接口调用方式" class="headerlink" title="三、程序接口调用方式"></a>三、程序接口调用方式</h1><p>RedissonClient、RedissonReactiveClient和RedissonRxClient实例本身和Redisson提供的所有分布式对象都是线程安全的。</p>
<p>Redisson为每个操作都提供了** 自动重试策略 **，当某个命令执行失败时，Redisson会自动进行重试。自动重试策略可以通过修改retryAttempts（默认值：3）参数和retryInterval（默认值：1000毫秒）参数来进行优化调整。当等待时间达到retryInterval指定的时间间隔以后，将自动重试下一次。全部重试失败以后将抛出错误。</p>
<p>Redisson框架提供的几乎所有对象都包含了同步和异步相互匹配的方法。这些对象都可以通过RedissonClient接口获取。同时还为大部分Redisson对象提供了满足异步流处理标准的程序接口RedissonReactiveClient。除此外还提供了RxJava2规范的RedissonRxClient程序接口。</p>
<p>以下是关于使用RAtomicLong对象的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RedissonClient client &#x3D; Redisson.create(config);</span><br><span class="line">RAtomicLong longObject &#x3D; client.getAtomicLong(&#39;myLong&#39;);</span><br><span class="line">&#x2F;&#x2F; 同步执行方式</span><br><span class="line">longObject.compareAndSet(3, 401);</span><br><span class="line">&#x2F;&#x2F; 异步执行方式</span><br><span class="line">RFuture&lt;Boolean&gt; result &#x3D; longObject.compareAndSetAsync(3, 401);</span><br><span class="line"></span><br><span class="line">RedissonReactiveClient client &#x3D; Redisson.createReactive(config);</span><br><span class="line">RAtomicLongReactive longObject &#x3D; client.getAtomicLong(&#39;myLong&#39;);</span><br><span class="line">&#x2F;&#x2F; 异步流执行方式</span><br><span class="line">Mono&lt;Boolean&gt; result &#x3D; longObject.compareAndSet(3, 401);</span><br><span class="line">RedissonRxClient client &#x3D; Redisson.createRx(config);</span><br><span class="line">RAtomicLongRx longObject&#x3D; client.getAtomicLong(&quot;myLong&quot;);</span><br><span class="line">&#x2F;&#x2F; RxJava2方式</span><br><span class="line">Flowable&lt;Boolean result &#x3D; longObject.compareAndSet(3, 401);</span><br></pre></td></tr></table></figure>
<h2 id="异步执行方式"><a href="#异步执行方式" class="headerlink" title="异步执行方式"></a>异步执行方式</h2><p>几乎所有的Redisson对象都实现了一个异步接口，异步接口提供的方法名称与其同步接口的方法名称相互匹配。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; RAtomicLong接口继承了RAtomicLongAsync接口</span><br><span class="line">RAtomicLongAsync longObject &#x3D; client.getAtomicLong(&quot;myLong&quot;);</span><br><span class="line">RFuture&lt;Boolean&gt; future &#x3D; longObject.compareAndSetAsync(1, 401);</span><br><span class="line">异步执行的方法都会返回一个实现了RFuture接口的对象。该对象同时提供了java.util.concurrent.CompletionStage和java.util.concurrent.Future两个异步接口。</span><br><span class="line"></span><br><span class="line">future.whenComplete((res, exception) -&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">future.thenAccept(res -&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理返回</span><br><span class="line">&#125;).exceptionally(exception -&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="异步流执行方式"><a href="#异步流执行方式" class="headerlink" title="异步流执行方式"></a>异步流执行方式</h2><p>Redisson为大多数分布式数据结构提供了满足Reactor项目的异步流处理标准的程序接口。该接口通过两种方式实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">基于Project Reactor标准的实现方式。使用范例如下：</span><br><span class="line">RedissonReactiveClient client &#x3D; Redisson.createReactive(config);</span><br><span class="line">RAtomicLongReactive atomicLong &#x3D; client.getAtomicLong(&quot;myLong&quot;);</span><br><span class="line">Mono&lt;Boolean&gt; cs &#x3D; longObject.compareAndSet(10, 91);</span><br><span class="line">Mono&lt;Long&gt; get &#x3D; longObject.get();</span><br><span class="line"></span><br><span class="line">Publisher&lt;Long&gt; getPublisher &#x3D; longObject.get();</span><br><span class="line">基于RxJava2标准的实现方式。使用范例如下：</span><br><span class="line">RedissonRxClient client &#x3D; Redisson.createRx(config);</span><br><span class="line">RAtomicLongRx atomicLong &#x3D; client.getAtomicLong(&quot;myLong&quot;);</span><br><span class="line">Single&lt;Boolean&gt; cs &#x3D; longObject.compareAndSet(10, 91);</span><br><span class="line">Single&lt;Long&gt; get &#x3D; longObject.get();</span><br></pre></td></tr></table></figure>

<h1 id="单个集合数据分片"><a href="#单个集合数据分片" class="headerlink" title="单个集合数据分片"></a>单个集合数据分片</h1><p>在集群模式下，Redisson为单个Redis集合类型提供了自动分片的功能。</p>
<p>Redisson提供的所有数据结构都支持在集群环境下使用，但每个数据结构只被保存在一个固定的槽内。Redisson PRO提供的自动分片功能能够将单个数据结构拆分，然后均匀的分布在整个集群里，而不是被挤在单一一个槽里。自动分片功能的优势主要有以下几点：</p>
<ul>
<li>单个数据结构可以充分利用整个集群内存资源，而不是被某一个节点的内存限制。</li>
<li>将单个数据结构分片以后分布在集群中不同的节点里，不仅可以大幅提高读写性能，还能够保证读写性能随着集群的扩张而自动提升。</li>
</ul>
<p>Redisson通过自身的分片算法，将一个大集合拆分为若干个片段（默认231个，分片数量范围是3 - 16834），然后将拆分后的片段均匀的分布到集群里各个节点里，保证每个节点分配到的片段数量大体相同。比如在默认情况下231个片段分到含有4个主节点的集群里，每个主节点将会分配到大约57个片段，同样的道理如果有5个主节点，每个节点会分配到大约46个片段。</p>
<p>目前支持的数据结构类型和服务包括集（Set）、映射（Map）、BitSet、布隆过滤器（Bloom Filter）、Spring Cache和Hibernate Cache。该功能仅限于Redisson PRO版本。</p>
<h1 id="四、分布式对象"><a href="#四、分布式对象" class="headerlink" title="四、分布式对象"></a>四、分布式对象</h1><p>每个Redisson对象实例都会有一个与之对应的Redis数据实例，可以通过调用getName方法来取得Redis数据实例的名称（key）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RMap map &#x3D; redisson.getMap(&quot;mymap&quot;);</span><br><span class="line">map.getName(); &#x2F;&#x2F; &#x3D; mymap</span><br><span class="line">所有与Redis key相关的操作都归纳在RKeys这个接口里：</span><br><span class="line"></span><br><span class="line">RKeys keys &#x3D; redisson.getKeys();</span><br><span class="line"></span><br><span class="line">Iterable&lt;String&gt; allKeys &#x3D; keys.getKeys();</span><br><span class="line">Iterable&lt;String&gt; foundedKeys &#x3D; keys.getKeysByPattern(&#39;key*&#39;);</span><br><span class="line">long numOfDeletedKeys &#x3D; keys.delete(&quot;obj1&quot;, &quot;obj2&quot;, &quot;obj3&quot;);</span><br><span class="line">long deletedKeysAmount &#x3D; keys.deleteByPattern(&quot;test?&quot;);</span><br><span class="line">String randomKey &#x3D; keys.randomKey();</span><br><span class="line">long keysAmount &#x3D; keys.count();</span><br></pre></td></tr></table></figure>
<h2 id="通用对象桶（Object-Bucket）"><a href="#通用对象桶（Object-Bucket）" class="headerlink" title="通用对象桶（Object Bucket）"></a>通用对象桶（Object Bucket）</h2><p>Redisson的分布式RBucketJava对象是一种通用对象桶可以用来存放任类型的对象。 除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RBucket&lt;AnyObject&gt; bucket &#x3D; redisson.getBucket(&quot;anyObject&quot;);</span><br><span class="line">bucket.set(new AnyObject(1));</span><br><span class="line">AnyObject obj &#x3D; bucket.get();</span><br><span class="line"></span><br><span class="line">bucket.trySet(new AnyObject(3));</span><br><span class="line">bucket.compareAndSet(new AnyObject(4), new AnyObject(5));</span><br><span class="line">bucket.getAndSet(new AnyObject(6));</span><br><span class="line">还可以通过RBuckets接口实现批量操作多个RBucket对象：</span><br><span class="line"></span><br><span class="line">RBuckets buckets &#x3D; redisson.getBuckets();</span><br><span class="line">List&lt;RBucket&lt;V&gt;&gt; foundBuckets &#x3D; buckets.find(&quot;myBucket*&quot;);</span><br><span class="line">Map&lt;String, V&gt; loadedBuckets &#x3D; buckets.get(&quot;myBucket1&quot;, &quot;myBucket2&quot;, &quot;myBucket3&quot;);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;myBucket1&quot;, new MyObject());</span><br><span class="line">map.put(&quot;myBucket2&quot;, new MyObject());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 利用Redis的事务特性，同时保存所有的通用对象桶，如果任意一个通用对象桶已经存在则放弃保存其他所有数据。</span><br><span class="line">buckets.trySet(map);</span><br><span class="line">&#x2F;&#x2F; 同时保存全部通用对象桶。</span><br><span class="line">buckets.set(map);</span><br></pre></td></tr></table></figure>
<h2 id="二进制流（Binary-Stream）"><a href="#二进制流（Binary-Stream）" class="headerlink" title="二进制流（Binary Stream）"></a>二进制流（Binary Stream）</h2><p>Redisson的分布式RBinaryStream Java对象同时提供了InputStream接口和OutputStream接口的实现。流的最大容量受Redis主节点的内存大小限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RBinaryStream stream &#x3D; redisson.getBinaryStream(&quot;anyStream&quot;);</span><br><span class="line">byte[] content &#x3D; ...</span><br><span class="line">stream.set(content);</span><br><span class="line"></span><br><span class="line">InputStream is &#x3D; stream.getInputStream();</span><br><span class="line">byte[] readBuffer &#x3D; new byte[512];</span><br><span class="line">is.read(readBuffer);</span><br><span class="line"></span><br><span class="line">OutputStream os &#x3D; stream.getOuputStream();</span><br><span class="line">byte[] contentToWrite &#x3D; ...</span><br><span class="line">os.write(contentToWrite);</span><br></pre></td></tr></table></figure>

<h2 id="地理空间对象桶（Geospatial-Bucket）"><a href="#地理空间对象桶（Geospatial-Bucket）" class="headerlink" title="地理空间对象桶（Geospatial Bucket）"></a>地理空间对象桶（Geospatial Bucket）</h2><p>Redisson的分布式RGeo Java对象是一种专门用来储存与地理位置有关的对象桶。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RGeo&lt;String&gt; geo &#x3D; redisson.getGeo(&quot;test&quot;);</span><br><span class="line">geo.add(new GeoEntry(13.361389, 38.115556, &quot;Palermo&quot;),</span><br><span class="line">        new GeoEntry(15.087269, 37.502669, &quot;Catania&quot;));</span><br><span class="line">geo.addAsync(37.618423, 55.751244, &quot;Moscow&quot;);</span><br><span class="line"></span><br><span class="line">Double distance &#x3D; geo.dist(&quot;Palermo&quot;, &quot;Catania&quot;, GeoUnit.METERS);</span><br><span class="line">geo.hashAsync(&quot;Palermo&quot;, &quot;Catania&quot;);</span><br><span class="line">Map&lt;String, GeoPosition&gt; positions &#x3D; geo.pos(&quot;test2&quot;, &quot;Palermo&quot;, &quot;test3&quot;, &quot;Catania&quot;, &quot;test1&quot;);</span><br><span class="line">List&lt;String&gt; cities &#x3D; geo.radius(15, 37, 200, GeoUnit.KILOMETERS);</span><br><span class="line">Map&lt;String, GeoPosition&gt; citiesWithPositions &#x3D; geo.radiusWithPosition(15, 37, 200, GeoUnit.KILOMETERS);</span><br></pre></td></tr></table></figure>
<h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><p>Redisson的分布式RBitSetJava对象采用了与java.util.BiteSet类似结构的设计风格。可以理解为它是一个分布式的可伸缩式位向量。需要注意的是RBitSet的大小受Redis限制，最大长度为4 294 967 295。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RBitSet set &#x3D; redisson.getBitSet(&quot;simpleBitset&quot;);</span><br><span class="line">set.set(0, true);</span><br><span class="line">set.set(1812, false);</span><br><span class="line">set.clear(0);</span><br><span class="line">set.addAsync(&quot;e&quot;);</span><br><span class="line">set.xor(&quot;anotherBitset&quot;);</span><br></pre></td></tr></table></figure>
<p>BitSet数据分片（Sharding）（分布式RoaringBitMap）</p>
<p>基于Redis的Redisson集群分布式BitSet通过RClusteredBitSet接口，为集群状态下的Redis环境提供了BitSet数据分片的功能。通过优化后更加有效的分布式RoaringBitMap算法，突破了原有的BitSet大小限制，达到了集群物理内存容量大小。在这里可以获取更多的内部信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RClusteredBitSet set &#x3D; redisson.getClusteredBitSet(&quot;simpleBitset&quot;);</span><br><span class="line">set.set(0, true);</span><br><span class="line">set.set(1812, false);</span><br><span class="line">set.clear(0);</span><br><span class="line">set.addAsync(&quot;e&quot;);</span><br><span class="line">set.xor(&quot;anotherBitset&quot;);</span><br><span class="line">该功能仅限于Redisson PRO版本。</span><br></pre></td></tr></table></figure>
<h2 id="原子整长形（AtomicLong）"><a href="#原子整长形（AtomicLong）" class="headerlink" title="原子整长形（AtomicLong）"></a>原子整长形（AtomicLong）</h2><p>Redisson的分布式整长形RAtomicLong对象和Java中的java.util.concurrent.atomic.AtomicLong对象类似。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAtomicLong atomicLong &#x3D; redisson.getAtomicLong(&quot;myAtomicLong&quot;);</span><br><span class="line">atomicLong.set(3);</span><br><span class="line">atomicLong.incrementAndGet();</span><br><span class="line">atomicLong.get();</span><br></pre></td></tr></table></figure>
<h2 id="原子双精度浮点（AtomicDouble）"><a href="#原子双精度浮点（AtomicDouble）" class="headerlink" title="原子双精度浮点（AtomicDouble）"></a>原子双精度浮点（AtomicDouble）</h2><p>Redisson还提供了分布式原子双精度浮点RAtomicDouble，弥补了Java自身的不足。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAtomicDouble atomicDouble &#x3D; redisson.getAtomicDouble(&quot;myAtomicDouble&quot;);</span><br><span class="line">atomicDouble.set(2.81);</span><br><span class="line">atomicDouble.addAndGet(4.11);</span><br><span class="line">atomicDouble.get();</span><br></pre></td></tr></table></figure>
<h2 id="话题（订阅分发）"><a href="#话题（订阅分发）" class="headerlink" title="话题（订阅分发）"></a>话题（订阅分发）</h2><p>Redisson的分布式话题<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RTopic.html对象实现了发布、订阅的机制。除了同步接口外，还提供了异步（[Async](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RTopicAsync.html)）、反射式（[Reactive](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RTopicReactive.html)）和[RxJava2](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RTopicRx.html" target="_blank" rel="noopener">RTopic</a>标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RTopic topic &#x3D; redisson.getTopic(&quot;anyTopic&quot;);</span><br><span class="line">topic.addListener(SomeObject.class, new MessageListener&lt;SomeObject&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(String channel, SomeObject message) &#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>// 在其他线程或JVM节点<br>RTopic topic = redisson.getTopic(“anyTopic”);<br>long clientsReceivedMessage = topic.publish(new SomeObject());<br>在Redis节点故障转移（主从切换）或断线重连以后，所有的话题监听器将自动完成话题的重新订阅。</p>
<p>模糊话题</p>
<p>Redisson的模糊话题RPatternTopic对象可以通过正式表达式来订阅多个话题。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 订阅所有满足&#96;topic1.*&#96;表达式的话题</span><br><span class="line">RPatternTopic topic1 &#x3D; redisson.getPatternTopic(&quot;topic1.*&quot;);</span><br><span class="line">int listenerId &#x3D; topic1.addListener(Message.class, new PatternMessageListener&lt;Message&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(String pattern, String channel, Message msg) &#123;</span><br><span class="line">         Assert.fail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在Redis节点故障转移（主从切换）或断线重连以后，所有的模糊话题监听器将自动完成话题的重新订阅。</p>
<h2 id="布隆过滤器（Bloom-Filter）"><a href="#布隆过滤器（Bloom-Filter）" class="headerlink" title="布隆过滤器（Bloom Filter）"></a>布隆过滤器（Bloom Filter）</h2><p>Redisson利用Redis实现了Java分布式布隆过滤器（Bloom Filter）。所含最大比特数量为2^32。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RBloomFilter&lt;SomeObject&gt; bloomFilter &#x3D; redisson.getBloomFilter(&quot;sample&quot;);</span><br><span class="line">&#x2F;&#x2F; 初始化布隆过滤器，预计统计元素数量为55000000，期望误差率为0.03</span><br><span class="line">bloomFilter.tryInit(55000000L, 0.03);</span><br><span class="line">bloomFilter.add(new SomeObject(&quot;field1Value&quot;, &quot;field2Value&quot;));</span><br><span class="line">bloomFilter.add(new SomeObject(&quot;field5Value&quot;, &quot;field8Value&quot;));</span><br><span class="line">bloomFilter.contains(new SomeObject(&quot;field1Value&quot;, &quot;field8Value&quot;));</span><br></pre></td></tr></table></figure>
<p>布隆过滤器数据分片（Sharding）</p>
<p>基于Redis的Redisson集群分布式布隆过滤器通过RClusteredBloomFilter接口，为集群状态下的Redis环境提供了布隆过滤器数据分片的功能。 通过优化后更加有效的算法，通过压缩未使用的比特位来释放集群内存空间。每个对象的状态都将被分布在整个集群中。所含最大比特数量为2^64。在这里可以获取更多的内部信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RClusteredBloomFilter&lt;SomeObject&gt; bloomFilter &#x3D; redisson.getClusteredBloomFilter(&quot;sample&quot;);</span><br><span class="line">&#x2F;&#x2F; 采用以下参数创建布隆过滤器</span><br><span class="line">&#x2F;&#x2F; expectedInsertions &#x3D; 255000000</span><br><span class="line">&#x2F;&#x2F; falseProbability &#x3D; 0.03</span><br><span class="line">bloomFilter.tryInit(255000000L, 0.03);</span><br><span class="line">bloomFilter.add(new SomeObject(&quot;field1Value&quot;, &quot;field2Value&quot;));</span><br><span class="line">bloomFilter.add(new SomeObject(&quot;field5Value&quot;, &quot;field8Value&quot;));</span><br><span class="line">bloomFilter.contains(new SomeObject(&quot;field1Value&quot;, &quot;field8Value&quot;));</span><br><span class="line">该功能仅限于Redisson PRO版本。</span><br></pre></td></tr></table></figure>
<h2 id="基数估计算法（HyperLogLog）"><a href="#基数估计算法（HyperLogLog）" class="headerlink" title="基数估计算法（HyperLogLog）"></a>基数估计算法（HyperLogLog）</h2><p>Redisson利用Redis实现了Java分布式基数估计算法（HyperLogLog）对象。该对象可以在有限的空间内通过概率算法统计大量的数据。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RHyperLogLog&lt;Integer&gt; log &#x3D; redisson.getHyperLogLog(&quot;log&quot;);</span><br><span class="line">log.add(1);</span><br><span class="line">log.add(2);</span><br><span class="line">log.add(3);</span><br><span class="line"></span><br><span class="line">log.count();</span><br></pre></td></tr></table></figure>
<h2 id="整长型累加器（LongAdder）"><a href="#整长型累加器（LongAdder）" class="headerlink" title="整长型累加器（LongAdder）"></a>整长型累加器（LongAdder）</h2><p>基于Redis的Redisson分布式整长型累加器（LongAdder）采用了与java.util.concurrent.atomic.LongAdder类似的接口。通过利用客户端内置的LongAdder对象，为分布式环境下递增和递减操作提供了很高得性能。据统计其性能最高比分布式AtomicLong对象快 12000 倍。完美适用于分布式统计计量场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RLongAdder atomicLong &#x3D; redisson.getLongAdder(&quot;myLongAdder&quot;);</span><br><span class="line">atomicLong.add(12);</span><br><span class="line">atomicLong.increment();</span><br><span class="line">atomicLong.decrement();</span><br><span class="line">atomicLong.sum();</span><br><span class="line">当不再使用整长型累加器对象的时候应该自行手动销毁，如果Redisson对象被关闭（shutdown）了，则不用手动销毁。</span><br><span class="line"></span><br><span class="line">RLongAdder atomicLong &#x3D; ...</span><br><span class="line">atomicLong.destroy();</span><br></pre></td></tr></table></figure>
<h2 id="双精度浮点累加器（DoubleAdder）"><a href="#双精度浮点累加器（DoubleAdder）" class="headerlink" title="双精度浮点累加器（DoubleAdder）"></a>双精度浮点累加器（DoubleAdder）</h2><p>基于Redis的Redisson分布式双精度浮点累加器（DoubleAdder）采用了与java.util.concurrent.atomic.DoubleAdder类似的接口。通过利用客户端内置的DoubleAdder对象，为分布式环境下递增和递减操作提供了很高得性能。据统计其性能最高比分布式AtomicDouble对象快 12000 倍。完美适用于分布式统计计量场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RLongDouble atomicDouble &#x3D; redisson.getLongDouble(&quot;myLongDouble&quot;);</span><br><span class="line">atomicDouble.add(12);</span><br><span class="line">atomicDouble.increment();</span><br><span class="line">atomicDouble.decrement();</span><br><span class="line">atomicDouble.sum();</span><br></pre></td></tr></table></figure>
<p>当不再使用双精度浮点累加器对象的时候应该自行手动销毁，如果Redisson对象被关闭（shutdown）了，则不用手动销毁。</p>
<h2 id="限流器（RateLimiter）"><a href="#限流器（RateLimiter）" class="headerlink" title="限流器（RateLimiter）"></a>限流器（RateLimiter）</h2><p>基于Redis的分布式限流器（RateLimiter）可以用来在分布式环境下现在请求方的调用频率。既适用于不同Redisson实例下的多线程限流，也适用于相同Redisson实例下的多线程限流。该算法不保证公平性。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RRateLimiter rateLimiter &#x3D; redisson.getRateLimiter(&quot;myRateLimiter&quot;);</span><br><span class="line">&#x2F;&#x2F; 初始化</span><br><span class="line">&#x2F;&#x2F; 最大流速 &#x3D; 每1秒钟产生10个令牌</span><br><span class="line">rateLimiter.trySetRate(RateType.OVERALL, 10, 1, RateIntervalUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">CountDownLatch latch &#x3D; new CountDownLatch(2);</span><br><span class="line">limiter.acquire(3);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">Thread t &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">    limiter.acquire(2);</span><br><span class="line">    &#x2F;&#x2F; ...        </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="五、分布式集合"><a href="#五、分布式集合" class="headerlink" title="五、分布式集合"></a>五、分布式集合</h1><h2 id="1、映射（Map）"><a href="#1、映射（Map）" class="headerlink" title="1、映射（Map）"></a>1、映射（Map）</h2><p>基于Redis的Redisson的分布式映射结构的RMap Java对象实现了java.util.concurrent.ConcurrentMap接口和java.util.Map接口。与HashMap不同的是，RMap保持了元素的插入顺序。该对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<p>除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。如果你想用Redis Map来保存你的POJO的话，可以考虑使用分布式实时对象（Live Object）服务。</p>
<p>在特定的场景下，映射缓存（Map）上的高度频繁的读取操作，使网络通信都被视为瓶颈时，可以使用Redisson提供的带有本地缓存功能的映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RMap&lt;String, SomeObject&gt; map &#x3D; redisson.getMap(&quot;anyMap&quot;);</span><br><span class="line">SomeObject prevObject &#x3D; map.put(&quot;123&quot;, new SomeObject());</span><br><span class="line">SomeObject currentObject &#x3D; map.putIfAbsent(&quot;323&quot;, new SomeObject());</span><br><span class="line">SomeObject obj &#x3D; map.remove(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line">map.fastPut(&quot;321&quot;, new SomeObject());</span><br><span class="line">map.fastRemove(&quot;321&quot;);</span><br><span class="line"></span><br><span class="line">RFuture&lt;SomeObject&gt; putAsyncFuture &#x3D; map.putAsync(&quot;321&quot;);</span><br><span class="line">RFuture&lt;Void&gt; fastPutAsyncFuture &#x3D; map.fastPutAsync(&quot;321&quot;);</span><br><span class="line"></span><br><span class="line">map.fastPutAsync(&quot;321&quot;, new SomeObject());</span><br><span class="line">map.fastRemoveAsync(&quot;321&quot;);</span><br></pre></td></tr></table></figure>
<p>映射的字段锁的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RMap&lt;MyKey, MyValue&gt; map &#x3D; redisson.getMap(&quot;anyMap&quot;);</span><br><span class="line">MyKey k &#x3D; new MyKey();</span><br><span class="line">RLock keyLock &#x3D; map.getLock(k);</span><br><span class="line">keyLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">   MyValue v &#x3D; map.get(k);</span><br><span class="line">   &#x2F;&#x2F; 其他业务逻辑</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   keyLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RReadWriteLock rwLock &#x3D; map.getReadWriteLock(k);</span><br><span class="line">rwLock.readLock().lock();</span><br><span class="line">try &#123;</span><br><span class="line">   MyValue v &#x3D; map.get(k);</span><br><span class="line">   &#x2F;&#x2F; 其他业务逻辑</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   keyLock.readLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="映射（Map）的元素淘汰（Eviction），本地缓存（LocalCache）和数据分片（Sharding）"><a href="#映射（Map）的元素淘汰（Eviction），本地缓存（LocalCache）和数据分片（Sharding）" class="headerlink" title="映射（Map）的元素淘汰（Eviction），本地缓存（LocalCache）和数据分片（Sharding）"></a>映射（Map）的元素淘汰（Eviction），本地缓存（LocalCache）和数据分片（Sharding）</h3><p>Redisson提供了一系列的映射类型的数据结构，这些结构按特性主要分为三大类：</p>
<p>*<em>元素淘汰（Eviction） *</em>类 – 带有元素淘汰（Eviction）机制的映射类允许针对一个映射中每个元素单独设定 有效时间 和 最长闲置时间 。</p>
<p><strong>本地缓存（LocalCache）</strong> 类 – 本地缓存（Local Cache）也叫就近缓存（Near Cache）。这类映射的使用主要用于在特定的场景下，映射缓存（MapCache）上的高度频繁的读取操作，使网络通信都被视为瓶颈的情况。Redisson与Redis通信的同时，还将部分数据保存在本地内存里。这样的设计的好处是它能将读取速度提高最多 45倍 。 所有同名的本地缓存共用一个订阅发布话题，所有更新和过期消息都将通过该话题共享。</p>
<p><strong>数据分片（Sharding）</strong> 类 – 数据分片（Sharding）类仅适用于Redis集群环境下，因此带有数据分片（Sharding）功能的映射也叫集群分布式映射。它利用分库的原理，将单一一个映射结构切分为若干个小的映射，并均匀的分布在集群中的各个槽里。这样的设计能使一个单一映射结构突破Redis自身的容量限制，让其容量随集群的扩大而增长。在扩容的同时，还能够使读写性能和元素淘汰处理能力随之成线性增长。</p>
<p>以下列表是Redisson提供的所有映射的名称及其特性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">接口名称</span><br><span class="line">中文名称	RedissonClient</span><br><span class="line">对应的构造方法	本地缓存功能</span><br><span class="line">Local Cache	数据分片功能</span><br><span class="line">Sharding	元素淘汰功能</span><br><span class="line">Eviction</span><br><span class="line">RMap</span><br><span class="line">映射	getMap()</span><br><span class="line"> 	No	No	No</span><br><span class="line">RMapCache</span><br><span class="line">映射缓存	getMapCache()</span><br><span class="line"> 	No	No	Yes</span><br><span class="line">RLocalCachedMap</span><br><span class="line">本地缓存映射	getLocalCachedMap()</span><br><span class="line"> 	Yes	No	No</span><br><span class="line">RLocalCachedMap</span><br><span class="line">Cache</span><br><span class="line">本地缓存映射缓存</span><br><span class="line">仅限于Redisson PRO版本	getLocalCachedMapCache()	Yes	No	Yes</span><br><span class="line">RClusteredMap</span><br><span class="line">集群分布式映射存</span><br><span class="line">仅限于Redisson PRO版本	getClusteredMap()	No	Yes	No</span><br><span class="line">RClusteredMapCache</span><br><span class="line">集群分布式映射缓存存</span><br><span class="line">仅限于Redisson PRO版本	getClusteredMapCache()	No	Yes	Yes</span><br><span class="line">RClusteredLocal</span><br><span class="line">CachedMap</span><br><span class="line">集群分布式本地缓存映射存</span><br><span class="line">仅限于Redisson PRO版本	getClusteredLocal</span><br><span class="line">CachedMap()	Yes	Yes	No</span><br><span class="line">RClusteredLocal</span><br><span class="line">CachedMapCache</span><br><span class="line">集群分布式本地缓存映射缓存存</span><br><span class="line">仅限于Redisson PRO版本	getClusteredLocal</span><br><span class="line">CachedMapCache()	Yes	Yes	Yes</span><br><span class="line">除此以外，Redisson还提供了Spring Cache和JCache的实现。</span><br></pre></td></tr></table></figure>
<h4 id="元素淘汰功能（Eviction）"><a href="#元素淘汰功能（Eviction）" class="headerlink" title="元素淘汰功能（Eviction）"></a>元素淘汰功能（Eviction）</h4><p>Redisson的分布式的RMapCache Java对象在基于RMap的前提下实现了针对单个元素的淘汰机制。同时仍然保留了元素的插入顺序。由于RMapCache是基于RMap实现的，使它同时继承了java.util.concurrent.ConcurrentMap接口和java.util.Map接口。Redisson提供的Spring Cache整合以及JCache正是基于这样的功能来实现的。</p>
<p>目前的Redis自身并不支持散列（Hash）当中的元素淘汰，因此所有过期元素都是通过org.redisson.EvictionScheduler实例来实现定期清理的。为了保证资源的有效利用，每次运行最多清理300个过期元素。任务的启动时间将根据上次实际清理数量自动调整，间隔时间趋于1秒到1小时之间。比如该次清理时删除了300条元素，那么下次执行清理的时间将在1秒以后（最小间隔时间）。一旦该次清理数量少于上次清理数量，时间间隔将增加1.5倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RMapCache&lt;String, SomeObject&gt; map &#x3D; redisson.getMapCache(&quot;anyMap&quot;);</span><br><span class="line">&#x2F;&#x2F; 有效时间 ttl &#x3D; 10分钟</span><br><span class="line">map.put(&quot;key1&quot;, new SomeObject(), 10, TimeUnit.MINUTES);</span><br><span class="line">&#x2F;&#x2F; 有效时间 ttl &#x3D; 10分钟, 最长闲置时间 maxIdleTime &#x3D; 10秒钟</span><br><span class="line">map.put(&quot;key1&quot;, new SomeObject(), 10, TimeUnit.MINUTES, 10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 有效时间 &#x3D; 3 秒钟</span><br><span class="line">map.putIfAbsent(&quot;key2&quot;, new SomeObject(), 3, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F; 有效时间 ttl &#x3D; 40秒钟, 最长闲置时间 maxIdleTime &#x3D; 10秒钟</span><br><span class="line">map.putIfAbsent(&quot;key2&quot;, new SomeObject(), 40, TimeUnit.SECONDS, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h4 id="本地缓存功能（Local-Cache）"><a href="#本地缓存功能（Local-Cache）" class="headerlink" title="本地缓存功能（Local Cache）"></a>本地缓存功能（Local Cache）</h4><p>在特定的场景下，映射（Map）上的高度频繁的读取操作，使网络通信都被视为瓶颈时，使用Redisson提供的带有本地缓存功能的分布式本地缓存映射RLocalCachedMapJava对象会是一个很好的选择。它同时实现了java.util.concurrent.ConcurrentMap和java.util.Map两个接口。本地缓存功能充分的利用了JVM的自身内存空间，对部分常用的元素实行就地缓存，这样的设计让读取操作的性能较分布式映射相比提高最多 45倍 。以下配置参数可以用来创建这个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">LocalCachedMapOptions options = LocalCachedMapOptions.defaults()</span><br><span class="line">      <span class="comment">// 用于淘汰清除本地缓存内的元素</span></span><br><span class="line">      <span class="comment">// 共有以下几种选择:</span></span><br><span class="line">      <span class="comment">// LFU - 统计元素的使用频率，淘汰用得最少（最不常用）的。</span></span><br><span class="line">      <span class="comment">// LRU - 按元素使用时间排序比较，淘汰最早（最久远）的。</span></span><br><span class="line">      <span class="comment">// SOFT - 元素用Java的WeakReference来保存，缓存元素通过GC过程清除。</span></span><br><span class="line">      <span class="comment">// WEAK - 元素用Java的SoftReference来保存, 缓存元素通过GC过程清除。</span></span><br><span class="line">      <span class="comment">// NONE - 永不淘汰清除缓存元素。</span></span><br><span class="line">     .evictionPolicy(EvictionPolicy.NONE)</span><br><span class="line">     <span class="comment">// 如果缓存容量值为0表示不限制本地缓存容量大小</span></span><br><span class="line">     .cacheSize(<span class="number">1000</span>)</span><br><span class="line">      <span class="comment">// 以下选项适用于断线原因造成了未收到本地缓存更新消息的情况。</span></span><br><span class="line">      <span class="comment">// 断线重连的策略有以下几种：</span></span><br><span class="line">      <span class="comment">// CLEAR - 如果断线一段时间以后则在重新建立连接以后清空本地缓存</span></span><br><span class="line">      <span class="comment">// LOAD - 在服务端保存一份10分钟的作废日志</span></span><br><span class="line">      <span class="comment">//        如果10分钟内重新建立连接，则按照作废日志内的记录清空本地缓存的元素</span></span><br><span class="line">      <span class="comment">//        如果断线时间超过了这个时间，则将清空本地缓存中所有的内容</span></span><br><span class="line">      <span class="comment">// NONE - 默认值。断线重连时不做处理。</span></span><br><span class="line">     .reconnectionStrategy(ReconnectionStrategy.NONE)</span><br><span class="line">      <span class="comment">// 以下选项适用于不同本地缓存之间相互保持同步的情况</span></span><br><span class="line">      <span class="comment">// 缓存同步策略有以下几种：</span></span><br><span class="line">      <span class="comment">// INVALIDATE - 默认值。当本地缓存映射的某条元素发生变动时，同时驱逐所有相同本地缓存映射内的该元素</span></span><br><span class="line">      <span class="comment">// UPDATE - 当本地缓存映射的某条元素发生变动时，同时更新所有相同本地缓存映射内的该元素</span></span><br><span class="line">      <span class="comment">// NONE - 不做任何同步处理</span></span><br><span class="line">     .syncStrategy(SyncStrategy.INVALIDATE)</span><br><span class="line">      <span class="comment">// 每个Map本地缓存里元素的有效时间，默认毫秒为单位</span></span><br><span class="line">     .timeToLive(<span class="number">10000</span>)</span><br><span class="line">      <span class="comment">// 或者</span></span><br><span class="line">     .timeToLive(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">      <span class="comment">// 每个Map本地缓存里元素的最长闲置时间，默认毫秒为单位</span></span><br><span class="line">     .maxIdle(<span class="number">10000</span>)</span><br><span class="line">      <span class="comment">// 或者</span></span><br><span class="line">     .maxIdle(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">RLocalCachedMap&lt;String, Integer&gt; map = redisson.getLocalCachedMap(<span class="string">"test"</span>, options);</span><br><span class="line"></span><br><span class="line">String prevObject = map.put(<span class="string">"123"</span>, <span class="number">1</span>);</span><br><span class="line">String currentObject = map.putIfAbsent(<span class="string">"323"</span>, <span class="number">2</span>);</span><br><span class="line">String obj = map.remove(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在不需要旧值的情况下可以使用fast为前缀的类似方法</span></span><br><span class="line">map.fastPut(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">map.fastPutIfAbsent(<span class="string">"d"</span>, <span class="number">32</span>);</span><br><span class="line">map.fastRemove(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">RFuture&lt;String&gt; putAsyncFuture = map.putAsync(<span class="string">"321"</span>);</span><br><span class="line">RFuture&lt;Void&gt; fastPutAsyncFuture = map.fastPutAsync(<span class="string">"321"</span>);</span><br><span class="line"></span><br><span class="line">map.fastPutAsync(<span class="string">"321"</span>, <span class="keyword">new</span> SomeObject());</span><br><span class="line">map.fastRemoveAsync(<span class="string">"321"</span>);</span><br></pre></td></tr></table></figure>
<p>当不再使用Map本地缓存对象的时候应该手动销毁，如果Redisson对象被关闭（shutdown）了，则不用手动销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RLocalCachedMap&lt;String, Integer&gt; map &#x3D; ...</span><br><span class="line">map.destroy();</span><br><span class="line">如何通过加载数据的方式来降低过期淘汰事件发布信息对网络的影响</span><br><span class="line">代码范例:</span><br><span class="line"></span><br><span class="line">public void loadData(String cacheName, Map&lt;String, String&gt; data) &#123;</span><br><span class="line">    RLocalCachedMap&lt;String, String&gt; clearMap &#x3D; redisson.getLocalCachedMap(cacheName, </span><br><span class="line">            LocalCachedMapOptions.defaults().cacheSize(1).syncStrategy(SyncStrategy.INVALIDATE));</span><br><span class="line">    RLocalCachedMap&lt;String, String&gt; loadMap &#x3D; redisson.getLocalCachedMap(cacheName, </span><br><span class="line">            LocalCachedMapOptions.defaults().cacheSize(1).syncStrategy(SyncStrategy.NONE));</span><br><span class="line">    </span><br><span class="line">    loadMap.putAll(data);</span><br><span class="line">    clearMap.clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据分片功能（Sharding）"><a href="#数据分片功能（Sharding）" class="headerlink" title="数据分片功能（Sharding）"></a>数据分片功能（Sharding）</h4><p>Map数据分片是Redis集群模式下的一个功能。Redisson提供的分布式集群映射RClusteredMap Java对象也是基于RMap实现的。它同时实现了java.util.concurrent.ConcurrentMap和java.util.Map两个接口。在这里可以获取更多的内部信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RClusteredMap&lt;String, SomeObject&gt; map &#x3D; redisson.getClusteredMap(&quot;anyMap&quot;);</span><br><span class="line"></span><br><span class="line">SomeObject prevObject &#x3D; map.put(&quot;123&quot;, new SomeObject());</span><br><span class="line">SomeObject currentObject &#x3D; map.putIfAbsent(&quot;323&quot;, new SomeObject());</span><br><span class="line">SomeObject obj &#x3D; map.remove(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line">map.fastPut(&quot;321&quot;, new SomeObject());</span><br><span class="line">map.fastRemove(&quot;321&quot;);</span><br></pre></td></tr></table></figure>
<h5 id="映射持久化方式（缓存策略）"><a href="#映射持久化方式（缓存策略）" class="headerlink" title="映射持久化方式（缓存策略）"></a>映射持久化方式（缓存策略）</h5><p>Redisson供了将映射中的数据持久化到外部储存服务的功能。主要场景有一下几种：</p>
<ul>
<li>将Redisson的分布式映射类型作为业务和外部储存媒介之间的缓存。</li>
<li>或是用来增加Redisson映射类型中数据的持久性，或是用来增加已被驱逐的数据的寿命。</li>
<li>或是用来缓存数据库，Web服务或其他数据源的数据。</li>
</ul>
<h6 id="Read-through策略"><a href="#Read-through策略" class="headerlink" title="Read-through策略"></a>Read-through策略</h6><p>通俗的讲，如果一个被请求的数据不存在于Redisson的映射中的时候，Redisson将通过预先配置好的MapLoader对象加载数据。</p>
<h6 id="Write-through（数据同步写入）策略"><a href="#Write-through（数据同步写入）策略" class="headerlink" title="Write-through（数据同步写入）策略"></a>Write-through（数据同步写入）策略</h6><p>在遇到映射中某条数据被更改时，Redisson会首先通过预先配置好的MapWriter对象写入到外部储存系统，然后再更新Redis内的数据。</p>
<h6 id="Write-behind（数据异步写入）策略"><a href="#Write-behind（数据异步写入）策略" class="headerlink" title="Write-behind（数据异步写入）策略"></a>Write-behind（数据异步写入）策略</h6><p>对映射的数据的更改会首先写入到Redis，然后再使用异步的方式，通过MapWriter对象写入到外部储存系统。在并发环境下可以通过writeBehindThreads参数来控制写入线程的数量，已达到对外部储存系统写入并发量的控制。</p>
<p>以上策略适用于所有实现了RMap、RMapCache、RLocalCachedMap和RLocalCachedMapCache接口的对象。</p>
<p>配置范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MapOptions&lt;K, V&gt; options &#x3D; MapOptions.&lt;K, V&gt;defaults()</span><br><span class="line">                              .writer(myWriter)</span><br><span class="line">                              .loader(myLoader);</span><br><span class="line"></span><br><span class="line">RMap&lt;K, V&gt; map &#x3D; redisson.getMap(&quot;test&quot;, options);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RMapCache&lt;K, V&gt; map &#x3D; redisson.getMapCache(&quot;test&quot;, options);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RLocalCachedMap&lt;K, V&gt; map &#x3D; redisson.getLocalCachedMap(&quot;test&quot;, options);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RLocalCachedMapCache&lt;K, V&gt; map &#x3D; redisson.getLocalCachedMapCache(&quot;test&quot;, options);</span><br></pre></td></tr></table></figure>
<h3 id="映射监听器（Map-Listener）"><a href="#映射监听器（Map-Listener）" class="headerlink" title="映射监听器（Map Listener）"></a>映射监听器（Map Listener）</h3><p>Redisson为所有实现了RMapCache或RLocalCachedMapCache接口的对象提供了监听以下事件的监听器：</p>
<ul>
<li>事件 | 监听器 元素 添加 事件 | org.redisson.api.map.event.EntryCreatedListener</li>
<li>元素 过期 事件 | org.redisson.api.map.event.EntryExpiredListener</li>
<li>元素 删除 事件 | org.redisson.api.map.event.EntryRemovedListener</li>
<li>元素 更新 事件 | org.redisson.api.map.event.EntryUpdatedListener</li>
</ul>
<p>使用范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">RMapCache&lt;String, Integer&gt; map &#x3D; redisson.getMapCache(&quot;myMap&quot;);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RLocalCachedMapCache&lt;String, Integer&gt; map &#x3D; redisson.getLocalCachedMapCache(&quot;myMap&quot;, options);</span><br><span class="line"></span><br><span class="line">int updateListener &#x3D; map.addListener(new EntryUpdatedListener&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onUpdated(EntryEvent&lt;Integer, Integer&gt; event) &#123;</span><br><span class="line">          event.getKey(); &#x2F;&#x2F; 字段名</span><br><span class="line">          event.getValue() &#x2F;&#x2F; 新值</span><br><span class="line">          event.getOldValue() &#x2F;&#x2F; 旧值</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">int createListener &#x3D; map.addListener(new EntryCreatedListener&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onCreated(EntryEvent&lt;Integer, Integer&gt; event) &#123;</span><br><span class="line">          event.getKey(); &#x2F;&#x2F; 字段名</span><br><span class="line">          event.getValue() &#x2F;&#x2F; 值</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">int expireListener &#x3D; map.addListener(new EntryExpiredListener&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onExpired(EntryEvent&lt;Integer, Integer&gt; event) &#123;</span><br><span class="line">          event.getKey(); &#x2F;&#x2F; 字段名</span><br><span class="line">          event.getValue() &#x2F;&#x2F; 值</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">int removeListener &#x3D; map.addListener(new EntryRemovedListener&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onRemoved(EntryEvent&lt;Integer, Integer&gt; event) &#123;</span><br><span class="line">          event.getKey(); &#x2F;&#x2F; 字段名</span><br><span class="line">          event.getValue() &#x2F;&#x2F; 值</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">map.removeListener(updateListener);</span><br><span class="line">map.removeListener(createListener);</span><br><span class="line">map.removeListener(expireListener);</span><br><span class="line">map.removeListener(removeListener);</span><br></pre></td></tr></table></figure>
<h3 id="LRU有界映射"><a href="#LRU有界映射" class="headerlink" title="LRU有界映射"></a>LRU有界映射</h3><p>Redisson提供了基于Redis的以LRU为驱逐策略的分布式LRU有界映射对象。顾名思义，分布式LRU有界映射允许通过对其中元素按使用时间排序处理的方式，主动移除超过规定容量限制的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RMapCache&lt;String, String&gt; map &#x3D; redisson.getMapCache(&quot;map&quot;);</span><br><span class="line">&#x2F;&#x2F; 尝试将该映射的最大容量限制设定为10</span><br><span class="line">map.trySetMaxSize(10);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将该映射的最大容量限制设定或更改为10</span><br><span class="line">map.setMaxSize(10);</span><br><span class="line"></span><br><span class="line">map.put(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">map.put(&quot;3&quot;, &quot;3&quot;, 1, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h2 id="2、多值映射（Multimap）"><a href="#2、多值映射（Multimap）" class="headerlink" title="2、多值映射（Multimap）"></a>2、多值映射（Multimap）</h2><p>基于Redis的Redisson的分布式RMultimap Java对象允许Map中的一个字段值包含多个元素。 字段总数受Redis限制，每个Multimap最多允许有4 294 967 295个不同字段。</p>
<h3 id="基于集（Set）的多值映射（Multimap）"><a href="#基于集（Set）的多值映射（Multimap）" class="headerlink" title="基于集（Set）的多值映射（Multimap）"></a>基于集（Set）的多值映射（Multimap）</h3><p>基于Set的Multimap不允许一个字段值包含有重复的元素。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>RSetMultimap&lt;SimpleKey, SimpleValue&gt; map = redisson.getSetMultimap(“myMultimap”);<br>map.put(new SimpleKey(“0”), new SimpleValue(“1”));<br>map.put(new SimpleKey(“0”), new SimpleValue(“2”));<br>map.put(new SimpleKey(“3”), new SimpleValue(“4”));</p>
<p>Set<SimpleValue> allValues = map.get(new SimpleKey(“0”));</p>
<p>List<SimpleValue> newValues = Arrays.asList(new SimpleValue(“7”), new SimpleValue(“6”), new SimpleValue(“5”));<br>Set<SimpleValue> oldValues = map.replaceValues(new SimpleKey(“0”), newValues);</p>
<p>Set<SimpleValue> removedValues = map.removeAll(new SimpleKey(“0”));</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="基于列表（List）的多值映射（Multimap）"><a href="#基于列表（List）的多值映射（Multimap）" class="headerlink" title="基于列表（List）的多值映射（Multimap）"></a>基于列表（List）的多值映射（Multimap）</h3><p>基于List的Multimap在保持插入顺序的同时允许一个字段下包含重复的元素。</p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><p>RListMultimap&lt;SimpleKey, SimpleValue&gt; map = redisson.getListMultimap(“test1”);<br>map.put(new SimpleKey(“0”), new SimpleValue(“1”));<br>map.put(new SimpleKey(“0”), new SimpleValue(“2”));<br>map.put(new SimpleKey(“0”), new SimpleValue(“1”));<br>map.put(new SimpleKey(“3”), new SimpleValue(“4”));</p>
<p>List<SimpleValue> allValues = map.get(new SimpleKey(“0”));</p>
<p>Collection<SimpleValue> newValues = Arrays.asList(new SimpleValue(“7”), new SimpleValue(“6”), new SimpleValue(“5”));<br>List<SimpleValue> oldValues = map.replaceValues(new SimpleKey(“0”), newValues);</p>
<p>List<SimpleValue> removedValues = map.removeAll(new SimpleKey(“0”));</p>
<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="多值映射（Multimap）淘汰机制（Eviction）"><a href="#多值映射（Multimap）淘汰机制（Eviction）" class="headerlink" title="多值映射（Multimap）淘汰机制（Eviction）"></a>多值映射（Multimap）淘汰机制（Eviction）</h3><p>Multimap对象的淘汰机制是通过不同的接口来实现的。它们是RSetMultimapCache接口和RListMultimapCache接口，分别对应的是Set和List的Multimaps。</p>
<p>所有过期元素都是通过org.redisson.EvictionScheduler实例来实现定期清理的。为了保证资源的有效利用，每次运行最多清理100个过期元素。任务的启动时间将根据上次实际清理数量自动调整，间隔时间趋于1秒到2小时之间。比如该次清理时删除了100条元素，那么下次执行清理的时间将在1秒以后（最小间隔时间）。一旦该次清理数量少于上次清理数量，时间间隔将增加1.5倍。</p>
<p>RSetMultimapCache的使用范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RSetMultimapCache&lt;String, String&gt; multimap &#x3D; redisson.getSetMultimapCache(&quot;myMultimap&quot;);</span><br><span class="line">multimap.put(&quot;1&quot;, &quot;a&quot;);</span><br><span class="line">multimap.put(&quot;1&quot;, &quot;b&quot;);</span><br><span class="line">multimap.put(&quot;1&quot;, &quot;c&quot;);</span><br><span class="line"></span><br><span class="line">multimap.put(&quot;2&quot;, &quot;e&quot;);</span><br><span class="line">multimap.put(&quot;2&quot;, &quot;f&quot;);</span><br><span class="line"></span><br><span class="line">multimap.expireKey(&quot;2&quot;, 10, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<h2 id="3、集（Set）"><a href="#3、集（Set）" class="headerlink" title="3、集（Set）"></a>3、集（Set）</h2><p>基于Redis的Redisson的分布式Set结构的RSet Java对象实现了java.util.Set接口。通过元素的相互状态比较保证了每个元素的唯一性。该对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RSet&lt;SomeObject&gt; set &#x3D; redisson.getSet(&quot;anySet&quot;);</span><br><span class="line">set.add(new SomeObject());</span><br><span class="line">set.remove(new SomeObject());</span><br><span class="line">Redisson PRO版本中的Set对象还可以在Redis集群环境下支持单集合数据分片。</span><br></pre></td></tr></table></figure>
<h3 id="集（Set）淘汰机制（Eviction）"><a href="#集（Set）淘汰机制（Eviction）" class="headerlink" title="集（Set）淘汰机制（Eviction）"></a>集（Set）淘汰机制（Eviction）</h3><p>基于Redis的Redisson的分布式RSetCache Java对象在基于RSet的前提下实现了针对单个元素的淘汰机制。由于RSetCache是基于RSet实现的，使它还集成了java.util.Set接口。</p>
<p>目前的Redis自身并不支持Set当中的元素淘汰，因此所有过期元素都是通过org.redisson.EvictionScheduler实例来实现定期清理的。为了保证资源的有效利用，每次运行最多清理100个过期元素。任务的启动时间将根据上次实际清理数量自动调整，间隔时间趋于1秒到2小时之间。比如该次清理时删除了100条元素，那么下次执行清理的时间将在1秒以后（最小间隔时间）。一旦该次清理数量少于上次清理数量，时间间隔将增加1.5倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSetCache&lt;SomeObject&gt; set &#x3D; redisson.getSetCache(&quot;anySet&quot;);</span><br><span class="line">&#x2F;&#x2F; ttl &#x3D; 10 seconds</span><br><span class="line">set.add(new SomeObject(), 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h3 id="集（Set）数据分片（Sharding）"><a href="#集（Set）数据分片（Sharding）" class="headerlink" title="集（Set）数据分片（Sharding）"></a>集（Set）数据分片（Sharding）</h3><p>Set数据分片是Redis集群模式下的一个功能。Redisson提供的分布式RClusteredSet Java对象也是基于RSet实现的。在这里可以获取更多的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RClusteredSet&lt;SomeObject&gt; set &#x3D; redisson.getClusteredSet(&quot;anySet&quot;);</span><br><span class="line">set.add(new SomeObject());</span><br><span class="line">set.remove(new SomeObject());</span><br></pre></td></tr></table></figure>
<p>除了RClusteredSet以外，Redisson还提供了另一种集群模式下的分布式集（Set），它不仅提供了透明的数据分片功能，还为每个元素提供了淘汰机制。RClusteredSetCache 类分别同时提供了RClusteredSet 和RSetCache 这两个接口的实现。当然这些都是基于java.util.Set的接口实现上的。</p>
<p>该功能仅限于Redisson PRO版本。</p>
<h2 id="4、有序集（SortedSet）"><a href="#4、有序集（SortedSet）" class="headerlink" title="4、有序集（SortedSet）"></a>4、有序集（SortedSet）</h2><p>基于Redis的Redisson的分布式RSortedSet Java对象实现了java.util.SortedSet接口。在保证元素唯一性的前提下，通过比较器（Comparator）接口实现了对元素的排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RSortedSet&lt;Integer&gt; set &#x3D; redisson.getSortedSet(&quot;anySet&quot;);</span><br><span class="line">set.trySetComparator(new MyComparator()); &#x2F;&#x2F; 配置元素比较器</span><br><span class="line">set.add(3);</span><br><span class="line">set.add(1);</span><br><span class="line">set.add(2);</span><br><span class="line"></span><br><span class="line">set.removeAsync(0);</span><br><span class="line">set.addAsync(5);</span><br></pre></td></tr></table></figure>
<h2 id="5、计分排序集（ScoredSortedSet）"><a href="#5、计分排序集（ScoredSortedSet）" class="headerlink" title="5、计分排序集（ScoredSortedSet）"></a>5、计分排序集（ScoredSortedSet）</h2><p>基于Redis的Redisson的分布式RScoredSortedSet Java对象是一个可以按插入时指定的元素评分排序的集合。它同时还保证了元素的唯一性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RScoredSortedSet&lt;SomeObject&gt; set &#x3D; redisson.getScoredSortedSet(&quot;simple&quot;);</span><br><span class="line"></span><br><span class="line">set.add(0.13, new SomeObject(a, b));</span><br><span class="line">set.addAsync(0.251, new SomeObject(c, d));</span><br><span class="line">set.add(0.302, new SomeObject(g, d));</span><br><span class="line"></span><br><span class="line">set.pollFirst();</span><br><span class="line">set.pollLast();</span><br><span class="line"></span><br><span class="line">int index &#x3D; set.rank(new SomeObject(g, d)); &#x2F;&#x2F; 获取元素在集合中的位置</span><br><span class="line">Double score &#x3D; set.getScore(new SomeObject(g, d)); &#x2F;&#x2F; 获取元素的评分</span><br></pre></td></tr></table></figure>
<h2 id="6、字典排序集（LexSortedSet）"><a href="#6、字典排序集（LexSortedSet）" class="headerlink" title="6、字典排序集（LexSortedSet）"></a>6、字典排序集（LexSortedSet）</h2><p>基于Redis的Redisson的分布式RLexSortedSet Java对象在实现了java.util.Set<String>接口的同时，将其中的所有字符串元素按照字典顺序排列。它公式还保证了字符串元素的唯一性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RLexSortedSet set &#x3D; redisson.getLexSortedSet(&quot;simple&quot;);</span><br><span class="line">set.add(&quot;d&quot;);</span><br><span class="line">set.addAsync(&quot;e&quot;);</span><br><span class="line">set.add(&quot;f&quot;);</span><br><span class="line"></span><br><span class="line">set.lexRangeTail(&quot;d&quot;, false);</span><br><span class="line">set.lexCountHead(&quot;e&quot;);</span><br><span class="line">set.lexRange(&quot;d&quot;, true, &quot;z&quot;, false);</span><br></pre></td></tr></table></figure>
<h2 id="7、列表（List）"><a href="#7、列表（List）" class="headerlink" title="7、列表（List）"></a>7、列表（List）</h2><p>基于Redis的Redisson分布式列表（List）结构的RList Java对象在实现了java.util.List接口的同时，确保了元素插入时的顺序。该对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RList&lt;SomeObject&gt; list &#x3D; redisson.getList(&quot;anyList&quot;);</span><br><span class="line">list.add(new SomeObject());</span><br><span class="line">list.get(0);</span><br><span class="line">list.remove(new SomeObject());</span><br></pre></td></tr></table></figure>
<h2 id="8、队列（Queue）"><a href="#8、队列（Queue）" class="headerlink" title="8、队列（Queue）"></a>8、队列（Queue）</h2><p>基于Redis的Redisson分布式无界队列（Queue）结构的RQueue Java对象实现了java.util.Queue接口。尽管RQueue对象无初始大小（边界）限制，但对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RQueue&lt;SomeObject&gt; queue &#x3D; redisson.getQueue(&quot;anyQueue&quot;);</span><br><span class="line">queue.add(new SomeObject());</span><br><span class="line">SomeObject obj &#x3D; queue.peek();</span><br><span class="line">SomeObject someObj &#x3D; queue.poll();</span><br></pre></td></tr></table></figure>
<h2 id="9、双端队列（Deque）"><a href="#9、双端队列（Deque）" class="headerlink" title="9、双端队列（Deque）"></a>9、双端队列（Deque）</h2><p>基于Redis的Redisson分布式无界双端队列（Deque）结构的RDeque Java对象实现了java.util.Deque接口。尽管RDeque对象无初始大小（边界）限制，但对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RDeque&lt;SomeObject&gt; queue &#x3D; redisson.getDeque(&quot;anyDeque&quot;);</span><br><span class="line">queue.addFirst(new SomeObject());</span><br><span class="line">queue.addLast(new SomeObject());</span><br><span class="line">SomeObject obj &#x3D; queue.removeFirst();</span><br><span class="line">SomeObject someObj &#x3D; queue.removeLast();</span><br></pre></td></tr></table></figure>
<h2 id="10、阻塞队列（Blocking-Queue）"><a href="#10、阻塞队列（Blocking-Queue）" class="headerlink" title="10、阻塞队列（Blocking Queue）"></a>10、阻塞队列（Blocking Queue）</h2><p>基于Redis的Redisson分布式无界阻塞队列（Blocking Queue）结构的RBlockingQueue Java对象实现了java.util.concurrent.BlockingQueue接口。尽管RBlockingQueue对象无初始大小（边界）限制，但对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RBlockingQueue&lt;SomeObject&gt; queue &#x3D; redisson.getBlockingQueue(&quot;anyQueue&quot;);</span><br><span class="line">queue.offer(new SomeObject());</span><br><span class="line"></span><br><span class="line">SomeObject obj &#x3D; queue.peek();</span><br><span class="line">SomeObject someObj &#x3D; queue.poll();</span><br><span class="line">SomeObject ob &#x3D; queue.poll(10, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>poll, pollFromAny, pollLastAndOfferFirstTo和take方法内部采用话题订阅发布实现，在Redis节点故障转移（主从切换）或断线重连以后，内置的相关话题监听器将自动完成话题的重新订阅。</p>
<h2 id="11、有界阻塞队列（Bounded-Blocking-Queue）"><a href="#11、有界阻塞队列（Bounded-Blocking-Queue）" class="headerlink" title="11、有界阻塞队列（Bounded Blocking Queue）"></a>11、有界阻塞队列（Bounded Blocking Queue）</h2><p>基于Redis的Redisson分布式有界阻塞队列（Bounded Blocking Queue）结构的RBoundedBlockingQueue Java对象实现了java.util.concurrent.BlockingQueue接口。该对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。队列的初始容量（边界）必须在使用前设定好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RBoundedBlockingQueue&lt;SomeObject&gt; queue &#x3D; redisson.getBoundedBlockingQueue(&quot;anyQueue&quot;);</span><br><span class="line">&#x2F;&#x2F; 如果初始容量（边界）设定成功则返回&#96;真（true）&#96;，</span><br><span class="line">&#x2F;&#x2F; 如果初始容量（边界）已近存在则返回&#96;假（false）&#96;。</span><br><span class="line">queue.trySetCapacity(2);</span><br><span class="line"></span><br><span class="line">queue.offer(new SomeObject(1));</span><br><span class="line">queue.offer(new SomeObject(2));</span><br><span class="line">&#x2F;&#x2F; 此时容量已满，下面代码将会被阻塞，直到有空闲为止。</span><br><span class="line">queue.put(new SomeObject());</span><br><span class="line"></span><br><span class="line">SomeObject obj &#x3D; queue.peek();</span><br><span class="line">SomeObject someObj &#x3D; queue.poll();</span><br><span class="line">SomeObject ob &#x3D; queue.poll(10, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>poll, pollFromAny, pollLastAndOfferFirstTo和take方法内部采用话题订阅发布实现，在Redis节点故障转移（主从切换）或断线重连以后，内置的相关话题监听器将自动完成话题的重新订阅。</p>
<h2 id="12-阻塞双端队列（Blocking-Deque）"><a href="#12-阻塞双端队列（Blocking-Deque）" class="headerlink" title="12. 阻塞双端队列（Blocking Deque）"></a>12. 阻塞双端队列（Blocking Deque）</h2><p>基于Redis的Redisson分布式无界阻塞双端队列（Blocking Deque）结构的RBlockingDeque Java对象实现了java.util.concurrent.BlockingDeque接口。尽管RBlockingDeque对象无初始大小（边界）限制，但对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RBlockingDeque&lt;Integer&gt; deque &#x3D; redisson.getBlockingDeque(&quot;anyDeque&quot;);</span><br><span class="line">deque.putFirst(1);</span><br><span class="line">deque.putLast(2);</span><br><span class="line">Integer firstValue &#x3D; queue.takeFirst();</span><br><span class="line">Integer lastValue &#x3D; queue.takeLast();</span><br><span class="line">Integer firstValue &#x3D; queue.pollFirst(10, TimeUnit.MINUTES);</span><br><span class="line">Integer lastValue &#x3D; queue.pollLast(3, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>poll, pollFromAny, pollLastAndOfferFirstTo和take方法内部采用话题订阅发布实现，在Redis节点故障转移（主从切换）或断线重连以后，内置的相关话题监听器将自动完成话题的重新订阅。</p>
<h2 id="13-阻塞公平队列（Blocking-Fair-Queue）"><a href="#13-阻塞公平队列（Blocking-Fair-Queue）" class="headerlink" title="13. 阻塞公平队列（Blocking Fair Queue）"></a>13. 阻塞公平队列（Blocking Fair Queue）</h2><p>基于Redis的Redisson分布式无界阻塞公平队列（Blocking Fair Queue）结构的RBlockingFairQueue Java对象在实现Redisson分布式无界阻塞队列（Blocking Queue）结构RBlockingQueue接口的基础上，解决了多个队列消息的处理者在复杂的网络环境下，网络延时的影响使“较远”的客户端最终收到消息数量低于“较近”的客户端的问题。从而解决了这种现象引发的个别处理节点过载的情况。</p>
<p>以分布式无界阻塞队列为基础，采用公平获取消息的机制，不仅保证了poll、pollFromAny、pollLastAndOfferFirstTo和take方法获取消息的先入顺序，还能让队列里的消息被均匀的发布到处在复杂分布式环境中的各个处理节点里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RBlockingFairQueue queue &#x3D; redisson.getBlockingFairQueue(&quot;myQueue&quot;);</span><br><span class="line">queue.offer(new SomeObject());</span><br><span class="line"></span><br><span class="line">SomeObject obj &#x3D; queue.peek();</span><br><span class="line">SomeObject someObj &#x3D; queue.poll();</span><br><span class="line">SomeObject ob &#x3D; queue.poll(10, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>该功能仅限于Redisson PRO版本。</p>
<h2 id="14-阻塞公平双端队列（Blocking-Fair-Deque）"><a href="#14-阻塞公平双端队列（Blocking-Fair-Deque）" class="headerlink" title="14. 阻塞公平双端队列（Blocking Fair Deque）"></a>14. 阻塞公平双端队列（Blocking Fair Deque）</h2><p>基于Redis的Redisson分布式无界阻塞公平双端队列（Blocking Fair Deque）结构的RBlockingFairDeque Java对象在实现Redisson分布式无界阻塞双端队列（Blocking Deque）结构RBlockingDeque接口的基础上，解决了多个队列消息的处理者在复杂的网络环境下，网络延时的影响使“较远”的客户端最终收到消息数量低于“较近”的客户端的问题。从而解决了这种现象引发的个别处理节点过载的情况。</p>
<p>以分布式无界阻塞双端队列为基础，采用公平获取消息的机制，不仅保证了poll、take、pollFirst、takeFirst、pollLast和takeLast方法获取消息的先入顺序，还能让队列里的消息被均匀的发布到处在复杂分布式环境中的各个处理节点里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RBlockingFairDeque deque &#x3D; redisson.getBlockingFairDeque(&quot;myDeque&quot;);</span><br><span class="line">deque.offer(new SomeObject());</span><br><span class="line"></span><br><span class="line">SomeObject firstElement &#x3D; queue.peekFirst();</span><br><span class="line">SomeObject firstElement &#x3D; queue.pollFirst();</span><br><span class="line">SomeObject firstElement &#x3D; queue.pollFirst(10, TimeUnit.MINUTES);</span><br><span class="line">SomeObject firstElement &#x3D; queue.takeFirst();</span><br><span class="line"></span><br><span class="line">SomeObject lastElement &#x3D; queue.peekLast();</span><br><span class="line">SomeObject lastElement &#x3D; queue.pollLast();</span><br><span class="line">SomeObject lastElement &#x3D; queue.pollLast(10, TimeUnit.MINUTES);</span><br><span class="line">SomeObject lastElement &#x3D; queue.takeLast();</span><br></pre></td></tr></table></figure>
<p>该功能仅限于Redisson PRO版本。</p>
<h2 id="15-延迟队列（Delayed-Queue）"><a href="#15-延迟队列（Delayed-Queue）" class="headerlink" title="15. 延迟队列（Delayed Queue）"></a>15. 延迟队列（Delayed Queue）</h2><p>基于Redis的Redisson分布式延迟队列（Delayed Queue）结构的RDelayedQueue Java对象在实现了RQueue接口的基础上提供了向队列按要求延迟添加项目的功能。该功能可以用来实现消息传送延迟按几何增长或几何衰减的发送策略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RQueue&lt;String&gt; distinationQueue &#x3D; ...</span><br><span class="line">RDelayedQueue&lt;String&gt; delayedQueue &#x3D; getDelayedQueue(distinationQueue);</span><br><span class="line">&#x2F;&#x2F; 10秒钟以后将消息发送到指定队列</span><br><span class="line">delayedQueue.offer(&quot;msg1&quot;, 10, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F; 一分钟以后将消息发送到指定队列</span><br><span class="line">delayedQueue.offer(&quot;msg2&quot;, 1, TimeUnit.MINUTES);</span><br><span class="line">在该对象不再需要的情况下，应该主动销毁。仅在相关的Redisson对象也需要关闭的时候可以不用主动销毁。</span><br><span class="line"></span><br><span class="line">RDelayedQueue&lt;String&gt; delayedQueue &#x3D; ...</span><br><span class="line">delayedQueue.destroy();</span><br></pre></td></tr></table></figure>
<h2 id="16-优先队列（Priority-Queue）"><a href="#16-优先队列（Priority-Queue）" class="headerlink" title="16. 优先队列（Priority Queue）"></a>16. 优先队列（Priority Queue）</h2><p>基于Redis的Redisson分布式优先队列（Priority Queue）Java对象实现了java.util.Queue的接口。可以通过比较器（Comparator）接口来对元素排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RPriorityQueue&lt;Integer&gt; queue &#x3D; redisson.getPriorityQueue(&quot;anyQueue&quot;);</span><br><span class="line">queue.trySetComparator(new MyComparator()); &#x2F;&#x2F; 指定对象比较器</span><br><span class="line">queue.add(3);</span><br><span class="line">queue.add(1);</span><br><span class="line">queue.add(2);</span><br><span class="line"></span><br><span class="line">queue.removeAsync(0);</span><br><span class="line">queue.addAsync(5);</span><br><span class="line"></span><br><span class="line">queue.poll();</span><br></pre></td></tr></table></figure>
<h2 id="17-优先双端队列（Priority-Deque）"><a href="#17-优先双端队列（Priority-Deque）" class="headerlink" title="17. 优先双端队列（Priority Deque）"></a>17. 优先双端队列（Priority Deque）</h2><p>基于Redis的Redisson分布式优先双端队列（Priority Deque）Java对象实现了java.util.Deque的接口。可以通过比较器（Comparator）接口来对元素排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RPriorityDeque&lt;Integer&gt; queue &#x3D; redisson.getPriorityDeque(&quot;anyQueue&quot;);</span><br><span class="line">queue.trySetComparator(new MyComparator()); &#x2F;&#x2F; 指定对象比较器</span><br><span class="line">queue.addLast(3);</span><br><span class="line">queue.addFirst(1);</span><br><span class="line">queue.add(2);</span><br><span class="line"></span><br><span class="line">queue.removeAsync(0);</span><br><span class="line">queue.addAsync(5);</span><br><span class="line"></span><br><span class="line">queue.pollFirst();</span><br><span class="line">queue.pollLast();</span><br></pre></td></tr></table></figure>
<h2 id="18-优先阻塞队列（Priority-Blocking-Queue）"><a href="#18-优先阻塞队列（Priority-Blocking-Queue）" class="headerlink" title="18. 优先阻塞队列（Priority Blocking Queue）"></a>18. 优先阻塞队列（Priority Blocking Queue）</h2><p>基于Redis的分布式无界优先阻塞队列（Priority Blocking Queue）Java对象的结构与java.util.concurrent.PriorityBlockingQueue类似。可以通过比较器（Comparator）接口来对元素排序。PriorityBlockingQueue的最大容量是4 294 967 295个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RPriorityBlockingQueue&lt;Integer&gt; queue &#x3D; redisson.getPriorityBlockingQueue(&quot;anyQueue&quot;);</span><br><span class="line">queue.trySetComparator(new MyComparator()); &#x2F;&#x2F; 指定对象比较器</span><br><span class="line">queue.add(3);</span><br><span class="line">queue.add(1);</span><br><span class="line">queue.add(2);</span><br><span class="line"></span><br><span class="line">queue.removeAsync(0);</span><br><span class="line">queue.addAsync(5);</span><br><span class="line"></span><br><span class="line">queue.take();</span><br></pre></td></tr></table></figure>
<p>当Redis服务端断线重连以后，或Redis服务端发生主从切换，并重新建立连接后，断线时正在使用poll，pollLastAndOfferFirstTo或take方法的对象Redisson将自动再次为其订阅相关的话题。</p>
<h2 id="19-优先阻塞双端队列（Priority-Blocking-Deque）"><a href="#19-优先阻塞双端队列（Priority-Blocking-Deque）" class="headerlink" title="19. 优先阻塞双端队列（Priority Blocking Deque）"></a>19. 优先阻塞双端队列（Priority Blocking Deque）</h2><p>基于Redis的分布式无界优先阻塞双端队列（Priority Blocking Deque）Java对象实现了java.util.Deque的接口。addLast、 addFirst、push方法不能再这个对里使用。PriorityBlockingDeque的最大容量是4 294 967 295个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RPriorityBlockingDeque&lt;Integer&gt; queue &#x3D; redisson.getPriorityBlockingDeque(&quot;anyQueue&quot;);</span><br><span class="line">queue.trySetComparator(new MyComparator()); &#x2F;&#x2F; 指定对象比较器</span><br><span class="line">queue.add(2);</span><br><span class="line"></span><br><span class="line">queue.removeAsync(0);</span><br><span class="line">queue.addAsync(5);</span><br><span class="line"></span><br><span class="line">queue.pollFirst();</span><br><span class="line">queue.pollLast();</span><br><span class="line">queue.takeFirst();</span><br><span class="line">queue.takeLast();</span><br></pre></td></tr></table></figure>
<p>当Redis服务端断线重连以后，或Redis服务端发生主从切换，并重新建立连接后，断线时正在使用poll，pollLastAndOfferFirstTo或take方法的对象Redisson将自动再次为其订阅相关的话题。</p>
<h1 id="六、分布式锁和同步器"><a href="#六、分布式锁和同步器" class="headerlink" title="六、分布式锁和同步器"></a>六、分布式锁和同步器</h1><h2 id="1-可重入锁（Reentrant-Lock）"><a href="#1-可重入锁（Reentrant-Lock）" class="headerlink" title="1. 可重入锁（Reentrant Lock）"></a>1. 可重入锁（Reentrant Lock）</h2><p>基于Redis的Redisson分布式可重入锁RLock Java对象实现了java.util.concurrent.locks.Lock接口。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);</span><br><span class="line">&#x2F;&#x2F; 最常见的使用方法</span><br><span class="line">lock.lock();</span><br></pre></td></tr></table></figure>
<p>大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。</p>
<p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 加锁以后10秒钟自动解锁</span><br><span class="line">&#x2F;&#x2F; 无需调用unlock方法手动解锁</span><br><span class="line">lock.lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span><br><span class="line">boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">if (res) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Redisson同时还为分布式锁提供了异步执行的相关方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);</span><br><span class="line">lock.lockAsync();</span><br><span class="line">lock.lockAsync(10, TimeUnit.SECONDS);</span><br><span class="line">Future&lt;Boolean&gt; res &#x3D; lock.tryLockAsync(100, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>RLock对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出IllegalMonitorStateException错误。但是如果遇到需要其他进程也能解锁的情况，请使用分布式信号量Semaphore 对象.</p>
<h2 id="2-公平锁（Fair-Lock）"><a href="#2-公平锁（Fair-Lock）" class="headerlink" title="2. 公平锁（Fair Lock）"></a>2. 公平锁（Fair Lock）</h2><p>基于Redis的Redisson分布式可重入公平锁也是实现了java.util.concurrent.locks.Lock接口的一种RLock对象。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RLock fairLock &#x3D; redisson.getFairLock(&quot;anyLock&quot;);</span><br><span class="line">&#x2F;&#x2F; 最常见的使用方法</span><br><span class="line">fairLock.lock();</span><br></pre></td></tr></table></figure>
<p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 10秒钟以后自动解锁</span><br><span class="line">&#x2F;&#x2F; 无需调用unlock方法手动解锁</span><br><span class="line">fairLock.lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span><br><span class="line">boolean res &#x3D; fairLock.tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">fairLock.unlock();</span><br><span class="line">Redisson同时还为分布式可重入公平锁提供了异步执行的相关方法：</span><br><span class="line"></span><br><span class="line">RLock fairLock &#x3D; redisson.getFairLock(&quot;anyLock&quot;);</span><br><span class="line">fairLock.lockAsync();</span><br><span class="line">fairLock.lockAsync(10, TimeUnit.SECONDS);</span><br><span class="line">Future&lt;Boolean&gt; res &#x3D; fairLock.tryLockAsync(100, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h2 id="3-联锁（MultiLock）"><a href="#3-联锁（MultiLock）" class="headerlink" title="3. 联锁（MultiLock）"></a>3. 联锁（MultiLock）</h2><p>基于Redis的Redisson分布式联锁RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RLock lock1 &#x3D; redissonInstance1.getLock(&quot;lock1&quot;);</span><br><span class="line">RLock lock2 &#x3D; redissonInstance2.getLock(&quot;lock2&quot;);</span><br><span class="line">RLock lock3 &#x3D; redissonInstance3.getLock(&quot;lock3&quot;);</span><br><span class="line"></span><br><span class="line">RedissonMultiLock lock &#x3D; new RedissonMultiLock(lock1, lock2, lock3);</span><br><span class="line">&#x2F;&#x2F; 同时加锁：lock1 lock2 lock3</span><br><span class="line">&#x2F;&#x2F; 所有的锁都上锁成功才算成功。</span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RedissonMultiLock lock &#x3D; new RedissonMultiLock(lock1, lock2, lock3);</span><br><span class="line">&#x2F;&#x2F; 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开</span><br><span class="line">lock.lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为加锁等待100秒时间，并在加锁成功10秒钟后自动解开</span><br><span class="line">boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h2 id="4-红锁（RedLock）"><a href="#4-红锁（RedLock）" class="headerlink" title="4. 红锁（RedLock）"></a>4. 红锁（RedLock）</h2><p>基于Redis的Redisson红锁RedissonRedLock对象实现了Redlock介绍的加锁算法。该对象也可以用来将多个RLock对象关联为一个红锁，每个RLock对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RLock lock1 &#x3D; redissonInstance1.getLock(&quot;lock1&quot;);</span><br><span class="line">RLock lock2 &#x3D; redissonInstance2.getLock(&quot;lock2&quot;);</span><br><span class="line">RLock lock3 &#x3D; redissonInstance3.getLock(&quot;lock3&quot;);</span><br><span class="line"></span><br><span class="line">RedissonRedLock lock &#x3D; new RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">&#x2F;&#x2F; 同时加锁：lock1 lock2 lock3</span><br><span class="line">&#x2F;&#x2F; 红锁在大部分节点上加锁成功就算成功。</span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RedissonRedLock lock &#x3D; new RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">&#x2F;&#x2F; 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开</span><br><span class="line">lock.lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为加锁等待100秒时间，并在加锁成功10秒钟后自动解开</span><br><span class="line">boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h2 id="5-读写锁（ReadWriteLock）"><a href="#5-读写锁（ReadWriteLock）" class="headerlink" title="5. 读写锁（ReadWriteLock）"></a>5. 读写锁（ReadWriteLock）</h2><p>基于Redis的Redisson分布式可重入读写锁RReadWriteLock Java对象实现了java.util.concurrent.locks.ReadWriteLock接口。其中读锁和写锁都继承了RLock接口。</p>
<p>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RReadWriteLock rwlock &#x3D; redisson.getReadWriteLock(&quot;anyRWLock&quot;);</span><br><span class="line">&#x2F;&#x2F; 最常见的使用方法</span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">rwlock.writeLock().lock();</span><br></pre></td></tr></table></figure>
<p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 10秒钟以后自动解锁</span><br><span class="line">&#x2F;&#x2F; 无需调用unlock方法手动解锁</span><br><span class="line">rwlock.readLock().lock(10, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">rwlock.writeLock().lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span><br><span class="line">boolean res &#x3D; rwlock.readLock().tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">boolean res &#x3D; rwlock.writeLock().tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h2 id="6-信号量（Semaphore）"><a href="#6-信号量（Semaphore）" class="headerlink" title="6. 信号量（Semaphore）"></a>6. 信号量（Semaphore）</h2><p>基于Redis的Redisson的分布式信号量（Semaphore）Java对象RSemaphore采用了与java.util.concurrent.Semaphore相似的接口和用法。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RSemaphore semaphore &#x3D; redisson.getSemaphore(&quot;semaphore&quot;);</span><br><span class="line">semaphore.acquire();</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">semaphore.acquireAsync();</span><br><span class="line">semaphore.acquire(23);</span><br><span class="line">semaphore.tryAcquire();</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">semaphore.tryAcquireAsync();</span><br><span class="line">semaphore.tryAcquire(23, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">semaphore.tryAcquireAsync(23, TimeUnit.SECONDS);</span><br><span class="line">semaphore.release(10);</span><br><span class="line">semaphore.release();</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">semaphore.releaseAsync();</span><br></pre></td></tr></table></figure>
<h2 id="7-可过期性信号量（PermitExpirableSemaphore）"><a href="#7-可过期性信号量（PermitExpirableSemaphore）" class="headerlink" title="7. 可过期性信号量（PermitExpirableSemaphore）"></a>7. 可过期性信号量（PermitExpirableSemaphore）</h2><p>基于Redis的Redisson可过期性信号量（PermitExpirableSemaphore）是在RSemaphore对象的基础上，为每个信号增加了一个过期时间。每个信号可以通过独立的ID来辨识，释放时只能通过提交这个ID才能释放。它提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RPermitExpirableSemaphore semaphore &#x3D; redisson.getPermitExpirableSemaphore(&quot;mySemaphore&quot;);</span><br><span class="line">String permitId &#x3D; semaphore.acquire();</span><br><span class="line">&#x2F;&#x2F; 获取一个信号，有效期只有2秒钟。</span><br><span class="line">String permitId &#x3D; semaphore.acquire(2, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">semaphore.release(permitId);</span><br></pre></td></tr></table></figure>
<h2 id="8-闭锁（CountDownLatch）"><a href="#8-闭锁（CountDownLatch）" class="headerlink" title="8. 闭锁（CountDownLatch）"></a>8. 闭锁（CountDownLatch）</h2><p>基于Redisson的Redisson分布式闭锁（CountDownLatch）Java对象RCountDownLatch采用了与java.util.concurrent.CountDownLatch相似的接口和用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RCountDownLatch latch &#x3D; redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);</span><br><span class="line">latch.trySetCount(1);</span><br><span class="line">latch.await();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在其他线程或其他JVM里</span><br><span class="line">RCountDownLatch latch &#x3D; redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);</span><br><span class="line">latch.countDown();</span><br></pre></td></tr></table></figure>
<h1 id="七、分布式服务"><a href="#七、分布式服务" class="headerlink" title="七、分布式服务"></a>七、分布式服务</h1><h2 id="1-分布式远程服务（Remote-Service）"><a href="#1-分布式远程服务（Remote-Service）" class="headerlink" title="1. 分布式远程服务（Remote Service）"></a>1. 分布式远程服务（Remote Service）</h2><p>基于Redis的Java分布式远程服务，可以用来通过共享接口执行存在于另一个Redisson实例里的对象方法。换句话说就是通过Redis实现了Java的远程过程调用（RPC）。分布式远程服务基于可以用POJO对象，方法的参数和返回类不受限制，可以是任何类型。</p>
<p>分布式远程服务（Remote Service）提供了两种类型的RRemoteService实例：</p>
<p><strong>服务端（远端）实例</strong> - 用来执行远程方法（工作者实例即worker instance）. 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RRemoteService remoteService &#x3D; redisson.getRemoteService();</span><br><span class="line">SomeServiceImpl someServiceImpl &#x3D; new SomeServiceImpl();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在调用远程方法以前，应该首先注册远程服务</span><br><span class="line">&#x2F;&#x2F; 只注册了一个服务端工作者实例，只能同时执行一个并发调用</span><br><span class="line">remoteService.register(SomeServiceInterface.class, someServiceImpl);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册了12个服务端工作者实例，可以同时执行12个并发调用</span><br><span class="line">remoteService.register(SomeServiceInterface.class, someServiceImpl, 12);</span><br></pre></td></tr></table></figure>
<p><strong>客户端（本地）实例</strong> - 用来请求远程方法. 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RRemoteService remoteService &#x3D; redisson.getRemoteService();</span><br><span class="line">SomeServiceInterface service &#x3D; remoteService.get(SomeServiceInterface.class);</span><br><span class="line"></span><br><span class="line">String result &#x3D; service.doSomeStuff(1L, &quot;secondParam&quot;, new AnyParam());</span><br></pre></td></tr></table></figure>
<p>客户端和服务端必须使用一样的共享接口，生成两者的Redisson实例必须采用相同的连接配置。客户端和服务端实例可以运行在同一个JVM里，也可以是不同的。客户端和服务端的数量不收限制。（注意：尽管Redisson不做任何限制，但是Redis的限制仍然有效。）</p>
<p>在服务端工作者可用实例数量 大于1 的时候，将并行执行并发调用的远程方法。</p>
<p>并行执行工作者数量计算方法如下： T = R * N</p>
<p>T - 并行执行工作者总数 R - Redisson服务端数量 N - 注册服务端时指定的执行工作者数量</p>
<p>超过该数量的并发请求将在列队中等候执行。</p>
<p>在服务端工作者实例可用数量为 1 时，远程过程调用将会按 顺序执行。这种情况下，每次只有一个请求将会被执行，其他请求将在列队中等候执行。</p>
<h3 id="分布式远程服务工作流程"><a href="#分布式远程服务工作流程" class="headerlink" title="分布式远程服务工作流程"></a>分布式远程服务工作流程</h3><p>分布式远程服务为每个注册接口建立了两个列队。一个列队用于请求，由服务端监听，另一个列队用于应答回执和结果回复，由客户端监听。应答回执用于判定该请求是否已经被接受。如果在指定的超时时间内没有被执行工作者执行将会抛出RemoteServiceAckTimeoutException错误。</p>
<p>下图描述了每次发起远程过程调用请求的工作流程。</p>
<p><img src="https://img.huyunshun.com/img/20200423150409.png" alt="20200423150409"></p>
<h3 id="发送即不管（Fire-and-Forget）模式和应答回执（Ack-Response）模式"><a href="#发送即不管（Fire-and-Forget）模式和应答回执（Ack-Response）模式" class="headerlink" title="发送即不管（Fire-and-Forget）模式和应答回执（Ack-Response）模式"></a>发送即不管（Fire-and-Forget）模式和应答回执（Ack-Response）模式</h3><p>分布式远程服务通过org.redisson.core.RemoteInvocationOptions类，为每个远程过程调用提供了一些可配置选项。这些选项可以用来指定和修改请求超时和选择跳过应答回执或结果的发送模式。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 应答回执超时1秒钟，远程执行超时30秒钟</span><br><span class="line">RemoteInvocationOptions options &#x3D; RemoteInvocationOptions.defaults();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 无需应答回执，远程执行超时30秒钟</span><br><span class="line">RemoteInvocationOptions options &#x3D; RemoteInvocationOptions.defaults().noAck();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应答回执超时1秒钟，不等待执行结果</span><br><span class="line">RemoteInvocationOptions options &#x3D; RemoteInvocationOptions.defaults().noResult();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应答回执超时1分钟，不等待执行结果</span><br><span class="line">RemoteInvocationOptions options &#x3D; RemoteInvocationOptions.defaults().expectAckWithin(1, TimeUnit.MINUTES).noResult();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发送即不管（Fire-and-Forget）模式，无需应答回执，不等待结果</span><br><span class="line">RemoteInvocationOptions options &#x3D; RemoteInvocationOptions.defaults().noAck().noResult();</span><br><span class="line"></span><br><span class="line">RRemoteService remoteService &#x3D; redisson.getRemoteService();</span><br><span class="line">YourService service &#x3D; remoteService.get(YourService.class, options);</span><br></pre></td></tr></table></figure>

<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>远程过程调用也可以采用异步的方式执行。异步调用需要单独提交一个带有@RRemoteAsync注解（annotation）的异步接口类。异步接口方法签名必须与远程接口的方法签名相符。异步接口的返回类必须是org.redisson.api.RFuture对象或其子对象。在调用RRemoteService.get方法时将对异步接口的方法进行验证。异步接口无须包含所有的远程接口里的方法，只需要包含要求异步执行的方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RemoteInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Long <span class="title">someMethod1</span><span class="params">(Long param1, String param2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someMethod2</span><span class="params">(MyObject param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyObject <span class="title">someMethod3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配远程接口的异步接口</span></span><br><span class="line"><span class="meta">@RRemoteAsync</span>(RemoteInterface<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RemoteInterfaceAsync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">RFuture&lt;Long&gt; <span class="title">someMethod1</span><span class="params">(Long param1, String param2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">RFuture&lt;Void&gt; <span class="title">someMethod2</span><span class="params">(MyObject param)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RRemoteService remoteService = redisson.getRemoteService();</span><br><span class="line">RemoteInterfaceAsync asyncService = remoteService.get(RemoteInterfaceAsync<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>** 取消异步调用 **<br>通过调用Future.cancel()方法可以非常方便的取消一个异步调用。分布式远程服务允许在三个阶段中任何一个阶段取消异步调用：</p>
<ul>
<li>远程调用请求在列队中排队阶段</li>
<li>远程调用请求已经被分布式远程服务接受，还未发送应答回执，执行尚未开始。</li>
<li>远程调用请求已经在执行阶段</li>
<li>想要正确的处理第三个阶段，在服务端代码里应该检查Thread.currentThread().isInterrupted()的返回状态。范例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 远程接口</span><br><span class="line">public interface MyRemoteInterface &#123;</span><br><span class="line"></span><br><span class="line">    Long myBusyMethod(Long param1, String param2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配远程接口的异步接口</span><br><span class="line">@RRemoteAsync(MyRemoteInterface.class)</span><br><span class="line">public interface MyRemoteInterfaceAsync &#123;</span><br><span class="line"></span><br><span class="line">    RFuture&lt;Long&gt; myBusyMethod(Long param1, String param2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 远程接口的实现</span><br><span class="line">public class MyRemoteServiceImpl implements MyRemoteInterface &#123;</span><br><span class="line"></span><br><span class="line">   public Long myBusyMethod(Long param1, String param2) &#123;</span><br><span class="line">       for (long i &#x3D; 0; i &lt; Long.MAX_VALUE; i++) &#123;</span><br><span class="line">           iterations.incrementAndGet();</span><br><span class="line">           if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(&quot;interrupted! &quot; + i);</span><br><span class="line">                return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RRemoteService remoteService &#x3D; redisson.getRemoteService();</span><br><span class="line">ExecutorService executor &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line">&#x2F;&#x2F; 注册远程服务的服务端的同时，通过单独指定的ExecutorService来配置执行线程池</span><br><span class="line">MyRemoteInterface serviceImpl &#x3D; new MyRemoteServiceImpl();</span><br><span class="line">remoteService.register(MyRemoteInterface.class, serviceImpl, 5, executor);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步调用方法</span><br><span class="line">MyRemoteInterfaceAsync asyncService &#x3D; remoteService.get(MyRemoteInterfaceAsync.class);</span><br><span class="line">RFuture&lt;Long&gt; future &#x3D; asyncService.myBusyMethod(1L, &quot;someparam&quot;);</span><br><span class="line">&#x2F;&#x2F; 取消异步调用</span><br><span class="line">future.cancel(true);</span><br></pre></td></tr></table></figure>
<h2 id="2、分布式实时对象（Live-Object）服务"><a href="#2、分布式实时对象（Live-Object）服务" class="headerlink" title="2、分布式实时对象（Live Object）服务"></a>2、分布式实时对象（Live Object）服务</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3>分布式实时对象（Live Object） 可以被理解为一个功能强化后的Java对象。该对象不仅可以被一个JVM里的各个线程相引用，还可以被多个位于不同JVM里的线程同时引用。</li>
</ul>
<p>Redisson分布式实时对象（Redisson Live Object，简称RLO）运用即时生成的代理类（Proxy），将一个指定的普通Java类里的所有字段，以及针对这些字段的操作全部映射到一个Redis Hash的数据结构，实现这种理念。每个字段的get和set方法最终被转译为针对同一个Redis Hash的hget和hset命令，从而使所有连接到同一个Redis节点的所有可以客户端同时对一个指定的对象进行操作。众所周知，一个对象的状态是由其内部的字段所赋的值来体现的，通过将这些值保存在一个像Redis这样的远程共享的空间的过程，把这个对象强化成了一个分布式对象。这个分布式对象就叫做Redisson分布式实时对象（Redisson Live Object，简称RLO）。</p>
<p>通过使用RLO，运行在不同服务器里的多个程序之间，共享一个对象实例变得和在单机程序里共享一个对象实例一样了。同时还避免了针对任何一个字段操作都需要将整个对象序列化和反序列化的繁琐，进而降低了程序开发的复杂性和其数据模型的复杂性：从任何一个客户端修改一个字段的值，处在其他服务器上的客户端即刻便能查看到。而且实现代码与单机程序代码无异。（连接到从节点的客户端仍然受Redis的最终一致性的特性限制）</p>
<p>鉴于Redis是一个单线程的程序，针对实时对象的所有的字段操作可以理解为全部是原子性操作，也就是说在读取一个字段的过程不会担心被其他线程所修改。</p>
<p>通过使用RLO，可以把Redis当作一个允许被多个JVM同时操作且不受GC影响的共享堆（Heap Space）。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>Redisson为分布式实时对象提供了一系列不同功能的注解，其中@REntity和@RId两个注解是分布式实时对象的必要条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@REntity</span><br><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    @RId</span><br><span class="line">    private String id;</span><br><span class="line">    @RIndex</span><br><span class="line">    private String value;</span><br><span class="line">    private MyObject parent;</span><br><span class="line"></span><br><span class="line">    public MyObject(String id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyObject() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; getters and setters</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开始使用分布式实时对象以前，需要先通过Redisson服务将指定的对象连接（attach），合并（merge）或持久化（persist）到Redis里。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RLiveObjectService service = redisson.getLiveObjectService();</span><br><span class="line">MyLiveObject myObject = <span class="keyword">new</span> MyLiveObject();</span><br><span class="line">myObject.setId(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// 将myObject对象当前的状态持久化到Redis里并与之保持同步。</span></span><br><span class="line">myObject = service.persist(myObject);</span><br><span class="line"></span><br><span class="line">MyLiveObject myObject = <span class="keyword">new</span> MyLiveObject(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// 抛弃myObject对象当前的状态，并与Redis里的数据建立连接并保持同步。</span></span><br><span class="line">myObject = service.attach(myObject);</span><br><span class="line"></span><br><span class="line">MyLiveObject myObject = <span class="keyword">new</span> MyLiveObject();</span><br><span class="line">myObject.setId(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// 将myObject对象当前的状态与Redis里的数据合并之后与之保持同步。</span></span><br><span class="line">myObject = service.merge(myObject);</span><br><span class="line">myObject.setValue(<span class="string">"somevalue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ID获取分布式实时对象</span></span><br><span class="line">MyLiveObject myObject = service.get(MyLiveObject.class, "1");</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过索引查找分布式实时对象</span></span><br><span class="line">Collection&lt;MyLiveObject&gt; myObjects = service.find(MyLiveObject.class, Conditions.in("value", "somevalue", "somevalue2"));</span><br><span class="line"></span><br><span class="line">Collection&lt;MyLiveObject&gt; myObjects = service.find(MyLiveObject.class, Conditions.and(Conditions.in("value", "somevalue", "somevalue2"), Conditions.eq("secondfield", "test")));</span><br></pre></td></tr></table></figure>
<p>“parent”字段中包含了指向到另一个分布式实时对象的引用，它可以与包含类是同一类型也可以不同。Redisson内部采用了与Java的引用类似的方式保存这个关系，而非将全部对象序列化，可视为与普通的引用同等效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;RLO对象:</span><br><span class="line">MyObject myObject &#x3D; service.get(MyObject.class, &quot;1&quot;);</span><br><span class="line">MyObject myParentObject &#x3D; service.get(MyObject.class, &quot;2&quot;);</span><br><span class="line">myObject.setValue(myParentObject);</span><br></pre></td></tr></table></figure>
<p>RLO的字段类型基本上无限制，可以是任何类型。比如Java util包里的集合类，Map类等，也可以是自定义的对象。只要指定的编码解码器能够对其进行编码和解码操作便可。</p>
<p>尽管RLO的字段类型基本上无限制，个别类型还是受限。注解了RId的字段类型不能是数组类（Array），比如int[]，long[]，double[]，byte[]等等。</p>
<p>为了保证RLO的用法和普通Java对象的用法尽可能一直，Redisson分布式实时对象服务自动将以下普通Java对象转换成与之匹配的Redisson分布式对象RObject。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">普通Java类	转换后的Redisson类</span><br><span class="line">SortedSet.class	RedissonSortedSet.class</span><br><span class="line">Set.class	RedissonSet.class</span><br><span class="line">ConcurrentMap.class	RedissonMap.class</span><br><span class="line">Map.class	RedissonMap.class</span><br><span class="line">BlockingDeque.class	RedissonBlockingDeque.class</span><br><span class="line">Deque.class	RedissonDeque.class</span><br><span class="line">BlockingQueue.class	RedissonBlockingQueue.class</span><br><span class="line">Queue.class	RedissonQueue.class</span><br><span class="line">List.class	RedissonList.class</span><br></pre></td></tr></table></figure>
<p>类型转换将按照从上至下的顺序匹配类型，例如LinkedList类同时实现了Deque，List和Queue，由于Deque排在靠上的位置，因此它将会被转换成一个RedissonDeque类型。</p>
<p>Redisson的分布式对象也采用类似的方式，将自身的状态储存于Redis当中，（几乎^）所有的状态改变都直接映射到Redis里，不在本地JVM中保留任何赋值。（^本地缓存对象除外，比如RLocalCachedMap）</p>
<h3 id="高级使用方法"><a href="#高级使用方法" class="headerlink" title="高级使用方法"></a>高级使用方法</h3><p>正如上述介绍，RLO类其实都是按需实时生成的代理（Proxy）类。生成的代理类和原类都一同缓存Redisson实例里。这个过程会消耗一些时间，在对耗时比较敏感的情况下，建议通过RedissonLiveObjectService提前注册所有的RLO类。这个服务也可以用来注销不再需要的RLO类，也可以用来查询一个类是否已经注册了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLiveObjectService service &#x3D; redisson.getLiveObjectService();</span><br><span class="line">service.registerClass(MyClass.class);</span><br><span class="line">service.unregisterClass(MyClass.class);</span><br><span class="line">Boolean registered &#x3D; service.isClassRegistered(MyClass.class);</span><br></pre></td></tr></table></figure>
<h3 id="注解（Annotation）使用方法"><a href="#注解（Annotation）使用方法" class="headerlink" title="注解（Annotation）使用方法"></a>注解（Annotation）使用方法</h3><p>@REntity </p>
<p>仅适用于类。通过指定@REntity的各个参数，可以详细的对每个RLO类实现特殊定制，以达到改变RLO对象的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namingScheme - 命名方案。命名方案规定了每个实例在Redis中对应key的名称。它不仅被用来与已存在的RLO建立关联，还被用来储存新建的RLO实例。默认采用Redisson自带的DefaultNamingScheme对象。</span><br><span class="line">codec - 编码解码器。在运行当中，Redisson用编码解码器来对RLO中的每个字段进行编码解码。Redisson内部采用了实例池管理不同类型的编码解码器实例。Redisson提供了多种不同的编码解码器，默认使用JsonJacksonCodec。</span><br><span class="line">fieldTransformation - 字段转换模式。如上所述，为了尽可能的保证RLO的用法和普通Java对象一致，Redisson会自动将常用的普通Java对象转换成与其匹配的Redisson分布式对象。这是由于字段转换模式的默认值是ANNOTATION_BASED，修改为IMPLEMENTATION_BASED就可以不转换。</span><br></pre></td></tr></table></figure>
<p>@RId</p>
<p>仅适用于字段。@RId注解只能用在具备区分实例的字段上，这类字段可以理解为一个类的id字段或主键字段。这个字段的值将被命名方案namingScheme用来与事先存在的RLO建立引用。加了该注解的字段是唯一在本地JVM里同时保存赋值的字段。一个类只能有一个字段包含@RId注解。</p>
<p>可以通过指定一个生成器generator策略来实现自动生成这个字段的值。默认不提供生成器。</p>
<p>@RIndex</p>
<p>仅适用于字段。用来指定可用于搜索的字段。可以通过RLiveObjectService.find方法来根据条件精细查找分布式实时对象。查询条件可以是含（IN），或（OR），和（AND）或相等（EQ）以及它们的任意组合。</p>
<p>使用范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyObject &#123;</span><br><span class="line">    @RIndex</span><br><span class="line">    String field1;</span><br><span class="line">    @RIndex</span><br><span class="line">    String field2;</span><br><span class="line">    @RIndex</span><br><span class="line">    String field3;</span><br><span class="line">&#125;</span><br><span class="line">Collection&lt;MyObject&gt; objects &#x3D; RLiveObjectService.find(MyObject.class, Conditions.or(Conditions.and(Conditions.eq(&quot;field1&quot;, &quot;value&quot;), Conditions.eq(&quot;field2&quot;, &quot;value&quot;)), Conditions.in(&quot;field3&quot;, &quot;value1&quot;, &quot;value2&quot;));</span><br></pre></td></tr></table></figure>
<p>@RObjectField</p>
<p>仅适用于字段。允许通过该注解中的namingScheme或codec来改变该字段的命名或编码方式，用来区别于@REntity中指定的预设方式。</p>
<p>@RCascade</p>
<p>仅适用于字段。用来指定包含于分布式实时对象字段内其它对象的级联操作方式。</p>
<p>可选的级联操作方式为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCascadeType.ALL - 执行所有级联操作</span><br><span class="line">RCascadeType.PERSIST - 仅在执行RLiveObjectService.persist()方法时进行级联操作 RCascadeType.DETACH - 仅在执行RLiveObjectService.detach()方法时进行级联操作 RCascadeType.MERGE - 仅在执行RLiveObjectService.merge()方法时进行级联操作 RCascadeType.DELETE - 仅在执行RLiveObjectService.delete()方法时进行级联操作</span><br></pre></td></tr></table></figure>
<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>如上所述，带有RId注解字段的类型不能使数组类，这是因为目前默认的命名方案类DefaultNamingScheme还不能正确地将数组类序列化和反序列化。在改善了DefaultNamingScheme类的不足以后会考虑取消这个限制。另外由于带有RId注解的字段是用来指定Redis中映射的key的名称，因此组建一个只含有唯一一个字段的RLO类是毫无意义的。选用RBucket会更适合这样的场景。</p>
<h2 id="3、分布式执行服务（Executor-Service）"><a href="#3、分布式执行服务（Executor-Service）" class="headerlink" title="3、分布式执行服务（Executor Service）"></a>3、分布式执行服务（Executor Service）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Redisson的分布式执行服务实现了java.util.concurrent.ExecutorService接口，支持在不同的独立节点里执行基于java.util.concurrent.Callable接口或java.lang.Runnable接口或Lambda的任务。这样的任务也可以通过使用Redisson实例，实现对储存在Redis里的数据进行操作。Redisson分布式执行服务是最快速和有效执行分布式运算的方法。</p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>Redisson独立节点不要求任务的类在类路径里。他们会自动被Redisson独立节点的ClassLoader加载。因此每次执行一个新任务时，不需要重启Redisson独立节点。</p>
<p>采用Callable任务的范例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RInject</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RMap&lt;String, Integer&gt; map = redissonClient.getMap(<span class="string">"myMap"</span>);</span><br><span class="line">        Long result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">            result += value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用Runnable任务的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @RInject</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    private long param;</span><br><span class="line"></span><br><span class="line">    public RunnableTask() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RunnableTask(long param) &#123;</span><br><span class="line">        this.param &#x3D; param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        RAtomicLong atomic &#x3D; redissonClient.getAtomicLong(&quot;myAtomic&quot;);</span><br><span class="line">        atomic.addAndGet(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建ExecutorService时可以配置以下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorOptions options &#x3D; ExecutorOptions.defaults()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定重新尝试执行任务的时间间隔。</span><br><span class="line">&#x2F;&#x2F; ExecutorService的工作节点将等待10分钟后重新尝试执行任务</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 设定为0则不进行重试</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 默认值为5分钟</span><br><span class="line">options.taskRetryInterval(10, TimeUnit.MINUTES);</span><br><span class="line">RExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;, options);</span><br><span class="line">executorService.submit(new RunnableTask(123));</span><br><span class="line"></span><br><span class="line">RExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;, options);</span><br><span class="line">Future&lt;Long&gt; future &#x3D; executorService.submit(new CallableTask());</span><br><span class="line">Long result &#x3D; future.get();</span><br></pre></td></tr></table></figure>
<p>使用Lambda任务的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;, options);</span><br><span class="line">Future&lt;Long&gt; future &#x3D; executorService.submit((Callable &amp; Serializable)() -&gt; &#123;</span><br><span class="line">      System.out.println(&quot;task has been executed!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">Long result &#x3D; future.get();</span><br></pre></td></tr></table></figure>
<p>可以通过@RInject注解来为任务实时注入Redisson实例依赖。</p>
<h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><p>通过Future.cancel()方法可以很方便的取消所有已提交的任务。通过对Thread.currentThread().isInterrupted()方法的调用可以在已经处于运行状态的任务里实现任务中断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class CallableTask implements Callable&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @RInject</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Long call() throws Exception &#123;</span><br><span class="line">        RMap&lt;String, Integer&gt; map &#x3D; redissonClient.getMap(&quot;myMap&quot;);</span><br><span class="line">        Long result &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; map里包含了许多的元素</span><br><span class="line">        for (Integer value : map.values()) &#123;</span><br><span class="line">           if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 任务被取消了</span><br><span class="line">                return null;</span><br><span class="line">           &#125;</span><br><span class="line">           result +&#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;);</span><br><span class="line">Future&lt;Long&gt; future &#x3D; executorService.submit(new CallableTask());</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RFuture&lt;Long&gt; future &#x3D; executorService.submitAsync(new CallableTask());</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">future.cancel(true);</span><br></pre></td></tr></table></figure>
<h2 id="4、分布式调度任务服务（Scheduler-Service）"><a href="#4、分布式调度任务服务（Scheduler-Service）" class="headerlink" title="4、分布式调度任务服务（Scheduler Service）"></a>4、分布式调度任务服务（Scheduler Service）</h2><h3 id="分布式调度任务服务概述"><a href="#分布式调度任务服务概述" class="headerlink" title="分布式调度任务服务概述"></a>分布式调度任务服务概述</h3><p>Redisson的分布式调度任务服务实现了java.util.concurrent.ScheduledExecutorService接口，支持在不同的独立节点里执行基于java.util.concurrent.Callable接口或java.lang.Runnable接口的任务。Redisson独立节点按顺序运行Redis列队里的任务。调度任务是一种需要在未来某个指定时间运行一次或多次的特殊任务。</p>
<h3 id="设定任务计划"><a href="#设定任务计划" class="headerlink" title="设定任务计划"></a>设定任务计划</h3><p>Redisson独立节点不要求任务的类在类路径里。他们会自动被Redisson独立节点的ClassLoader加载。因此每次执行一个新任务时，不需要重启Redisson独立节点。</p>
<p>采用Callable任务的范例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RInject</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RMap&lt;String, Integer&gt; map = redissonClient.getMap(<span class="string">"myMap"</span>);</span><br><span class="line">        Long result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">            result += value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建ExecutorService时可以配置以下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorOptions options &#x3D; ExecutorOptions.defaults()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定重新尝试执行任务的时间间隔。</span><br><span class="line">&#x2F;&#x2F; ExecutorService的工作节点将等待10分钟后重新尝试执行任务</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 设定为0则不进行重试</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 默认值为5分钟</span><br><span class="line">options.taskRetryInterval(10, TimeUnit.MINUTES);</span><br><span class="line">RScheduledExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;);</span><br><span class="line">ScheduledFuture&lt;Long&gt; future &#x3D; executorService.schedule(new CallableTask(), 10, TimeUnit.MINUTES);</span><br><span class="line">Long result &#x3D; future.get();</span><br></pre></td></tr></table></figure>
<p>使用Lambda任务的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;, options);</span><br><span class="line">ScheduledFuture&lt;Long&gt; future &#x3D; executorService.schedule((Callable &amp; Serializable)() -&gt; &#123;</span><br><span class="line">      System.out.println(&quot;task has been executed!&quot;);</span><br><span class="line">&#125;, 10, TimeUnit.MINUTES);</span><br><span class="line">Long result &#x3D; future.get();</span><br></pre></td></tr></table></figure>
<p>采用Runnable任务的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @RInject</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    private long param;</span><br><span class="line"></span><br><span class="line">    public RunnableTask() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RunnableTask(long param) &#123;</span><br><span class="line">        this.param&#x3D; param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        RAtomicLong atomic &#x3D; redissonClient.getAtomicLong(&quot;myAtomic&quot;);</span><br><span class="line">        atomic.addAndGet(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RScheduledExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;);</span><br><span class="line">ScheduledFuture&lt;?&gt; future1 &#x3D; executorService.schedule(new RunnableTask(123), 10, TimeUnit.HOURS);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">ScheduledFuture&lt;?&gt; future2 &#x3D; executorService.scheduleAtFixedRate(new RunnableTask(123), 10, 25, TimeUnit.HOURS);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">ScheduledFuture&lt;?&gt; future3 &#x3D; executorService.scheduleWithFixedDelay(new RunnableTask(123), 5, 10, TimeUnit.HOURS);</span><br></pre></td></tr></table></figure>
<h3 id="通过CRON表达式设定任务计划"><a href="#通过CRON表达式设定任务计划" class="headerlink" title="通过CRON表达式设定任务计划"></a>通过CRON表达式设定任务计划</h3><p>在分布式调度任务中，可以通过CRON表达式来为任务设定一个更复杂的计划。表达式与Quartz的CRON格式完全兼容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RScheduledExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;);</span><br><span class="line">executorService.schedule(new RunnableTask(), CronSchedule.of(&quot;10 0&#x2F;5 * * * ?&quot;));</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">executorService.schedule(new RunnableTask(), CronSchedule.dailyAtHourAndMinute(10, 5));</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">executorService.schedule(new RunnableTask(), CronSchedule.weeklyOnDayAndHourAndMinute(12, 4, Calendar.MONDAY, Calendar.FRIDAY));</span><br></pre></td></tr></table></figure>
<h3 id="取消计划任务"><a href="#取消计划任务" class="headerlink" title="取消计划任务"></a>取消计划任务</h3><p>分布式调度任务服务提供了两张取消任务的方式：通过调用ScheduledFuture.cancel()方法或调用RScheduledExecutorService.cancelScheduledTask方法。通过对Thread.currentThread().isInterrupted()方法的调用可以在已经处于运行状态的任务里实现任务中断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableTask implements Callable&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @RInject</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Long call() throws Exception &#123;</span><br><span class="line">        RMap&lt;String, Integer&gt; map &#x3D; redissonClient.getMap(&quot;myMap&quot;);</span><br><span class="line">        Long result &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; map里包含了许多的元素</span><br><span class="line">        for (Integer value : map.values()) &#123;</span><br><span class="line">           if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 任务被取消了</span><br><span class="line">                return null;</span><br><span class="line">           &#125;</span><br><span class="line">           result +&#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RScheduledExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;);</span><br><span class="line">RScheduledFuture&lt;Long&gt; future &#x3D; executorService.scheduleAsync(new RunnableTask(), CronSchedule.dailyAtHourAndMinute(10, 5));</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">future.cancel(true);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">String taskId &#x3D; future.getTaskId();</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">executorService.cancelScheduledTask(taskId);</span><br></pre></td></tr></table></figure>
<h2 id="5、分布式映射归纳服务（MapReduce）"><a href="#5、分布式映射归纳服务（MapReduce）" class="headerlink" title="5、分布式映射归纳服务（MapReduce）"></a>5、分布式映射归纳服务（MapReduce）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Redisson提供了通过映射归纳（MapReduce）编程模式来处理储存在Redis环境里的大量数据的服务。这个想法来至于其他的类似实现方式和谷歌发表的研究。所有 映射（Map） 和 归纳（Reduce） 阶段中的任务都是被分配到各个独立节点（Redisson Node）里并行执行的。以下所有接口均支持映射归纳（MapReduce）功能： RMap、 RMapCache、 RLocalCachedMap、 RSet、 RSetCache、 RList、 RSortedSet、 RScoredSortedSet、 RQueue、 RBlockingQueue、 RDeque、 RBlockingDeque、 RPriorityQueue 和 RPriorityDeque</p>
<p>映射归纳（MapReduce）的功能是通过RMapper、 RCollectionMapper、 RReducer 和 RCollator 这几个接口实现的。</p>
<ol>
<li>RMapper 映射器接口适用于映射（Map）类，它用来把映射（Map）中的每个元素转换为另一个作为归纳（Reduce）处理用的键值对。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RMapper&lt;KIn, VIn, KOut, VOut&gt; extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    void map(KIn key, VIn value, RCollector&lt;KOut, VOut&gt; collector);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>RCollectionMapper 映射器接口仅适用于集合（Collection）类型的对象，它用来把集合（Collection）中的元素转换成一组作为归纳（Reduce）处理用的键值对。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RCollectionMapper&lt;VIn, KOut, VOut&gt; extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    void map(VIn value, RCollector&lt;KOut, VOut&gt; collector);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>RReducer 归纳器接口用来将上面这些，由映射器生成的键值对列表进行归纳整理。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RReducer&lt;K, V&gt; extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    V reduce(K reducedKey, Iterator&lt;V&gt; values);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>RCollator 收集器接口用来把归纳整理以后的结果化简为单一一个对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RCollator&lt;K, V, R&gt; extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    R collate(Map&lt;K, V&gt; resultMap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上每个阶段的任务都可以用@RInject注解的方式来获取RedissonClient实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class WordMapper implements RMapper&lt;String, String, String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @RInject</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void map(String key, String value, RCollector&lt;String, Integer&gt; collector) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">        redissonClient.getAtomicLong(&quot;mapInvocations&quot;).incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="映射（Map）类型的使用范例"><a href="#映射（Map）类型的使用范例" class="headerlink" title="映射（Map）类型的使用范例"></a>映射（Map）类型的使用范例</h3>Redisson提供的RMap、 RMapCache和RLocalCachedMap这三种映射（Map）类型的对象均可以使用这种分布式映射归纳（MapReduce）服务。</li>
</ol>
<p>以下是在映射（Map）类型的基础上采用映射归纳（MapReduce）来实现字数统计的范例：</p>
<p>Mapper对象将每个映射的值用空格且分开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WordMapper implements RMapper&lt;String, String, String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void map(String key, String value, RCollector&lt;String, Integer&gt; collector) &#123;</span><br><span class="line">        String[] words &#x3D; value.split(&quot;[^a-zA-Z]&quot;);</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            collector.emit(word, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reducer对象计算统计所有单词的使用情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WordReducer implements RReducer&lt;String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer reduce(String reducedKey, Iterator&lt;Integer&gt; iter) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        while (iter.hasNext()) &#123;</span><br><span class="line">           Integer i &#x3D; (Integer) iter.next();</span><br><span class="line">           sum +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Collator对象统计所有单词的使用情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WordCollator implements RCollator&lt;String, Integer, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer collate(Map&lt;String, Integer&gt; resultMap) &#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        for (Integer count : resultMap.values()) &#123;</span><br><span class="line">            result +&#x3D; count;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把上面的各个对象串起来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RMap&lt;String, String&gt; map &#x3D; redisson.getMap(&quot;wordsMap&quot;);</span><br><span class="line">map.put(&quot;line1&quot;, &quot;Alice was beginning to get very tired&quot;);</span><br><span class="line">map.put(&quot;line2&quot;, &quot;of sitting by her sister on the bank and&quot;);</span><br><span class="line">map.put(&quot;line3&quot;, &quot;of having nothing to do once or twice she&quot;);</span><br><span class="line">map.put(&quot;line4&quot;, &quot;had peeped into the book her sister was reading&quot;);</span><br><span class="line">map.put(&quot;line5&quot;, &quot;but it had no pictures or conversations in it&quot;);</span><br><span class="line">map.put(&quot;line6&quot;, &quot;and what is the use of a book&quot;);</span><br><span class="line">map.put(&quot;line7&quot;, &quot;thought Alice without pictures or conversation&quot;);</span><br><span class="line"></span><br><span class="line">RMapReduce&lt;String, String, String, Integer&gt; mapReduce</span><br><span class="line">         &#x3D; map.&lt;String, Integer&gt;mapReduce()</span><br><span class="line">              .mapper(new WordMapper())</span><br><span class="line">              .reducer(new WordReducer());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计词频</span><br><span class="line">Map&lt;String, Integer&gt; mapToNumber &#x3D; mapReduce.execute();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计字数</span><br><span class="line">Integer totalWordsAmount &#x3D; mapReduce.execute(new WordCollator());</span><br></pre></td></tr></table></figure>
<h3 id="集合（Collection）类型的使用范例"><a href="#集合（Collection）类型的使用范例" class="headerlink" title="集合（Collection）类型的使用范例"></a>集合（Collection）类型的使用范例</h3><p>Redisson提供的RSet、 RSetCache、 RList、 RSortedSet、 RScoredSortedSet、 RQueue、 RBlockingQueue、 RDeque、 RBlockingDeque、 RPriorityQueue和RPriorityDeque这几种集合（Collection）类型的对象均可以使用这种分布式映射归纳（MapReduce）服务。</p>
<p>以下是在集合（Collection）类型的基础上采用映射归纳（MapReduce）来实现字数统计的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class WordMapper implements RCollectionMapper&lt;String, String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void map(String value, RCollector&lt;String, Integer&gt; collector) &#123;</span><br><span class="line">        String[] words &#x3D; value.split(&quot;[^a-zA-Z]&quot;);</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            collector.emit(word, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class WordReducer implements RReducer&lt;String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer reduce(String reducedKey, Iterator&lt;Integer&gt; iter) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        while (iter.hasNext()) &#123;</span><br><span class="line">           Integer i &#x3D; (Integer) iter.next();</span><br><span class="line">           sum +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class WordCollator implements RCollator&lt;String, Integer, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer collate(Map&lt;String, Integer&gt; resultMap) &#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        for (Integer count : resultMap.values()) &#123;</span><br><span class="line">            result +&#x3D; count;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">RList&lt;String&gt; list &#x3D; redisson.getList(&quot;myList&quot;);</span><br><span class="line">list.add(&quot;Alice was beginning to get very tired&quot;);</span><br><span class="line">list.add(&quot;of sitting by her sister on the bank and&quot;);</span><br><span class="line">list.add(&quot;of having nothing to do once or twice she&quot;);</span><br><span class="line">list.add(&quot;had peeped into the book her sister was reading&quot;);</span><br><span class="line">list.add(&quot;but it had no pictures or conversations in it&quot;);</span><br><span class="line">list.add(&quot;and what is the use of a book&quot;);</span><br><span class="line">list.add(&quot;thought Alice without pictures or conversation&quot;);</span><br><span class="line"></span><br><span class="line">RCollectionMapReduce&lt;String, String, Integer&gt; mapReduce</span><br><span class="line">         &#x3D; list.&lt;String, Integer&gt;mapReduce()</span><br><span class="line">               .mapper(new WordMapper())</span><br><span class="line">               .reducer(new WordReducer());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计词频</span><br><span class="line">Map&lt;String, Integer&gt; mapToNumber &#x3D; mapReduce.execute();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计字数</span><br><span class="line">Integer totalWordsAmount &#x3D; mapReduce.execute(new WordCollator());</span><br></pre></td></tr></table></figure>
<h1 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a>八、其他</h1><h2 id="1、对Redis节点的操作"><a href="#1、对Redis节点的操作" class="headerlink" title="1、对Redis节点的操作"></a>1、对Redis节点的操作</h2><p>Redisson的NodesGroup对象提供了许些对Redis节点的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NodesGroup nodesGroup &#x3D; redisson.getNodesGroup();</span><br><span class="line">nodesGroup.addConnectionListener(new ConnectionListener() &#123;</span><br><span class="line">    public void onConnect(InetSocketAddress addr) &#123;</span><br><span class="line">       &#x2F;&#x2F; Redis节点连接成功</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onDisconnect(InetSocketAddress addr) &#123;</span><br><span class="line">       &#x2F;&#x2F; Redis节点连接断开</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">也可以用来PING单个Redis节点或全部节点。</span><br><span class="line"></span><br><span class="line">NodesGroup nodesGroup &#x3D; redisson.getNodesGroup();</span><br><span class="line">Collection&lt;Node&gt; allNodes &#x3D; nodesGroup.getNodes();</span><br><span class="line">for (Node n : allNodes) &#123;</span><br><span class="line">    n.ping();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">nodesGroup.pingAll();</span><br></pre></td></tr></table></figure>
<h2 id="2-复杂多维对象结构和对象引用的支持"><a href="#2-复杂多维对象结构和对象引用的支持" class="headerlink" title="2. 复杂多维对象结构和对象引用的支持"></a>2. 复杂多维对象结构和对象引用的支持</h2><p>Redisson突破了Redis数据结构维度的限制，通过一个特殊引用对象的帮助，Redisson允许以任意的组合方式构建多维度的复杂对象结构，实现了对象之间的类似传统数据库里的关联关系。使用范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RMap&lt;RSet&lt;RList&gt;, RList&lt;RMap&gt;&gt; map &#x3D; redisson.getMap(&quot;myMap&quot;);</span><br><span class="line">RSet&lt;RList&gt; set &#x3D; redisson.getSet(&quot;mySet&quot;);</span><br><span class="line">RList&lt;RMap&gt; list &#x3D; redisson.getList(&quot;myList&quot;);</span><br><span class="line"></span><br><span class="line">map.put(set, list);</span><br><span class="line">&#x2F;&#x2F; 在特殊引用对象的帮助下，我们甚至可以构建一个循环引用，这是通过普通序列化方式实现不了的。</span><br><span class="line">set.add(list);</span><br><span class="line">list.add(map);</span><br></pre></td></tr></table></figure>
<p>在map包含的元素发生改变以后，我们无需再次“保存/持久”这些对象。因为map对象所记录的并不是序列化以后的值，而是元素对象的引用。这让Redisson提供的对象在使用方法上，与普通Java对象的使用方法一致。从而让Redis成为内存的一部分，而不仅仅是一个储存空间。</p>
<p>以上范例中，一共创建了三个Redis数据结构：一个Redis HASH，一个Redis SET和一个Redis LIST。</p>
<h2 id="3-命令的批量执行"><a href="#3-命令的批量执行" class="headerlink" title="3. 命令的批量执行"></a>3. 命令的批量执行</h2><p>多个连续命令可以通过RBatch对象在一次网络会话请求里合并发送，这样省去了产生多个请求消耗的时间和资源。这在Redis中叫做管道。</p>
<p>用户可以通过以下方式调整通过管道方式发送命令的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">BatchOptions options &#x3D; BatchOptions.defaults()</span><br><span class="line">&#x2F;&#x2F; 指定执行模式</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; ExecutionMode.REDIS_READ_ATOMIC - 所有命令缓存在Redis节点中，以原子性事务的方式执行。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; ExecutionMode.REDIS_WRITE_ATOMIC - 所有命令缓存在Redis节点中，以原子性事务的方式执行。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; ExecutionMode.IN_MEMORY - 所有命令缓存在Redisson本机内存中统一发送，但逐一执行（非事务）。默认模式。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; ExecutionMode.IN_MEMORY_ATOMIC - 所有命令缓存在Redisson本机内存中统一发送，并以原子性事务的方式执行。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">.executionMode(ExecutionMode.IN_MEMORY)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 告知Redis不用返回结果（可以减少网络用量）</span><br><span class="line">.skipResult()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将写入操作同步到从节点</span><br><span class="line">&#x2F;&#x2F; 同步到2个从节点，等待时间为1秒钟</span><br><span class="line">.syncSlaves(2, 1, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理结果超时为2秒钟</span><br><span class="line">.responseTimeout(2, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命令重试等待间隔时间为2秒钟</span><br><span class="line">.retryInterval(2, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命令重试次数。仅适用于未发送成功的命令</span><br><span class="line">.retryAttempts(4);</span><br><span class="line">使用方式如下：</span><br><span class="line"></span><br><span class="line">RBatch batch &#x3D; redisson.createBatch();</span><br><span class="line">batch.getMap(&quot;test&quot;).fastPutAsync(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">batch.getMap(&quot;test&quot;).fastPutAsync(&quot;2&quot;, &quot;3&quot;);</span><br><span class="line">batch.getMap(&quot;test&quot;).putAsync(&quot;2&quot;, &quot;5&quot;);</span><br><span class="line">batch.getAtomicLongAsync(&quot;counter&quot;).incrementAndGetAsync();</span><br><span class="line">batch.getAtomicLongAsync(&quot;counter&quot;).incrementAndGetAsync();</span><br><span class="line"></span><br><span class="line">BatchResult res &#x3D; batch.execute();</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">Future&lt;BatchResult&gt; asyncRes &#x3D; batch.executeAsync();</span><br><span class="line">List&lt;?&gt; response &#x3D; res.getResponses();</span><br><span class="line">res.getSyncedSlaves();</span><br></pre></td></tr></table></figure>
<p>在集群模式下，所有的命令会按各个槽所在的节点，筛选分配到各个节点并同时发送。每个节点返回的结果将会汇总到最终的结果列表里。</p>
<h2 id="4-Redisson事务"><a href="#4-Redisson事务" class="headerlink" title="4. Redisson事务"></a>4. Redisson事务</h2><p>Redisson为RMap、RMapCache、RLocalCachedMap、RSet、RSetCache和RBucket这样的对象提供了具有ACID属性的事务功能。Redisson事务通过分布式锁保证了连续写入的原子性，同时在内部通过操作指令队列实现了Redis原本没有的提交与滚回功能。当提交与滚回遇到问题的时候，将通过org.redisson.transaction.TransactionException告知用户。</p>
<p>目前支持的环境如下： SINGLE, MASTER/SLAVE, SENTINEL, ELASTICACHE REPLICATED, AZURE CACHE, RLEC。</p>
<p>Redisson事务支持的事务隔离等级为: READ_COMMITTED，即仅读取提交后的结果。</p>
<p>另见 Spring事务管理器 和本章 XA事务（XA Transactions）。</p>
<p>以下选项可以用来配置事务属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">TransactionOptions options &#x3D; TransactionOptions.defaults()</span><br><span class="line">&#x2F;&#x2F; 设置参与本次事务的主节点与其从节点同步的超时时间。</span><br><span class="line">&#x2F;&#x2F; 默认值是5秒。</span><br><span class="line">.syncSlavesTimeout(5, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理结果超时。</span><br><span class="line">&#x2F;&#x2F; 默认值是3秒。</span><br><span class="line">.responseTimeout(3, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命令重试等待间隔时间。仅适用于未发送成功的命令。</span><br><span class="line">&#x2F;&#x2F; 默认值是1.5秒。</span><br><span class="line">.retryInterval(2, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命令重试次数。仅适用于未发送成功的命令。</span><br><span class="line">&#x2F;&#x2F; 默认值是3次。</span><br><span class="line">.retryAttempts(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事务超时时间。如果规定时间内没有提交该事务则自动滚回。</span><br><span class="line">&#x2F;&#x2F; 默认值是5秒。</span><br><span class="line">.timeout(5, TimeUnit.SECONDS);</span><br><span class="line">代码范例：</span><br><span class="line"></span><br><span class="line">RTransaction transaction &#x3D; redisson.createTransaction(TransactionOptions.defaults());</span><br><span class="line"></span><br><span class="line">RMap&lt;String, String&gt; map &#x3D; transaction.getMap(&quot;myMap&quot;);</span><br><span class="line">map.put(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">String value &#x3D; map.get(&quot;3&quot;);</span><br><span class="line">RSet&lt;String&gt; set &#x3D; transaction.getSet(&quot;mySet&quot;)</span><br><span class="line">set.add(value);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">   transaction.commit();</span><br><span class="line">&#125; catch(TransactionException e) &#123;</span><br><span class="line">   transaction.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-XA事务（XA-Transactions）"><a href="#5-XA事务（XA-Transactions）" class="headerlink" title="5. XA事务（XA Transactions）"></a>5. XA事务（XA Transactions）</h2><p>Redisson提供了XAResource标准的实现。该实现可用于JTA事务中。</p>
<p>另见本章Redisson事务和Spring事务管理器。</p>
<p>该功能仅适用于Redisson PRO版本</p>
<p>代码范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Transaction对象可以从所有兼容JTA接口的事务管理器中获取。</span><br><span class="line">Transaction globalTransaction &#x3D; transactionManager.getTransaction();</span><br><span class="line"></span><br><span class="line">RXAResource xaResource &#x3D; redisson.getXAResource();</span><br><span class="line">globalTransaction.enlistResource(xaResource);</span><br><span class="line"></span><br><span class="line">RTransaction transaction &#x3D; xaResource.getTransaction();</span><br><span class="line">RBucket&lt;String&gt; bucket &#x3D; transaction.getBucket(&quot;myBucket&quot;);</span><br><span class="line">bucket.set(&quot;simple&quot;);</span><br><span class="line">RMap&lt;String, String&gt; map &#x3D; transaction.getMap(&quot;myMap&quot;);</span><br><span class="line">map.put(&quot;myKey&quot;, &quot;myValue&quot;);</span><br><span class="line"></span><br><span class="line">transactionManager.commit();</span><br></pre></td></tr></table></figure>
<h2 id="6-脚本执行"><a href="#6-脚本执行" class="headerlink" title="6. 脚本执行"></a>6. 脚本执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">redisson.getBucket(&quot;foo&quot;).set(&quot;bar&quot;);</span><br><span class="line">String r &#x3D; redisson.getScript().eval(Mode.READ_ONLY,</span><br><span class="line">   &quot;return redis.call(&#39;get&#39;, &#39;foo&#39;)&quot;, RScript.ReturnType.VALUE);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过预存的脚本进行同样的操作</span><br><span class="line">RScript s &#x3D; redisson.getScript();</span><br><span class="line">&#x2F;&#x2F; 首先将脚本保存到所有的Redis主节点</span><br><span class="line">String res &#x3D; s.scriptLoad(&quot;return redis.call(&#39;get&#39;, &#39;foo&#39;)&quot;);</span><br><span class="line">&#x2F;&#x2F; 返回值 res &#x3D;&#x3D; 282297a0228f48cd3fc6a55de6316f31422f5d17</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 再通过SHA值调用脚本</span><br><span class="line">Future&lt;Object&gt; r1 &#x3D; redisson.getScript().evalShaAsync(Mode.READ_ONLY,</span><br><span class="line">   &quot;282297a0228f48cd3fc6a55de6316f31422f5d17&quot;,</span><br><span class="line">   RScript.ReturnType.VALUE, Collections.emptyList());</span><br><span class="line">10.7. 底层Redis客户端</span><br><span class="line">Redisson在底层采用了高性能异步非阻塞式Java客户端，它同时支持异步和同步两种通信模式。如果有哪些命令Redisson还没提供支持，也可以直接通过调用底层Redis客户端来实现。Redisson支持的命令在Redis命令和Redisson对象匹配列表里做了详细对比参照。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在使用多个客户端的情况下可以共享同一个EventLoopGroup</span><br><span class="line">EventLoopGroup group &#x3D; new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">RedisClientConfig config &#x3D; new RedisClientConfig();</span><br><span class="line">config.setAddress(&quot;redis:&#x2F;&#x2F;localhost:6379&quot;) &#x2F;&#x2F; 或者用rediss:&#x2F;&#x2F;使用加密连接</span><br><span class="line">      .setPassword(&quot;myPassword&quot;)</span><br><span class="line">      .setDatabase(0)</span><br><span class="line">      .setClientName(&quot;myClient&quot;)</span><br><span class="line">      .setGroup(group);</span><br><span class="line"></span><br><span class="line">RedisClient client &#x3D; RedisClient.create(config);</span><br><span class="line">RedisConnection conn &#x3D; client.connect();</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RFuture&lt;RedisConnection&gt; connFuture &#x3D; client.connectAsync();</span><br><span class="line"></span><br><span class="line">conn.sync(StringCodec.INSTANCE, RedisCommands.SET, &quot;test&quot;, 0);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">conn.async(StringCodec.INSTANCE, RedisCommands.GET, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">conn.closeAsync()</span><br><span class="line"></span><br><span class="line">client.shutdown();</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">client.shutdownAsync();</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2018/12/23/EhCache%E4%BB%8B%E7%BB%8D%E5%92%8C%E8%BF%90%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/EhCache%E4%BB%8B%E7%BB%8D%E5%92%8C%E8%BF%90%E7%94%A8/" itemprop="url">EhCache介绍和运用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T14:03:42+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/EhCache/" itemprop="url" rel="index">
                    <span itemprop="name">EhCache</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring-Boot-的缓存机制"><a href="#Spring-Boot-的缓存机制" class="headerlink" title="Spring Boot 的缓存机制"></a>Spring Boot 的缓存机制</h2><p>高速缓存抽象不提供实际存储，并且依赖于由org.springframework.cache.Cache和org.springframework.cache.CacheManager接口实现的抽象。 Spring Boot根据实现自动配置合适的CacheManager，只要缓存支持通过@EnableCaching注释启用即可。</p>
<h2 id="EhCache"><a href="#EhCache" class="headerlink" title="EhCache"></a>EhCache</h2><p>Ehcache是一个用Java实现的使用简单，高速，实现线程安全的缓存管理类库，ehcache提供了用内存，磁盘文件存储，以及分布式存储方式等多种灵活的cache管理方案。同时ehcache作为开放源代码项目，采用限制比较宽松的Apache License V2.0作为授权方式，被广泛地用于Hibernate, Spring，Cocoon等其他开源系统。Ehcache 从 Hibernate 发展而来，逐渐涵盖了 Cahce 界的全部功能,是目前发展势头最好的一个项目。具有快速,简单,低消耗，依赖性小，扩展性强,支持对象或序列化缓存，支持缓存或元素的失效，提供 LRU、LFU 和 FIFO 缓存策略，支持内存缓存和磁盘缓存，分布式缓存机制等等特点。</p>
<p><img src="https://img.huyunshun.com/img/20200423140459.png" alt="20200423140459"></p>
<pre><code>快速；简单；多种缓存策略；
缓存数据有两级：内存和磁盘，因此无需担心容量问题；
缓存数据会在虚拟机重启的过程中写入磁盘；
可以通过 RMI、可插入 API 等方式进行分布式缓存；
具有缓存和缓存管理器的侦听接口；
支持多缓存管理器实例，以及一个实例的多个缓存区域；
提供 Hibernate 的缓存实现；</code></pre><p>说明</p>
<pre><code>CacheManager：是缓存管理器，可以通过单例或者多例的方式创建，也是Ehcache的入口类。
Cache：每个CacheManager可以管理多个Cache，每个Cache可以采用hash的方式管理多个Element。
Element：用于存放真正缓存内容的。</code></pre><h2 id="Ehcache的缓存数据淘汰策略"><a href="#Ehcache的缓存数据淘汰策略" class="headerlink" title="Ehcache的缓存数据淘汰策略"></a>Ehcache的缓存数据淘汰策略</h2><pre><code>FIFO：先进先出
LFU：最少被使用，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
LRU：最近最少使用，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
Ehcache的缓存数据过期策略
Ehcache采用的是懒淘汰机制，每次往缓存放入数据的时候，都会存一个时间，在读取的时候要和设置的时间做TTL比较来判断是否过期。</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>这段代码介绍了Ehcache3，缓存使用生命周期的一个过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CacheManager cacheManager =</span><br><span class="line">        <span class="comment">// 静态方法CacheManagerBuilder.newCacheManagerBuilder将返回一个新的org.ehcache.config.builders.CacheManagerBuilder的实例。</span></span><br><span class="line">        CacheManagerBuilder.newCacheManagerBuilder()</span><br><span class="line">        .withCache(<span class="string">"preConfigured"</span>,</span><br><span class="line">                <span class="comment">// 当我们要构建一个缓存管理器的时候，使用CacheManagerBuilder来创建一个预配置（pre-configured)缓存。</span></span><br><span class="line">                <span class="comment">// 第一个参数是一个别名，用于Cache和Cachemanager进行配合。</span></span><br><span class="line">                <span class="comment">// 第二个参数是org.ehcache.config.CacheConfiguration主要用来配置Cache。</span></span><br><span class="line">                <span class="comment">// 我们使用org.ehcache.config.builders.CacheConfigurationBuilder的静态方法newCacheConfigurationBuilder来创建一个默认配置实例。</span></span><br><span class="line">                CacheConfigurationBuilder.newCacheConfigurationBuilder(Long<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">ResourcePoolsBuilder</span>.<span class="title">heap</span>(100))</span></span><br><span class="line"><span class="class">                        // 调用.<span class="title">build</span>方法返回一个完整的实例，也能使用<span class="title">CacheManager</span>来初始化。</span></span><br><span class="line"><span class="class">                        .<span class="title">build</span>())</span></span><br><span class="line"><span class="class">        //在你开始使用<span class="title">CacheManager</span>的时候，需要使用<span class="title">init</span>()方法进行初始化。</span></span><br><span class="line"><span class="class">        .<span class="title">build</span>(<span class="title">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">Cache&lt;Long, String&gt; preConfigured</span><br><span class="line">        <span class="comment">//取回前面中设定的pre-configured别名，我们对于key和要传递的值类型，要求是类型安全的，否则将抛出ClassCastException异常。</span></span><br><span class="line">        = cacheManager.getCache(<span class="string">"preConfigured"</span>, Long<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="comment">//通过CacheManager创建出新的Cache。实例化和完整实例化的Cache将通过CacheManager.getCache API返回。</span></span><br><span class="line">Cache&lt;Long, String&gt; myCache = cacheManager.createCache(<span class="string">"myCache"</span>,</span><br><span class="line">        CacheConfigurationBuilder.newCacheConfigurationBuilder(Long<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">ResourcePoolsBuilder</span>.<span class="title">heap</span>(100)).<span class="title">build</span>())</span>;</span><br><span class="line"><span class="comment">//使用put方法存储数据。</span></span><br><span class="line">myCache.put(<span class="number">1L</span>, <span class="string">"da one!"</span>);</span><br><span class="line"><span class="comment">//使用get方法获取数据。</span></span><br><span class="line">String value = myCache.get(<span class="number">1L</span>);</span><br><span class="line"><span class="comment">//close方法将释放CacheManager所管理的缓存资源。</span></span><br><span class="line">cacheManager.close();</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启 cache 缓存--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- ehcache 缓存 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="引入配置文件-ehcache-xml"><a href="#引入配置文件-ehcache-xml" class="headerlink" title="引入配置文件 ehcache.xml"></a>引入配置文件 ehcache.xml</h3><p>在resource文件夹下创建文件ehcache.xml，并进行配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"http://ehcache.org/ehcache.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">updateCheck</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这里的 users 缓存空间是为了下面的 demo 做准备 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"users"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="ehcache-xml-文件配置详解"><a href="#ehcache-xml-文件配置详解" class="headerlink" title="ehcache.xml 文件配置详解"></a>ehcache.xml 文件配置详解</h3><pre><code>name:缓存名称。
maxElementsInMemory:缓存最大数目
maxElementsOnDisk：硬盘最大缓存个数。
eternal:对象是否永久有效，一但设置了，timeout将不起作用。
overflowToDisk:是否保存到磁盘，当系统当机时
timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
clearOnFlush：内存数量最大时是否清除。
memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。</code></pre><h3 id="在主类加上启动注解"><a href="#在主类加上启动注解" class="headerlink" title="在主类加上启动注解"></a>在主类加上启动注解</h3><p>在 Spring Boot 主类加上开启缓存的注解@EnableCaching。表示启动缓存功能。</p>
<p>在方法或类上就直接可以使用了，如：@Cacheable(value=”neteaseAccountInfoCache”,key=”#fid+#unionId “,unless=”#result==null”)</p>
<p>如果需要对缓存做更详细操作，可以参考<a href="https://www.cnblogs.com/zhangzhen894095789/p/6525845.html，比较全面，感谢！" target="_blank" rel="noopener">https://www.cnblogs.com/zhangzhen894095789/p/6525845.html，比较全面，感谢！</a></p>

          
        
      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2018/12/23/Idea%20SpringBoot%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/Idea%20SpringBoot%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/" itemprop="url">Idea SpringBoot多模块项目打包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T00:00:00+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">工具使用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、打包配置"><a href="#一、打包配置" class="headerlink" title="一、打包配置"></a>一、打包配置</h2><p>多模块时候，一般parant的pom中不用配置打包插件，直接在主模块中配置就行，如果有mybatis的模块，也可以配置，如：</p>
<p>主模块： </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com......ApplicationMain<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有mybatis的模块：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span><span class="comment">&lt;!-- i18n能读取到 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="二、打包测试"><a href="#二、打包测试" class="headerlink" title="二、打包测试"></a>二、打包测试</h2><p>打包时默认会进行测试，而由于多模块架构，测试一直失败，跳过测试的方法：</p>
<p>1、在pom文件里加插件：因为是多模块结构以及springboot的<parant>原因，导致每个pom都要添加，还可能出现意外问题。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、控制台，cd到父项目下，执行命令：mvn clean install -DskipTests</p>
<p>3、同上，执行命令：mvn clean install -Dmaven.test.skip=true</p>
<p>4、如果在idea中，直接这样：<br>    ￼<br>通常我都是，只在主模块配置打包，其他不处理，mapper文件放在数据层模块的资源文件中，默认spring boot会自动去编译。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.......ApplicationMain<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Maven多模块项目单独编译子模块项目时报错：Failed to execute goal on project/Could not resolve dependencies for project</p>
<p>背景：常规的父子项目搭建的工程，参考：<a href="http://www.cnblogs.com/EasonJim/p/6863987.html" target="_blank" rel="noopener">http://www.cnblogs.com/EasonJim/p/6863987.html</a></p>
<p>解决方法：</p>
<p>1、需要把parent工程，也就是package是pom的那个工程先install一下；之后再install公共引入的模块，最后就可以单独编译子模块。</p>
<p>2、不用install，直接编译parent项目；这种方式只能在parent项目下进行，不能单独编译子模块。</p>

          
        
      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2018/11/01/Tomcat%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/01/Tomcat%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5Servlet/" itemprop="url">Tomcat是如何实现异步Servlet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-01T00:00:00+08:00">
                2018-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Spring boot中实现一个servlet，需要再启动类加上@ServletComponentScan注解来扫描Servlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns &#x3D; &quot;&#x2F;async&quot;,asyncSupported &#x3D; true)</span><br><span class="line">@Slf4j</span><br><span class="line">public class AsyncServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService &#x3D;Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;开启异步,获取异步上下文</span><br><span class="line">        final AsyncContext ctx &#x3D; req.startAsync();</span><br><span class="line">        &#x2F;&#x2F; 提交线程池异步执行</span><br><span class="line">        executorService.execute(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    log.info(&quot;async Service 准备执行了&quot;);</span><br><span class="line">                    &#x2F;&#x2F;模拟耗时任务</span><br><span class="line">                    Thread.sleep(10000L);</span><br><span class="line">                    ctx.getResponse().getWriter().print(&quot;async servlet&quot;);</span><br><span class="line">                    log.info(&quot;async Service 执行了&quot;);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;最后执行完成后完成回调。</span><br><span class="line">                ctx.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>异步Servlet的内部原理</p>
<p>上面主要是：final AsyncContext ctx = req.startAsync()和ctx.complete()，查看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public AsyncContext startAsync(ServletRequest request,</span><br><span class="line">         ServletResponse response) &#123;</span><br><span class="line">     if (!isAsyncSupported()) &#123;</span><br><span class="line">         IllegalStateException ise &#x3D;</span><br><span class="line">                 new IllegalStateException(sm.getString(&quot;request.asyncNotSupported&quot;));</span><br><span class="line">         log.warn(sm.getString(&quot;coyoteRequest.noAsync&quot;,</span><br><span class="line">                 StringUtils.join(getNonAsyncClassNames())), ise);</span><br><span class="line">         throw ise;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (asyncContext &#x3D;&#x3D; null) &#123;</span><br><span class="line">         asyncContext &#x3D; new AsyncContextImpl(this);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     asyncContext.setStarted(getContext(), request, response,</span><br><span class="line">             request&#x3D;&#x3D;getRequest() &amp;&amp; response&#x3D;&#x3D;getResponse().getResponse());</span><br><span class="line">     asyncContext.setTimeout(getConnector().getAsyncTimeout());</span><br><span class="line"></span><br><span class="line">     return asyncContext;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>req.startAsync()只是保存了一个异步上下文，同时设置一些基础信息，比如Timeout，这里设置的默认超时时间是30S，如果你的异步处理逻辑超过30S，此时执行ctx.complete()就会抛出IllegalStateException 异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  public void complete() &#123;</span><br><span class="line">        if (log.isDebugEnabled()) &#123;</span><br><span class="line">            logDebug(&quot;complete   &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        check();</span><br><span class="line">        request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;类：AbstractProcessor </span><br><span class="line"> public final void action(ActionCode actionCode, Object param) &#123;</span><br><span class="line">    case ASYNC_COMPLETE: &#123;</span><br><span class="line">            clearDispatches();</span><br><span class="line">            if (asyncStateMachine.asyncComplete()) &#123;</span><br><span class="line">                processSocketEvent(SocketEvent.OPEN_READ, true);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;类：AbstractProcessor </span><br><span class="line">protected void processSocketEvent(SocketEvent event, boolean dispatch) &#123;</span><br><span class="line">        SocketWrapperBase&lt;?&gt; socketWrapper &#x3D; getSocketWrapper();</span><br><span class="line">        if (socketWrapper !&#x3D; null) &#123;</span><br><span class="line">            socketWrapper.processSocket(event, dispatch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;类：AbstractEndpoint</span><br><span class="line">public boolean processSocket(SocketWrapperBase&lt;S&gt; socketWrapper,</span><br><span class="line">            SocketEvent event, boolean dispatch) &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">            SocketProcessorBase&lt;S&gt; sc &#x3D; null;</span><br><span class="line">            if (processorCache !&#x3D; null) &#123;</span><br><span class="line">                sc &#x3D; processorCache.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            if (sc &#x3D;&#x3D; null) &#123;</span><br><span class="line">                sc &#x3D; createSocketProcessor(socketWrapper, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sc.reset(socketWrapper, event);</span><br><span class="line">            &#125;</span><br><span class="line">            Executor executor &#x3D; getExecutor();</span><br><span class="line">            if (dispatch &amp;&amp; executor !&#x3D; null) &#123;</span><br><span class="line">                executor.execute(sc);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sc.run();</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以，这里最终会调用AbstractEndpoint的processSocket方法，EndPoint是用来接受和处理请求的，接下来就会交给Processor去进行协议处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;类：AbstractProcessorLight</span><br><span class="line">public SocketState process(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分diam</span><br><span class="line">        SocketState state &#x3D; SocketState.CLOSED;</span><br><span class="line">        Iterator&lt;DispatchType&gt; dispatches &#x3D; null;</span><br><span class="line">        do &#123;</span><br><span class="line">            if (dispatches !&#x3D; null) &#123;</span><br><span class="line">                DispatchType nextDispatch &#x3D; dispatches.next();</span><br><span class="line">                state &#x3D; dispatch(nextDispatch.getSocketStatus());</span><br><span class="line">            &#125; else if (status &#x3D;&#x3D; SocketEvent.DISCONNECT) &#123;</span><br><span class="line">            </span><br><span class="line">            &#125; else if (isAsync() || isUpgrade() || state &#x3D;&#x3D; SocketState.ASYNC_END) &#123;</span><br><span class="line">                state &#x3D; dispatch(status);</span><br><span class="line">                if (state &#x3D;&#x3D; SocketState.OPEN) &#123;</span><br><span class="line">                    state &#x3D; service(socketWrapper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (status &#x3D;&#x3D; SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">                state &#x3D; SocketState.LONG;</span><br><span class="line">            &#125; else if (status &#x3D;&#x3D; SocketEvent.OPEN_READ)&#123;</span><br><span class="line">                state &#x3D; service(socketWrapper);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                state &#x3D; SocketState.CLOSED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; while (state &#x3D;&#x3D; SocketState.ASYNC_END ||</span><br><span class="line">                dispatches !&#x3D; null &amp;&amp; state !&#x3D; SocketState.CLOSED);</span><br><span class="line"></span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractProcessorLight会根据SocketEvent的状态来判断是不是要去调用service(socketWrapper)，该方法最终会去调用到容器，从而完成业务逻辑的调用，我们这个请求是执行完成后调用的，肯定不能进容器了，不然就是死循环了，这里通过isAsync()判断，就会进入dispatch(status)，最终会调用CoyoteAdapter的asyncDispatch方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public boolean asyncDispatch(org.apache.coyote.Request req, org.apache.coyote.Response res,</span><br><span class="line">            SocketEvent status) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">        Request request &#x3D; (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">        Response response &#x3D; (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line">        boolean success &#x3D; true;</span><br><span class="line">        AsyncContextImpl asyncConImpl &#x3D; request.getAsyncContextInternal();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!request.isAsync()) &#123;</span><br><span class="line">                response.setSuspended(false);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (status&#x3D;&#x3D;SocketEvent.TIMEOUT) &#123;</span><br><span class="line">                if (!asyncConImpl.timeout()) &#123;</span><br><span class="line">                    asyncConImpl.setErrorState(null, false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (status&#x3D;&#x3D;SocketEvent.ERROR) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!request.isAsyncDispatching() &amp;&amp; request.isAsync()) &#123;</span><br><span class="line">                WriteListener writeListener &#x3D; res.getWriteListener();</span><br><span class="line">                ReadListener readListener &#x3D; req.getReadListener();</span><br><span class="line">                if (writeListener !&#x3D; null &amp;&amp; status &#x3D;&#x3D; SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">                    ClassLoader oldCL &#x3D; null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        oldCL &#x3D; request.getContext().bind(false, null);</span><br><span class="line">                        res.onWritePossible();&#x2F;&#x2F;这里执行浏览器响应，写入数据</span><br><span class="line">                        if (request.isFinished() &amp;&amp; req.sendAllDataReadEvent() &amp;&amp;</span><br><span class="line">                                readListener !&#x3D; null) &#123;</span><br><span class="line">                            readListener.onAllDataRead();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Throwable t) &#123;</span><br><span class="line">                       </span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        request.getContext().unbind(false, oldCL);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;这里判断异步正在进行，说明这不是一个完成方法的回调，是一个正常异步请求，继续调用容器。</span><br><span class="line">            if (request.isAsyncDispatching()) &#123;</span><br><span class="line">                connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                        request, response);</span><br><span class="line">                Throwable t &#x3D; (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line">                if (t !&#x3D; null) &#123;</span><br><span class="line">                    asyncConImpl.setErrorState(t, true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;注意，这里，如果超时或者出错，request.isAsync()会返回false，这里是为了尽快的输出错误给客户端。</span><br><span class="line">            if (!request.isAsync()) &#123;</span><br><span class="line">                &#x2F;&#x2F;这里也是输出逻辑</span><br><span class="line">                request.finishRequest();</span><br><span class="line">                response.finishResponse();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;销毁request和response</span><br><span class="line">            if (!success || !request.isAsync()) &#123;</span><br><span class="line">                updateWrapperErrorCount(request, response);</span><br><span class="line">                request.recycle();</span><br><span class="line">                response.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return success;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ctx.complete()执行最终的方法了，完成了数据的输出，最终输出到浏览器。</p>
<p>第一次doGet请求执行完成后，Tomcat是怎么知道不用返回到客户端的呢？关键代码在CoyoteAdapter中的service方法，部分代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">postParseSuccess &#x3D; postParseRequest(req, request, res, response);</span><br><span class="line">          &#x2F;&#x2F;省略部分代码</span><br><span class="line">          if (postParseSuccess) &#123;</span><br><span class="line">              request.setAsyncSupported(</span><br><span class="line">                      connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">              connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                      request, response);</span><br><span class="line">          &#125;</span><br><span class="line">          if (request.isAsync()) &#123;</span><br><span class="line">              async &#x3D; true;</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F;输出数据到客户端</span><br><span class="line">              request.finishRequest();</span><br><span class="line">              response.finishResponse();</span><br><span class="line">          if (!async) &#123;</span><br><span class="line">              updateWrapperErrorCount(request, response);</span><br><span class="line">              &#x2F;&#x2F;销毁request和response</span><br><span class="line">              request.recycle();</span><br><span class="line">              response.recycle();</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>调用完Servlet后，会通过request.isAsync()来判断是否是异步请求，如果是异步请求，就设置async = true。如果是非异步请求就执行输出数据到客户端逻辑，同时销毁request和response。这里就完成了请求结束后不响应客户端的操作。</p>
<p>Spring Boot的@EnableAsync注解不是异步Servlet</p>
<p>从业务层面来说，确实是异步编程，但是有一个问题，抛开业务的并行处理来说，针对整个请求来说，并不是异步的，也就是说不能立即释放Tomcat的线程，从而不能达到异步Servlet的效果。为什么它不是异步的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private TestService service;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String test() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            log.info(&quot;testAsynch Start&quot;);</span><br><span class="line">            CompletableFuture&lt;String&gt; test1 &#x3D; service.test1();</span><br><span class="line">            CompletableFuture&lt;String&gt; test2 &#x3D; service.test2();</span><br><span class="line">            CompletableFuture&lt;String&gt; test3 &#x3D; service.test3();</span><br><span class="line">            CompletableFuture.allOf(test1, test2, test3);</span><br><span class="line">            log.info(&quot;test1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + test1.get());</span><br><span class="line">            log.info(&quot;test2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + test2.get());</span><br><span class="line">            log.info(&quot;test3&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; + test3.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">@Service</span><br><span class="line">public class TestService &#123;</span><br><span class="line">    @Async(&quot;asyncExecutor&quot;)</span><br><span class="line">    public CompletableFuture&lt;String&gt; test1() throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(3000L);</span><br><span class="line">        return CompletableFuture.completedFuture(&quot;test1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async(&quot;asyncExecutor&quot;)</span><br><span class="line">    public CompletableFuture&lt;String&gt; test2() throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(3000L);</span><br><span class="line">        return CompletableFuture.completedFuture(&quot;test2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async(&quot;asyncExecutor&quot;)</span><br><span class="line">    public CompletableFuture&lt;String&gt; test3() throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(3000L);</span><br><span class="line">        return CompletableFuture.completedFuture(&quot;test3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAsync</span><br><span class="line">public class TomcatdebugApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TomcatdebugApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;asyncExecutor&quot;)</span><br><span class="line">    public Executor asyncExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor &#x3D; new ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(3);</span><br><span class="line">        executor.setMaxPoolSize(3);</span><br><span class="line">        executor.setQueueCapacity(100);</span><br><span class="line">        executor.setThreadNamePrefix(&quot;AsynchThread-&quot;);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我请求之后，在调用容器执行业务逻辑之前打了一个断点，然后在返回之后的同样打了一个断点，在Controller执行完之后，请求才回到了CoyoteAdapter中，并且判断request.isAsync(),根据图中看到，是为false,那么接下来就会执行request.finishRequest()和response.finishResponse()<br>来执行响应的结束，并销毁请求和响应体。很有趣的事情是，我实验的时候发现，在执行request.isAsync()之前，浏览器的页面上已经出现了响应体，这是SpringBoot框架已经通过StringHttpMessageConverter类中的writeInternal方法已经进行输出了。<br>以上分析的核心逻辑就是，Tomcat的线程执行CoyoteAdapter调用容器后，必须要等到请求返回，然后再判断是否是异步请求，再处理请求，然后执行完毕后，线程才能进行回收。而我一最开始的异步Servlet例子，执行完doGet方法后，就会立即返回，也就是会直接到request.isAsync()的逻辑，然后整个线程的逻辑执行完毕，线程被回收。</p>

          
        
      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2018/09/04/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-web%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-web%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/" itemprop="url">Tomcat源码分析-web请求处理过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>请求时由Connector来处理。从启动连接器开始：</p>
<h3 id="启动连接器"><a href="#启动连接器" class="headerlink" title="启动连接器"></a>启动连接器</h3><p>连接器构造方法中实例化了一个ProtocolHandler协议处理器，用来处理请求。然后在启动方法中启动协议处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate settings before starting</span></span><br><span class="line">    <span class="keyword">if</span> (getPort() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(</span><br><span class="line">                <span class="string">"coyoteConnector.invalidPort"</span>, Integer.valueOf(getPort())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        protocolHandler.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerStartFailed"</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在AbstractProtocol中启动endpoint：</p>
<h3 id="启动endpoint"><a href="#启动endpoint" class="headerlink" title="启动endpoint"></a>启动endpoint</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">        getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.start"</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    endpoint.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start timeout thread</span></span><br><span class="line">    asyncTimeout = <span class="keyword">new</span> AsyncTimeout();</span><br><span class="line">    Thread timeoutThread = <span class="keyword">new</span> Thread(asyncTimeout, getNameInternal() + <span class="string">"-AsyncTimeout"</span>);</span><br><span class="line">    <span class="keyword">int</span> priority = endpoint.getThreadPriority();</span><br><span class="line">    <span class="keyword">if</span> (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY) &#123;</span><br><span class="line">        priority = Thread.NORM_PRIORITY;</span><br><span class="line">    &#125;</span><br><span class="line">    timeoutThread.setPriority(priority);</span><br><span class="line">    timeoutThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    timeoutThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>endpoint的实现有几种：<br><img src="https://img.huyunshun.com/img/20200406092859.png" alt="20200406092859"></p>
<p>比如：NioEndPoint</p>
<h3 id="NioEndPoint"><a href="#NioEndPoint" class="headerlink" title="NioEndPoint"></a>NioEndPoint</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 启动NIO端点，创建acceptor和poller线程。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">        running = <span class="keyword">true</span>;</span><br><span class="line">        paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getProcessorCache());</span><br><span class="line">        eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                        socketProperties.getEventCache());</span><br><span class="line">        nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动轮询器线程</span></span><br><span class="line">        pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">            Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动线程s  是父类AbstractEndpoint方法</span></span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中定义了内部类，通过线程方式处理。</p>
<h3 id="Acceptor接收请求"><a href="#Acceptor接收请求" class="headerlink" title="Acceptor接收请求"></a>Acceptor接收请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>.<span class="title">Acceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop until we receive a shutdown command</span></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Loop if endpoint is paused 自旋的方式</span></span><br><span class="line">            <span class="keyword">while</span> (paused &amp;&amp; running) &#123;</span><br><span class="line">                state = AcceptorState.PAUSED;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            state = AcceptorState.RUNNING;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//i如果达到最大连接数，请稍候</span></span><br><span class="line">                countUpOrAwaitConnection();</span><br><span class="line"></span><br><span class="line">                SocketChannel socket = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 接受套接字</span></span><br><span class="line">                    socket = serverSock.accept();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    <span class="comment">// We didn't get a socket</span></span><br><span class="line">                    countDownConnection();</span><br><span class="line">                    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">                        <span class="comment">// 引入延迟</span></span><br><span class="line">                        errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">                        <span class="comment">// re-throw</span></span><br><span class="line">                        <span class="keyword">throw</span> ioe;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 成功接受，重置错误延迟</span></span><br><span class="line">                errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 配置套接字</span></span><br><span class="line">                <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                    <span class="comment">// 把套接字传递给适当的处理器</span></span><br><span class="line">                    <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">                        closeSocket(socket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    closeSocket(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">                log.error(sm.getString(<span class="string">"endpoint.accept.fail"</span>), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state = AcceptorState.ENDED;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeSocket</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">        countDownConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.socket().close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe)  &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(sm.getString(<span class="string">"endpoint.err.close"</span>), ioe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(sm.getString(<span class="string">"endpoint.err.close"</span>), ioe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用setSocketOptions方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理指定的连接</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Process the connection</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//禁用阻塞</span></span><br><span class="line">        socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Socket sock = socket.socket();</span><br><span class="line">        socketProperties.setProperties(sock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//就是把SocketChannel转换为Nio Channel</span></span><br><span class="line">        NioChannel channel = nioChannels.pop();</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            SocketBufferHandler bufhandler = <span class="keyword">new</span> SocketBufferHandler(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            <span class="keyword">if</span> (isSSLEnabled()) &#123;<span class="comment">//HTTPS</span></span><br><span class="line">                channel = <span class="keyword">new</span> SecureNioChannel(socket, bufhandler, selectorPool, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel = <span class="keyword">new</span> NioChannel(socket, bufhandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.setIOChannel(socket);</span><br><span class="line">            channel.reset();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注册进去</span></span><br><span class="line">        getPoller0().register(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.error(<span class="string">""</span>,t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(tt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Tell to close the socket</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Poller方法，向轮询器注册新创建的套接字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> NioChannel socket)</span> </span>&#123;</span><br><span class="line">    socket.setPoller(<span class="keyword">this</span>);</span><br><span class="line">    NioSocketWrapper ka = <span class="keyword">new</span> NioSocketWrapper(socket, NioEndpoint.<span class="keyword">this</span>);</span><br><span class="line">    socket.setSocketWrapper(ka);</span><br><span class="line">    ka.setPoller(<span class="keyword">this</span>);</span><br><span class="line">    ka.setReadTimeout(getSocketProperties().getSoTimeout());</span><br><span class="line">    ka.setWriteTimeout(getSocketProperties().getSoTimeout());</span><br><span class="line">    ka.setKeepAliveLeft(NioEndpoint.<span class="keyword">this</span>.getMaxKeepAliveRequests());</span><br><span class="line">    ka.setSecure(isSSLEnabled());</span><br><span class="line">    ka.setReadTimeout(getConnectionTimeout());</span><br><span class="line">    ka.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">    PollerEvent r = eventCache.pop();</span><br><span class="line">    ka.interestOps(SelectionKey.OP_READ);<span class="comment">//this is what OP_REGISTER turns into.</span></span><br><span class="line">    <span class="comment">//新建PollerEvent 加入到 EventQueue</span></span><br><span class="line">    <span class="keyword">if</span> ( r==<span class="keyword">null</span>) r = <span class="keyword">new</span> PollerEvent(socket,ka,OP_REGISTER);</span><br><span class="line">    <span class="keyword">else</span> r.reset(socket,ka,OP_REGISTER);</span><br><span class="line">    addEvent(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Poller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Loop until destroy() is called</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> hasEvents = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!close) &#123;</span><br><span class="line">                hasEvents = events();</span><br><span class="line">                <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//非阻塞</span></span><br><span class="line">                    keyCount = selector.selectNow();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    keyCount = selector.select(selectorTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 遍历所有eventqueue中所有的PollorEvent,然后依次调用PollorEvent的run方法，将socket注册到selector</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                events();</span><br><span class="line">                timeout(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    log.error(sm.getString(<span class="string">"endpoint.nio.selectorCloseFail"</span>), ioe);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(x);</span><br><span class="line">            log.error(<span class="string">""</span>,x);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//either we timed out or we woke up, process events first</span></span><br><span class="line">        <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents | events());</span><br><span class="line"></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">            keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Walk through the collection of ready keys and dispatch any active event.</span></span><br><span class="line">        <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey sk = iterator.next();</span><br><span class="line">            NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">            <span class="comment">// Attachment may be null if another thread has called</span></span><br><span class="line">            <span class="comment">// cancelledKey()</span></span><br><span class="line">            <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//接受请求后，移除。</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                processKey(sk, attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//超时</span></span><br><span class="line">        timeout(keyCount,hasEvents);</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">    getStopLatch().countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理轮询器事件队列中的事件 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">events</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//PollerEvent</span></span><br><span class="line">    PollerEvent pe = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != <span class="keyword">null</span>; i++ ) &#123;</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pe.run();</span><br><span class="line">            pe.reset();</span><br><span class="line">            <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                eventCache.push(pe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Throwable x ) &#123;</span><br><span class="line">            log.error(<span class="string">""</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper attachment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( close ) &#123;</span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( sk.isValid() &amp;&amp; attachment != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable() || sk.isWritable() ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( attachment.getSendfileData() != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                    processSendfile(sk,attachment, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                    <span class="keyword">boolean</span> closeSocket = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 先读后写</span></span><br><span class="line">                    <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_READ, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_WRITE, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (closeSocket) &#123;</span><br><span class="line">                        cancelledKey(sk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//invalid key</span></span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( CancelledKeyException ckx ) &#123;</span><br><span class="line">        cancelledKey(sk);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.error(<span class="string">""</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过处理器 处理具有给定状态的给定SocketWrapper。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">        SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (socketWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有拿到socket处理器，就去创建一个。</span></span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.reset(socketWrapper, event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过线程池处理</span></span><br><span class="line">        Executor executor = getExecutor();</span><br><span class="line">        <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(sc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sc.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">        getLog().warn(sm.getString(<span class="string">"endpoint.executor.fail"</span>, socketWrapper) , ree);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="comment">// OOM或类似的创建线程，或者池及其队列已满</span></span><br><span class="line">        getLog().error(sm.getString(<span class="string">"endpoint.process.fail"</span>), t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SocketProcessorBase&lt;S&gt; <span class="title">createSocketProcessor</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper, SocketEvent event)</span></span>;</span><br></pre></td></tr></table></figure>
<p>createSocketProcessor方法是抽象方法，去他的处理器实现：</p>
<p><img src="https://img.huyunshun.com/img/20200406100928.png" alt="20200406100928"></p>
<p>AbstractHttp11Protocol extends AbstractProtocol</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Processor <span class="title">createProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Http11Processor</span></span><br><span class="line">    Http11Processor processor = <span class="keyword">new</span> Http11Processor(<span class="keyword">this</span>, getEndpoint());</span><br><span class="line">    processor.setAdapter(getAdapter());</span><br><span class="line">    <span class="comment">//默认的keepalive的情况下，默认每个socket最大处理请求次数</span></span><br><span class="line">    processor.setMaxKeepAliveRequests(getMaxKeepAliveRequests());</span><br><span class="line">    <span class="comment">//开启keepalive的timeout</span></span><br><span class="line">    processor.setConnectionUploadTimeout(getConnectionUploadTimeout());</span><br><span class="line">    <span class="comment">//文件上传的默认超时时间</span></span><br><span class="line">    processor.setDisableUploadTimeout(getDisableUploadTimeout());</span><br><span class="line"></span><br><span class="line">    processor.setRestrictedUserAgents(getRestrictedUserAgents());</span><br><span class="line">    processor.setMaxSavePostSize(getMaxSavePostSize());</span><br><span class="line">    <span class="keyword">return</span> processor;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">通过处理后，设置对应的适配器。processor.setAdapter(getAdapter());通过适配器去匹配Mapper中的映射，如果找不到，就是请求错了。</span><br><span class="line"></span><br><span class="line">最中到<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoyoteAdapter</span> <span class="keyword">implements</span> <span class="title">Adapter</span>中去处理。通过适配器就过度到相应的容器上去处理。</span></span><br><span class="line"><span class="class">### 通过<span class="title">Adapter</span>找到对应的容器</span></span><br><span class="line"><span class="class">适配器执行方法：<span class="title">public</span> <span class="title">class</span> <span class="title">CoyoteAdapter</span> <span class="keyword">implements</span> <span class="title">Adapter</span></span></span><br><span class="line"><span class="class">```<span class="title">java</span></span></span><br><span class="line"><span class="class">@<span class="title">Override</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">service</span>(<span class="title">org</span>.<span class="title">apache</span>.<span class="title">coyote</span>.<span class="title">Request</span> <span class="title">req</span>, <span class="title">org</span>.<span class="title">apache</span>.<span class="title">coyote</span>.<span class="title">Response</span> <span class="title">res</span>)</span></span><br><span class="line"><span class="class">        <span class="title">throws</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把 coyote对象，转换为 http的对象</span></span><br><span class="line">    Request request = (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">    Response response = (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过连接器创建Request Response</span></span><br><span class="line">        request = connector.createRequest();</span><br><span class="line">        request.setCoyoteRequest(req);</span><br><span class="line">        response = connector.createResponse();</span><br><span class="line">        response.setCoyoteResponse(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联</span></span><br><span class="line">        request.setResponse(response);</span><br><span class="line">        response.setRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set as notes</span></span><br><span class="line">        req.setNote(ADAPTER_NOTES, request);</span><br><span class="line">        res.setNote(ADAPTER_NOTES, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URICharset 编码</span></span><br><span class="line">        req.getParameters().setQueryStringCharset(connector.getURICharset());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connector.getXpoweredBy()) &#123;</span><br><span class="line">        response.addHeader(<span class="string">"X-Powered-By"</span>, POWERED_BY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> async = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> postParseSuccess = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    req.getRequestProcessor().setWorkerThreadName(THREAD_NAME.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分析并设置Catalina和配置特定的请求参数</span></span><br><span class="line">        <span class="comment">// 在map中解析请求</span></span><br><span class="line">        <span class="comment">//在分析HTTP头之后执行必要的处理，以便将请求/响应对传递到容器管道的开始处进行处理。</span></span><br><span class="line">        postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">        <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">            <span class="comment">//check valves if we support async</span></span><br><span class="line">            request.setAsyncSupported(</span><br><span class="line">                    connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">            <span class="comment">// 调用容器：</span></span><br><span class="line">            <span class="comment">// 通过连接器获得service可以获取容器（Engine只有一个），再获取调用链。在Engine（StandardEngine）启动后  pipeline也会启动，维护的是StandardEngineValve</span></span><br><span class="line">            connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">            async = <span class="keyword">true</span>;</span><br><span class="line">            ReadListener readListener = req.getReadListener();</span><br><span class="line">            <span class="keyword">if</span> (readListener != <span class="keyword">null</span> &amp;&amp; request.isFinished()) &#123;</span><br><span class="line">                <span class="comment">// 可能在service（）方法期间读取了所有数据，因此需要在此处检查</span></span><br><span class="line">                ClassLoader oldCL = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oldCL = request.getContext().bind(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (req.sendAllDataReadEvent()) &#123;</span><br><span class="line">                        req.getReadListener().onAllDataRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    request.getContext().unbind(<span class="keyword">false</span>, oldCL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Throwable throwable =</span><br><span class="line">                    (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果异步请求已启动，则在该容器线程完成并发生错误后不会结束，则触发异步错误进程</span></span><br><span class="line">            <span class="keyword">if</span> (!request.isAsyncCompleting() &amp;&amp; throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.getAsyncContextInternal().setErrorState(throwable, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//请求响应完成</span></span><br><span class="line">            request.finishRequest();</span><br><span class="line">            response.finishResponse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AtomicBoolean error = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        res.action(ActionCode.IS_ERROR, error);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.isAsyncCompleting() &amp;&amp; error.get()) &#123;</span><br><span class="line">            <span class="comment">// 如果有字符，现在就将它们全部刷新到字节缓冲区，因为字节用于计算内容长度（当然，如果所有内容都适合字节缓冲区）。</span></span><br><span class="line">            res.action(ActionCode.ASYNC_POST_PROCESS,  <span class="keyword">null</span>);</span><br><span class="line">            async = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Access log</span></span><br><span class="line">        <span class="keyword">if</span> (!async &amp;&amp; postParseSuccess) &#123;</span><br><span class="line">            <span class="comment">// 仅在调用处理时记录。如果postParseRequest（）失败，则它已将其记录下来。</span></span><br><span class="line">            Context context = request.getContext();</span><br><span class="line">            Host host = request.getHost();</span><br><span class="line">            <span class="comment">//如果上下文为空，则可能是终结点已关闭，此连接已关闭，请求已在其他线程中回收。</span></span><br><span class="line">            <span class="comment">//该线程已经更新了访问日志，因此在这种情况下不更新访问日志是可以的。</span></span><br><span class="line">            <span class="comment">//另一种可能是在 无法将处理和请求映射到上下文。</span></span><br><span class="line">            <span class="comment">//在这种情况下，通过主机或引擎登录。</span></span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis() - req.getStartTime();</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                context.logAccess(request, response, time, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.isError()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (host != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    host.logAccess(request, response, time, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    connector.getService().getContainer().logAccess(</span><br><span class="line">                            request, response, time, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        req.getRequestProcessor().setWorkerThreadName(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收包装器请求和响应</span></span><br><span class="line">        <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">            updateWrapperErrorCount(request, response);</span><br><span class="line">            request.recycle();</span><br><span class="line">            response.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</p>
<p>通过连接器获得service可以获取容器（Engine只有一个），再获取调用链。在Engine（StandardEngine）启动后  pipeline也会启动，维护的是StandardEngineValve</p>
<p>invoke方法是StandardEngineValve中的invoke方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择用于此请求的主机</span></span><br><span class="line">    Host host = request.getHost();</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">        response.sendError</span><br><span class="line">            (HttpServletResponse.SC_BAD_REQUEST, sm.getString(<span class="string">"standardEngine.noHost"</span>,request.getServerName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">        request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请此主机处理此请求</span></span><br><span class="line">    host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StandardEngineValve中的invoke又会调用host中的StandardHostValve的invoke方法，依次StandardContextValve-&gt;StandardWrapperValve，最后到StandardWrapperValve中的invoke，这里处理servlet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize local variables we may need</span></span><br><span class="line">    <span class="keyword">boolean</span> unavailable = <span class="keyword">false</span>;</span><br><span class="line">    Throwable throwable = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// This should be a Request attribute...</span></span><br><span class="line">    <span class="keyword">long</span> t1=System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//增加请求次数</span></span><br><span class="line">    requestCount.incrementAndGet();</span><br><span class="line">    <span class="comment">//获取StandardWrapper，每次都有StandardWrapper和value</span></span><br><span class="line">    StandardWrapper wrapper = (StandardWrapper) getContainer();</span><br><span class="line">    <span class="comment">//获取Servlet</span></span><br><span class="line">    Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line">    Context context = (Context) wrapper.getParent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for the application being marked unavailable</span></span><br><span class="line">    <span class="keyword">if</span> (!context.getState().isAvailable()) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                        sm.getString(<span class="string">"standardContext.isUnavailable"</span>));</span><br><span class="line">        unavailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否获取到 包装头信息</span></span><br><span class="line">    <span class="keyword">if</span> (!unavailable &amp;&amp; wrapper.isUnavailable()) &#123;</span><br><span class="line">        container.getLogger().info(sm.getString(<span class="string">"standardWrapper.isUnavailable"</span>,</span><br><span class="line">                wrapper.getName()));</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">"Retry-After"</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                    sm.getString(<span class="string">"standardWrapper.isUnavailable"</span>,</span><br><span class="line">                            wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                    sm.getString(<span class="string">"standardWrapper.notFound"</span>,</span><br><span class="line">                            wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        unavailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个servlet实例来处理这个请求</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//没有获取到，就加载，Tomcat默认是按需加载。（延迟加载）</span></span><br><span class="line">        <span class="keyword">if</span> (!unavailable) &#123;</span><br><span class="line">            <span class="comment">//实例化</span></span><br><span class="line">            servlet = wrapper.allocate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">        container.getLogger().error(</span><br><span class="line">                sm.getString(<span class="string">"standardWrapper.allocateException"</span>,</span><br><span class="line">                        wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">"Retry-After"</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                        sm.getString(<span class="string">"standardWrapper.isUnavailable"</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                        sm.getString(<span class="string">"standardWrapper.notFound"</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">"standardWrapper.allocateException"</span>,</span><br><span class="line">                            wrapper.getName()), StandardWrapper.getRootCause(e));</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">"standardWrapper.allocateException"</span>,</span><br><span class="line">                            wrapper.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">        servlet = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageBytes requestPathMB = request.getRequestPathMB();</span><br><span class="line">    DispatcherType dispatcherType = DispatcherType.REQUEST;</span><br><span class="line">    <span class="keyword">if</span> (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</span><br><span class="line">            requestPathMB);</span><br><span class="line">    <span class="comment">// 过滤链，层层通过过滤器，再层层返回。</span></span><br><span class="line">    ApplicationFilterChain filterChain =</span><br><span class="line">            ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the filter chain for this request</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> This also calls the servlet's service() method</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp; (filterChain != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// Swallow output if needed</span></span><br><span class="line">            <span class="keyword">if</span> (context.getSwallowOutput()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SystemLogHandler.startCapture();</span><br><span class="line">                    <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                        request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//执行过滤链</span></span><br><span class="line">                        filterChain.doFilter(request.getRequest(),</span><br><span class="line">                                response.getResponse());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    String log = SystemLogHandler.stopCapture();</span><br><span class="line">                    <span class="keyword">if</span> (log != <span class="keyword">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        context.getLogger().info(log);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                    request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterChain.doFilter</span><br><span class="line">                        (request.getRequest(), response.getResponse());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientAbortException | CloseNowException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (container.getLogger().isDebugEnabled()) &#123;</span><br><span class="line">            container.getLogger().debug(sm.getString(</span><br><span class="line">                    <span class="string">"standardWrapper.serviceException"</span>, wrapper.getName(),</span><br><span class="line">                    context.getName()), e);</span><br><span class="line">        &#125;</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">"standardWrapper.serviceException"</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">"standardWrapper.serviceException"</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        <span class="comment">//            throwable = e;</span></span><br><span class="line">        <span class="comment">//            exception(request, response, e);</span></span><br><span class="line">        wrapper.unavailable(e);</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">"Retry-After"</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                        sm.getString(<span class="string">"standardWrapper.isUnavailable"</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                        sm.getString(<span class="string">"standardWrapper.notFound"</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do not save exception in 'throwable', because we</span></span><br><span class="line">        <span class="comment">// do not want to do exception(request, response, e) processing</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        Throwable rootCause = StandardWrapper.getRootCause(e);</span><br><span class="line">        <span class="keyword">if</span> (!(rootCause <span class="keyword">instanceof</span> ClientAbortException)) &#123;</span><br><span class="line">            container.getLogger().error(sm.getString(</span><br><span class="line">                    <span class="string">"standardWrapper.serviceExceptionRoot"</span>,</span><br><span class="line">                    wrapper.getName(), context.getName(), e.getMessage()),</span><br><span class="line">                    rootCause);</span><br><span class="line">        &#125;</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">"standardWrapper.serviceException"</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放此请求的过滤器链</span></span><br><span class="line">        <span class="keyword">if</span> (filterChain != <span class="keyword">null</span>) &#123;</span><br><span class="line">            filterChain.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收到servlet池，取消分配分配的servlet实例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (servlet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wrapper.deallocate(servlet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(e);</span><br><span class="line">            container.getLogger().error(sm.getString(<span class="string">"standardWrapper.deallocateException"</span>,</span><br><span class="line">                                wrapper.getName()), e);</span><br><span class="line">            <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                throwable = e;</span><br><span class="line">                exception(request, response, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this servlet has been marked permanently unavailable,</span></span><br><span class="line">        <span class="comment">// unload it and release this instance</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                (wrapper.getAvailable() == Long.MAX_VALUE)) &#123;</span><br><span class="line">                wrapper.unload();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(e);</span><br><span class="line">            container.getLogger().error(sm.getString(<span class="string">"standardWrapper.unloadException"</span>,</span><br><span class="line">                                wrapper.getName()), e);</span><br><span class="line">            <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                exception(request, response, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> t2=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> time=t2-t1;</span><br><span class="line">        processingTime += time;</span><br><span class="line">        <span class="keyword">if</span>( time &gt; maxTime) maxTime=time;</span><br><span class="line">        <span class="keyword">if</span>( time &lt; minTime) minTime=time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一直到找到servlet</p>
<h3 id="实例化servlet"><a href="#实例化servlet" class="headerlink" title="实例化servlet"></a>实例化servlet</h3><p>allocate()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Servlet <span class="title">allocate</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are currently unloading this servlet, throw an exception</span></span><br><span class="line">    <span class="keyword">if</span> (unloading) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">"standardWrapper.unloading"</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> newInstance = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是单线程模型，则每次返回相同的实例</span></span><br><span class="line">    <span class="keyword">if</span> (!singleThreadModel) &#123;</span><br><span class="line">        <span class="comment">// 必要时加载并初始化我们的实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span> || !instanceInitialized) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                            log.debug(<span class="string">"Allocating non-STM instance"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 注意：在加载之前，我们不知道Servlet是否实现了SingleThreadModel。</span></span><br><span class="line">                        instance = loadServlet();</span><br><span class="line">                        newInstance = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!singleThreadModel) &#123;</span><br><span class="line">                            <span class="comment">// For non-STM, increment here to prevent a race condition with unload. Bug 43683, test case</span></span><br><span class="line">                            <span class="comment">// #3</span></span><br><span class="line">                            countAllocated.incrementAndGet();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        ExceptionUtils.handleThrowable(e);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">"standardWrapper.allocate"</span>), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!instanceInitialized) &#123;</span><br><span class="line">                    initServlet(instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单线程模式</span></span><br><span class="line">        <span class="keyword">if</span> (singleThreadModel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newInstance) &#123;</span><br><span class="line">                <span class="comment">// 必须在上述同步之外执行此操作，以防止可能的死锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (instancePool) &#123;</span><br><span class="line">                    <span class="comment">//往实例池里放</span></span><br><span class="line">                    instancePool.push(instance);</span><br><span class="line">                    nInstances++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">"  Returning non-STM instance"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于新实例，在创建时计数将增加</span></span><br><span class="line">            <span class="keyword">if</span> (!newInstance) &#123;</span><br><span class="line">                countAllocated.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (instancePool) &#123;</span><br><span class="line">        <span class="keyword">while</span> (countAllocated.get() &gt;= nInstances) &#123;</span><br><span class="line">            <span class="comment">// 如果可能，分配一个新实例，否则等待</span></span><br><span class="line">            <span class="keyword">if</span> (nInstances &lt; maxInstances) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instancePool.push(loadServlet());</span><br><span class="line">                    nInstances++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    ExceptionUtils.handleThrowable(e);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">"standardWrapper.allocate"</span>), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instancePool.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">"  Returning allocated STM instance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        countAllocated.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> instancePool.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>上面最终通过连接器的适配器执行service：<br>connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);<br>最终可以找到servlet处理。</p>
<p>处理完成，层层返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求响应完成</span></span><br><span class="line">request.finishRequest();</span><br><span class="line">response.finishResponse();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Writing leftover bytes</span></span><br><span class="line">    outputBuffer.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (suspended) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有字符，就将它们全部刷新到字节缓冲区，计算内容长度（当然，如果所有内容都适合字节缓冲区）。</span></span><br><span class="line">    <span class="keyword">if</span> (cb.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//数据刷出 并进行字符转换</span></span><br><span class="line">        flushCharBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((!coyoteResponse.isCommitted()) &amp;&amp; (coyoteResponse.getContentLengthLong() == -<span class="number">1</span>)</span><br><span class="line">            &amp;&amp; !coyoteResponse.getRequest().method().equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">        <span class="comment">//如果这没有导致响应提交，则可以计算最终内容长度。只有当这不是头</span></span><br><span class="line">        <span class="comment">//因为在这种情况下，不应该有任何机构</span></span><br><span class="line">        <span class="comment">//在此处设置值为零将导致显式内容</span></span><br><span class="line">        <span class="comment">//正在对响应设置零的长度。</span></span><br><span class="line">        <span class="keyword">if</span> (!coyoteResponse.isCommitted()) &#123;</span><br><span class="line">            coyoteResponse.setContentLength(bb.remaining());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据对象，刷出到outputbuffer</span></span><br><span class="line">    <span class="keyword">if</span> (coyoteResponse.getStatus() == HttpServletResponse.SC_SWITCHING_PROTOCOLS) &#123;</span><br><span class="line">        doFlush(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doFlush(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    closed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求应该在响应时已完全读取</span></span><br><span class="line">    <span class="comment">//已关闭。进一步读取输入a）是没有意义的，b）真的</span></span><br><span class="line">    <span class="comment">//混淆AJP（错误50189），关闭输入缓冲区以防止它们。</span></span><br><span class="line">    <span class="comment">//转换为http对象</span></span><br><span class="line">    Request req = (Request) coyoteResponse.getRequest().getNote(CoyoteAdapter.ADAPTER_NOTES);</span><br><span class="line">    req.inputBuffer.close();</span><br><span class="line"></span><br><span class="line">    coyoteResponse.action(ActionCode.CLOSE, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求时序图：<br><img src="https://img.huyunshun.com/img/20200406144305.png" alt="20200406144305"></p>
<h2 id="总结accept流程"><a href="#总结accept流程" class="headerlink" title="总结accept流程"></a>总结accept流程</h2><p>Connector 启动以后会启动一组线程用于不同阶段的请求处理过程，Acceptor、Poller、worker 所在的线程组都维护在 NioEndpoint 中。</p>
<pre><code>Acceptor线程组。用于接受新连接，并将新连接封装一下，选择一个 Poller 将新连接添加到 Poller 的事件队列中，Acceptor线程组是多个线程组成的线程组。
Poller 线程组。用于监听 Socket 事件，当 Socket 可读或可写等等时，将 Socket 封装一下添加到 worker 线程池的任务队列中，Poller线程组是多个线程组成的线程组。
worker 线程组。用于对请求进行处理，包括分析请求报文并创建 Request 对象，调用容器的 pipeline 进行处理，worker线程组是Executor创建的线程池。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 创建worker线程组</span></span><br><span class="line">            <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">                createExecutor();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Poller线程组由一堆线程组成</span></span><br><span class="line">            pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">                pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">                Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">"-ClientPoller-"</span>+i);</span><br><span class="line">                pollerThread.setPriority(threadPriority);</span><br><span class="line">                pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                pollerThread.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startAcceptorThreads();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Acceptor线程组由一堆线程组成</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">        acceptors = <span class="keyword">new</span> Acceptor[count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            acceptors[i] = createAcceptor();</span><br><span class="line">            String threadName = getName() + <span class="string">"-Acceptor-"</span> + i;</span><br><span class="line">            acceptors[i].setThreadName(threadName);</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(acceptors[i], threadName);</span><br><span class="line">            t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">            t.setDaemon(getDaemon());</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// worker的线程组由executor创建线程池组成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        internalExecutor = <span class="keyword">true</span>;</span><br><span class="line">        TaskQueue taskqueue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">        TaskThreadFactory tf = <span class="keyword">new</span> TaskThreadFactory(getName() + <span class="string">"-exec-"</span>, daemon, getThreadPriority());</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">        taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="请求处理过程"><a href="#请求处理过程" class="headerlink" title="请求处理过程"></a>请求处理过程</h3><h4 id="Acceptor接收连接"><a href="#Acceptor接收连接" class="headerlink" title="Acceptor接收连接"></a>Acceptor接收连接</h4><p>Acceptor接受的新连接没有立即注册到selector当中，需要先封装成PollerEvent对象后保存至PollerEvent队列当中，Poller对象会消费PollerEvent队列，类似生产消费模型。</p>
<pre><code>Acceptor 在启动后会阻塞在 ServerSocketChannel.accept(); 方法处，当有新连接到达时，该方法返回一个 SocketChannel。

setSocketOptions()方法将 Socket 封装到 NioChannel 中，并注册到 Poller。

一开始就启动了多个 Poller 线程，注册的时候采用轮询选择 Poller 。NioEndpoint 维护了一个 Poller 数组，当一个连接分配给 pollers[index] 时，下一个连接就会分配给 pollers[(index+1)%pollers.length]。

addEvent() 方法会将 Socket 添加到该 Poller 的 PollerEvent 队列中。到此 Acceptor 的任务就完成了。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServerSocketChannel serverSock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>.<span class="title">Acceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                state = AcceptorState.RUNNING;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SocketChannel socket = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 监听socket负责接收新连接</span></span><br><span class="line">                        socket = serverSock.accept();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">                        <span class="comment">// 处理接受到的socket对象</span></span><br><span class="line">                        <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">                            closeSocket(socket);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state = AcceptorState.ENDED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setSocketOptions</span><span class="params">(SocketChannel socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            Socket sock = socket.socket();</span><br><span class="line">            socketProperties.setProperties(sock);</span><br><span class="line">            </span><br><span class="line">            channel = <span class="keyword">new</span> NioChannel(socket, bufhandler);</span><br><span class="line">            <span class="comment">// 注册到Poller当中</span></span><br><span class="line">            getPoller0().register(channel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Poller <span class="title">getPoller0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Math.abs(pollerRotater.incrementAndGet()) % pollers.length;</span><br><span class="line">        <span class="keyword">return</span> pollers[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> NioChannel socket)</span> </span>&#123;</span><br><span class="line">            socket.setPoller(<span class="keyword">this</span>);</span><br><span class="line">            NioSocketWrapper ka = <span class="keyword">new</span> NioSocketWrapper(socket, NioEndpoint.<span class="keyword">this</span>);</span><br><span class="line">            r = <span class="keyword">new</span> PollerEvent(socket,ka,OP_REGISTER);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加PollerEvent队列当中</span></span><br><span class="line">            addEvent(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEvent</span><span class="params">(PollerEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 投入到PollerEvent队列当中</span></span><br><span class="line">            events.offer(event);</span><br><span class="line">            <span class="keyword">if</span> ( wakeupCounter.incrementAndGet() == <span class="number">0</span> ) selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Poller处理请求"><a href="#Poller处理请求" class="headerlink" title="Poller处理请求"></a>Poller处理请求</h4><p>Poller会消费PollerEvent队列（由Acceptor进行投递），并注册到Selector当中。当注册到Selector的socket数据可读的时候将socket封装成SocketProcessor对象，投递到Executor实现的线程池进行处理。</p>
<pre><code>selector.select(1000)。当 Poller 启动后因为 selector 中并没有已注册的 Channel，所以当执行到该方法时只能阻塞。所有的 Poller 共用一个 Selector，其实现类是 sun.nio.ch.SelectorImpl。

events() 方法通过 addEvent() 方法添加到事件队列中的 Socket 注册到SelectorImpl。这里指的socket是accept过来的请求的socket。

当 Socket 可读时，Poller 才对其进行处理，createSocketProcessor() 方法将 Socket 封装到 SocketProcessor 中，SocketProcessor 实现了 Runnable 接口。worker 线程通过调用其 run() 方法来对 Socket 进行处理。

execute(SocketProcessor) 方法将 SocketProcessor 提交到线程池，放入线程池的 workQueue 中。workQueue 是 BlockingQueue 的实例。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PollerEvent</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> NioChannel socket;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> interestOps;</span><br><span class="line">        <span class="keyword">private</span> NioSocketWrapper socketWrapper;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PollerEvent</span><span class="params">(NioChannel ch, NioSocketWrapper w, <span class="keyword">int</span> intOps)</span> </span>&#123;</span><br><span class="line">            reset(ch, w, intOps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (interestOps == OP_REGISTER) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.getIOChannel().register(</span><br><span class="line">                            socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// events()负责处理PollerEvent事件并注册到selector当中</span></span><br><span class="line">                hasEvents = events();</span><br><span class="line">                keyCount = selector.select(selectorTimeout);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理新接受的socket的读写事件</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">                    keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (iterator != <span class="keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey sk = iterator.next();</span><br><span class="line">                    NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line"></span><br><span class="line">                    processKey(sk, attachment);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理读写事件</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper attachment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_READ, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">                            </span><br><span class="line">            <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_WRITE, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    closeSocket = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">            SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">            Executor executor = getExecutor();</span><br><span class="line">            <span class="comment">// 注册到Worker的线程池ThreadPoolExecutor。</span></span><br><span class="line">            <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                executor.execute(sc);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Worker处理具体请求"><a href="#Worker处理具体请求" class="headerlink" title="Worker处理具体请求"></a>Worker处理具体请求</h4><p>当新任务添加到 workQueue(ThreadPoolExecutor)后，workQueue.take()方法会返回一个 Runnable，通常是 SocketProcessor,然后 worker 线程调用 SocketProcessor的run() -&gt; doRun()方法对 Socket 进行处理。</p>
<p>createProcessor() 会创建一个Http11Processor, 它用来解析 Socket，将 Socket 中的内容封装到Request中。注意这个Request是临时使用的一个类，它的全类名是org.apache.coyote.Request。</p>
<p>CoyoteAdapter的postParseRequest()方法封装一下 Request，并处理一下映射关系(从 URL 映射到相应的 Host、Context、Wrapper)。</p>
<p>CoyoteAdapter将 Rquest 提交给 Container(StandardEngine) 处理之前，并将 org.apache.coyote.Request封装到 org.apache.catalina.connector.Request，传递给 Container处理的 Request 是 org.apache.catalina.connector.Request。</p>
<p>connector.getService().getMapper().map()，用来在Mapper中查询 URL 的映射关系。映射关系会保留到 org.apache.catalina.connector.Request 中，Container处理阶段 request.getHost()是使用的就是这个阶段查询到的映射主机，以此类推 request.getContext()、request.getWrapper()都是。</p>
<p>connector.getService().getContainer().getPipeline().getFirst().invoke()会将请求传递到 Container(StandardEngine)处理，至此进入了Engine-&gt;Host-&gt;Context-&gt;Wrapper的处理流程，当然了 Container处理也是在 Worker线程中执行的（也就是说Tomcat处理请求是通过ThreadPoolExecutor的线程池实现的），但是这是一个相对独立的模块，所以单独分出来一节。</p>

          
        
      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2018/09/04/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">Tomcat源码中涉及的设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法模式抽象出某个业务操作公共的流程，将流程分为几个步骤，其中有一些步骤是固定不变的，有一些步骤是变化的，固定不变的步骤通过一个基类来实现，而变化的部分通过钩子方法让子类去实现，这样就实现了对系统中流程的统一化规范化管理。</p>
<p>Tomcat中关于生命周期管理应用了模板方法模式，在一个组件的生命周期中都会涉及到init(初始化)，start（启动），stop(停止)，destory（销毁），而对于每一个生命周期阶段其实都有固定一些事情要做，比如判断前置状态，设置后置状态，以及通知状态变更事件的监听者等，而这些工作其实是可以固化的，所以Tomcat中就将每个生命周期阶段公共的部分固化，然后通过initInternal,startInternal,stopInternal,destoryInternal这几个钩子方法开放给子类去实现具体的逻辑。</p>
<p><img src="https://img.huyunshun.com/img/20200412101412.png" alt="20200412101412"></p>
<p>tomcat的所有容器都实现了Lifecycle的生命周期管理接口</p>
<p>基类LifecycleBase实现了Lifecycle接口并实现init、start、stop、destroy等方法。</p>
<p>  init()方法内部模板化初始化流程，抽象具体的实现initInternal()方法。<br>  start()方法内部模板化启动流程，抽象具体的实现startInternal()方法。<br>  stop()方法内部模板化停止流程，抽象具体的实现stopInternal()方法。<br>  destroy()方法内部模板化释放流程，抽象具体的实现destroyInternal()方法。</p>
<p>Tomcat状态转移图</p>
<p><img src="https://img.huyunshun.com/img/20200412103613.png" alt="20200412103613"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_INIT_EVENT = <span class="string">"before_init"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_INIT_EVENT = <span class="string">"after_init"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String START_EVENT = <span class="string">"start"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_START_EVENT = <span class="string">"before_start"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_START_EVENT = <span class="string">"after_start"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOP_EVENT = <span class="string">"stop"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_STOP_EVENT = <span class="string">"before_stop"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_STOP_EVENT = <span class="string">"after_stop"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_DESTROY_EVENT = <span class="string">"after_destroy"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_DESTROY_EVENT = <span class="string">"before_destroy"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERIODIC_EVENT = <span class="string">"periodic"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURE_START_EVENT = <span class="string">"configure_start"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURE_STOP_EVENT = <span class="string">"configure_stop"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LifecycleBase基实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBase</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(LifecycleBase<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm = StringManager.getManager(LifecycleBase<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件通知的注册生命周期侦听器列表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;LifecycleListener&gt; lifecycleListeners = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 源组件的当前状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> LifecycleState state = LifecycleState.NEW;</span><br><span class="line">    <span class="comment">//捕获Tomcat启动时的错误，当这个属性为真时，就会抛出LifecycleException错误</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> throwOnFailure = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getThrowOnFailure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> throwOnFailure;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThrowOnFailure</span><span class="params">(<span class="keyword">boolean</span> throwOnFailure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.throwOnFailure = throwOnFailure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">        lifecycleListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners() &#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleListeners.toArray(<span class="keyword">new</span> LifecycleListener[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">        lifecycleListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许子类触发&#123;<span class="doctag">@link</span> Lifecycle&#125;事件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</span><br><span class="line">        LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(<span class="keyword">this</span>, type, data);</span><br><span class="line">        <span class="keyword">for</span> (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">            listener.lifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">            invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//真正的初始化方法</span></span><br><span class="line">            initInternal();</span><br><span class="line">            setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleSubClassException(t, <span class="string">"lifecycleBase.initFail"</span>, toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类实现此方法以执行所需的任何实例初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||</span><br><span class="line">                LifecycleState.STARTED.equals(state)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                Exception e = <span class="keyword">new</span> LifecycleException();</span><br><span class="line">                log.debug(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;</span><br><span class="line">                !state.equals(LifecycleState.STOPPED)) &#123;</span><br><span class="line">            invalidTransition(Lifecycle.BEFORE_START_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setStateInternal(LifecycleState.STARTING_PREP, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//最终启动</span></span><br><span class="line">            startInternal();</span><br><span class="line">            <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">                <span class="comment">// This is a 'controlled' failure. The component put itself into the</span></span><br><span class="line">                <span class="comment">// FAILED state so call stop() to complete the clean-up.</span></span><br><span class="line">                stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.STARTING)) &#123;</span><br><span class="line">                <span class="comment">// Shouldn't be necessary but acts as a check that sub-classes are</span></span><br><span class="line">                <span class="comment">// doing what they are supposed to.</span></span><br><span class="line">                invalidTransition(Lifecycle.AFTER_START_EVENT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setStateInternal(LifecycleState.STARTED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// This is an 'uncontrolled' failure so put the component into the</span></span><br><span class="line">            <span class="comment">// FAILED state and throw an exception.</span></span><br><span class="line">            handleSubClassException(t, <span class="string">"lifecycleBase.startFail"</span>, toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类必须确保在执行此方法期间状态更改为*&#123;<span class="doctag">@link</span> LifecycleState&#125;STARTING&#125;。</span></span><br><span class="line"><span class="comment">     * 更改状态将触发&#123;<span class="doctag">@link</span> Lifecycle#START_EVENT&#125;事件。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果一个组件启动失败，它可能抛出一个&#123;<span class="doctag">@link</span> LifecycleException&#125;，这将导致它的父组件启动失败*，</span></span><br><span class="line"><span class="comment">     * 或者它将自己置于错误状态，在这种情况下，将对失败的组件调用&#123;<span class="doctag">@link</span>#stop（）&#125;*，但父组件*将继续正常启动。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LifecycleState.STOPPING_PREP.equals(state) || LifecycleState.STOPPING.equals(state) ||</span><br><span class="line">                LifecycleState.STOPPED.equals(state)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                Exception e = <span class="keyword">new</span> LifecycleException();</span><br><span class="line">                log.debug(sm.getString(<span class="string">"lifecycleBase.alreadyStopped"</span>, toString()), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(sm.getString(<span class="string">"lifecycleBase.alreadyStopped"</span>, toString()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">            state = LifecycleState.STOPPED;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!state.equals(LifecycleState.STARTED) &amp;&amp; !state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">            invalidTransition(Lifecycle.BEFORE_STOP_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">                <span class="comment">// Don't transition to STOPPING_PREP as that would briefly mark the</span></span><br><span class="line">                <span class="comment">// component as available but do ensure the BEFORE_STOP_EVENT is</span></span><br><span class="line">                <span class="comment">// fired</span></span><br><span class="line">                fireLifecycleEvent(BEFORE_STOP_EVENT, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setStateInternal(LifecycleState.STOPPING_PREP, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stopInternal();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Shouldn't be necessary but acts as a check that sub-classes are</span></span><br><span class="line">            <span class="comment">// doing what they are supposed to.</span></span><br><span class="line">            <span class="keyword">if</span> (!state.equals(LifecycleState.STOPPING) &amp;&amp; !state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">                invalidTransition(Lifecycle.AFTER_STOP_EVENT);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setStateInternal(LifecycleState.STOPPED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleSubClassException(t, <span class="string">"lifecycleBase.stopFail"</span>, toString());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Lifecycle.SingleUse) &#123;</span><br><span class="line">                <span class="comment">// Complete stop process first</span></span><br><span class="line">                setStateInternal(LifecycleState.STOPPED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">                destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * *子类必须确保在执行此方法期间将状态更改为*&#123;<span class="doctag">@link</span> LifecycleState#STOPPING&#125;。*更改状态将触发&#123;<span class="doctag">@link</span> Lifecycle#STOP_EVENT&#125;事件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stopInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LifecycleState.FAILED.equals(state)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Triggers clean-up</span></span><br><span class="line">                stop();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                <span class="comment">// Just log. Still want to destroy.</span></span><br><span class="line">                log.error(sm.getString(<span class="string">"lifecycleBase.destroyStopFail"</span>, toString()), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LifecycleState.DESTROYING.equals(state) || LifecycleState.DESTROYED.equals(state)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                Exception e = <span class="keyword">new</span> LifecycleException();</span><br><span class="line">                log.debug(sm.getString(<span class="string">"lifecycleBase.alreadyDestroyed"</span>, toString()), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled() &amp;&amp; !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Lifecycle.SingleUse)) &#123;</span><br><span class="line">                <span class="comment">// Rather than have every component that might need to call</span></span><br><span class="line">                <span class="comment">// destroy() check for SingleUse, don't log an info message if</span></span><br><span class="line">                <span class="comment">// multiple calls are made to destroy()</span></span><br><span class="line">                log.info(sm.getString(<span class="string">"lifecycleBase.alreadyDestroyed"</span>, toString()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!state.equals(LifecycleState.STOPPED) &amp;&amp; !state.equals(LifecycleState.FAILED) &amp;&amp;</span><br><span class="line">                !state.equals(LifecycleState.NEW) &amp;&amp; !state.equals(LifecycleState.INITIALIZED)) &#123;</span><br><span class="line">            invalidTransition(Lifecycle.BEFORE_DESTROY_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setStateInternal(LifecycleState.DESTROYING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            destroyInternal();</span><br><span class="line">            setStateInternal(LifecycleState.DESTROYED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleSubClassException(t, <span class="string">"lifecycleBase.destroyFail"</span>, toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类实现此方法以执行所需的任何实例销毁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">destroyInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifecycleState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStateName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(LifecycleState state)</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        setStateInternal(state, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(LifecycleState state, Object data)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        setStateInternal(state, data, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setStateInternal</span><span class="params">(LifecycleState state, Object data, <span class="keyword">boolean</span> check)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">"lifecycleBase.setState"</span>, <span class="keyword">this</span>, state));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check) &#123;</span><br><span class="line">            <span class="comment">// 必须是由一个抽象方法触发的（假设这个类中的代码是正确的）空永远都不是有效的状态</span></span><br><span class="line">            <span class="keyword">if</span> (state == <span class="keyword">null</span>) &#123;</span><br><span class="line">                invalidTransition(<span class="string">"null"</span>);</span><br><span class="line">                <span class="comment">// 无法访问的代码-这里是为了阻止eclipse抱怨方法后面可能有NPE</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任何方法都可以转换为failed startInternal（）允许启动准备到启动</span></span><br><span class="line">            <span class="comment">// stopInternal（）允许停止准备到停止，并且无法停止</span></span><br><span class="line">            <span class="keyword">if</span> (!(state == LifecycleState.FAILED ||</span><br><span class="line">                    (<span class="keyword">this</span>.state == LifecycleState.STARTING_PREP &amp;&amp;</span><br><span class="line">                            state == LifecycleState.STARTING) ||</span><br><span class="line">                    (<span class="keyword">this</span>.state == LifecycleState.STOPPING_PREP &amp;&amp;</span><br><span class="line">                            state == LifecycleState.STOPPING) ||</span><br><span class="line">                    (<span class="keyword">this</span>.state == LifecycleState.FAILED &amp;&amp;</span><br><span class="line">                            state == LifecycleState.STOPPING))) &#123;</span><br><span class="line">                <span class="comment">// No other transition permitted</span></span><br><span class="line">                invalidTransition(state.name());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        String lifecycleEvent = state.getLifecycleEvent();</span><br><span class="line">        <span class="keyword">if</span> (lifecycleEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fireLifecycleEvent(lifecycleEvent, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invalidTransition</span><span class="params">(String type)</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        String msg = sm.getString(<span class="string">"lifecycleBase.invalidTransition"</span>, type, toString(), state);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSubClassException</span><span class="params">(Throwable t, String key, Object... args)</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        setStateInternal(LifecycleState.FAILED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        String msg = sm.getString(key, args);</span><br><span class="line">        <span class="keyword">if</span> (getThrowOnFailure()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(t <span class="keyword">instanceof</span> LifecycleException)) &#123;</span><br><span class="line">                t = <span class="keyword">new</span> LifecycleException(msg, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> (LifecycleException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(msg, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>在Tomcat启动的过程中，调用Connector的startInternal()启动中，启动endpoint后bind的方法，初始化endpoint就是使用了工厂模式创建socket</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式的定义，有多个对象在关注着一个对象，如果这个对象的状态发生了改变，其它依赖（关注）它的对象就会收到通知，然后在接收到通知以后各个对象做出相应的动作。</p>
<p>观察者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 观察者的事件对象继承了EventObject类</span></span><br><span class="line"><span class="comment"> * 用于通知侦听器实现生命周期接口的组件上的事件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleEvent</span><span class="params">(Lifecycle lifecycle, String type, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(lifecycle);</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与此事件关联的事件数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object data;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Lifecycle) getSource();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者实现统一的接口LifecycleListener，实现具体的方法lifecycleEvent。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的lifecycleEvent方法</span></span><br><span class="line"><span class="comment">//具体实现以ContextConfig为例，实现了具体的lifecycleEvent方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextConfig</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理关联上下文的事件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Identify the context we are associated with</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            context = (Context) event.getLifecycle();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"contextConfig.cce"</span>, event.getLifecycle()), e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process the event that has occurred</span></span><br><span class="line">        <span class="keyword">if</span> (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) &#123;</span><br><span class="line">            configureStart();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) &#123;</span><br><span class="line">            beforeStart();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(Lifecycle.AFTER_START_EVENT)) &#123;</span><br><span class="line">            <span class="comment">// Restore docBase for management tools</span></span><br><span class="line">            <span class="keyword">if</span> (originalDocBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">                context.setDocBase(originalDocBase);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(Lifecycle.CONFIGURE_STOP_EVENT)) &#123;</span><br><span class="line">            configureStop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(Lifecycle.AFTER_INIT_EVENT)) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(Lifecycle.AFTER_DESTROY_EVENT)) &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被观察者</p>
<p>  被观察者实现接口Lifecycle，实现addLifecycleListener和removeLifecycleListener方法。<br>  容器的基类LifecycleBase实现了被观察者功能，提供List&lt;LifecycleListener&gt; lifecycleListeners保存被观察者。<br>  容器的具体实现当中都是继承LifecycleBase类，所以包含了被观察者的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBase</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;LifecycleListener&gt; lifecycleListeners = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> LifecycleState state = LifecycleState.NEW;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">        lifecycleListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners() &#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleListeners.toArray(<span class="keyword">new</span> LifecycleListener[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">        lifecycleListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</span><br><span class="line">        LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(<span class="keyword">this</span>, type, data);</span><br><span class="line">        <span class="keyword">for</span> (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">            listener.lifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链，顾名思义，就是用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕。</p>
<p>在tomcat中容器之间，当一个请求过来的时候首先是engine容器接受请求，然后engine容器会把请求传到host容器，host容器又会传到context容器，context容器传到wrapper容器，最后wrapper容器使用适配请求的servlet处理请求。</p>
<p><img src="https://img.huyunshun.com/img/20200412111304.png" alt="20200412111304"></p>
<p><img src="https://img.huyunshun.com/img/20200412110748.png" alt="20200412110748"></p>
<p><img src="https://img.huyunshun.com/img/20200412113158.png" alt="20200412113158"></p>
<p>组成：</p>
<ul>
<li>Valve Valve作为职责链上的每个节点，主要用于处理流到该节点的request对象。</li>
</ul>
<p><img src="https://img.huyunshun.com/img/20200412111252.png" alt="20200412111252"></p>
<ul>
<li>Pipeline Pipeline作为职责链对象，主要维护Valve职责链节点对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Valve</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Valve <span class="title">getNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backgroundProcess</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsyncSupported</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pipeline</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Valve <span class="title">getBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBasic</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addValve</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> Valve[] getValves();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeValve</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Valve <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsyncSupported</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNonAsyncValves</span><span class="params">(Set&lt;String&gt; result)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Pipeline上面可以有很多Valve，这些Valve存放的方式并非统一存放在Pipeline中，而是像一个链表一个接着一个。当你获取到一个Valve实例的时候，调用getNext()方法即可获取在这个Pipeline上的下个Valve实例。</p>
<p>Pipeline中很多的方法都是操作Valve的，包括获取，设置，移除Valve,getFirst()返回的是Pipeline上的第一个Valve,而getBasic(),setBasic()则是获取/设置基础阀,我们都知道在Pipeline中，每个pipeline至少都有一个阀门，叫做基础阀，而getBasic(),setBasic()则是操作基础阀的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * StandardPipeline标准实现类中我们看到了对Pipeline接口的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardPipeline</span> <span class="keyword">extends</span> <span class="title">LifecycleBase</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Pipeline</span>, <span class="title">Contained</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(StandardPipeline<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm = StringManager.getManager(Constants.Package);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------------------------------------------- Constructors</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new StandardPipeline instance with no associated Container.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StandardPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new StandardPipeline instance that is associated with the</span></span><br><span class="line"><span class="comment">     * specified Container.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> container The container we should be associated with</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StandardPipeline</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        setContainer(container);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------------------------------------- Instance Variables</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The basic Valve (if any) associated with this Pipeline.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Valve basic = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The Container with which this Pipeline is associated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Container container = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The first valve associated with this Pipeline.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Valve first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------- Public Methods</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsyncSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Valve valve = (first!=<span class="keyword">null</span>)?first:basic;</span><br><span class="line">        <span class="keyword">boolean</span> supported = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (supported &amp;&amp; valve!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            supported = supported &amp; valve.isAsyncSupported();</span><br><span class="line">            valve = valve.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> supported;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNonAsyncValves</span><span class="params">(Set&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        Valve valve = (first!=<span class="keyword">null</span>) ? first : basic;</span><br><span class="line">        <span class="keyword">while</span> (valve != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!valve.isAsyncSupported()) &#123;</span><br><span class="line">                result.add(valve.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            valve = valve.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------ Contained Methods</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置与此管道关联的容器。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组件的start()方法，将first(第一个阀门)赋值给current变量，如果current为空，就将basic(也就是基础阀)赋值给current,</span></span><br><span class="line"><span class="comment">     * 接下来如果一个标准的遍历单向链表，调用每个对象的start()方法，最后将组件(pipeline)状态设置为STARTING(启动中)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the Valves in our pipeline (including the basic), if any</span></span><br><span class="line">        Valve current = first;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            current = basic;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current <span class="keyword">instanceof</span> Lifecycle)</span><br><span class="line">                ((Lifecycle) current).start();</span><br><span class="line">            current = current.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setState(LifecycleState.STARTING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stopInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">        setState(LifecycleState.STOPPING);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stop the Valves in our pipeline (including the basic), if any</span></span><br><span class="line">        Valve current = first;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            current = basic;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current <span class="keyword">instanceof</span> Lifecycle)</span><br><span class="line">                ((Lifecycle) current).stop();</span><br><span class="line">            current = current.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Valve[] valves = getValves();</span><br><span class="line">        <span class="keyword">for</span> (Valve valve : valves) &#123;</span><br><span class="line">            removeValve(valve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a String representation of this component.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Pipeline["</span>);</span><br><span class="line">        sb.append(container);</span><br><span class="line">        sb.append(<span class="string">']'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------- Pipeline Methods</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Return the Valve instance that has been distinguished as the basic</span></span><br><span class="line"><span class="comment">     * Valve for this Pipeline (if any).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Valve <span class="title">getBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.basic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置基础阀的方法，这个方法在每个容器的构造函数中调用，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 阀门链表的遍历。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBasic</span><span class="params">(Valve valve)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经有基础阀(basic已经有值并且跟要设置的值一样）那么直接return</span></span><br><span class="line">        Valve oldBasic = <span class="keyword">this</span>.basic;</span><br><span class="line">        <span class="keyword">if</span> (oldBasic == valve)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旧的基础阀非空 那么调用其stop方法取消和对应container的关联。(销毁旧的基础阀)</span></span><br><span class="line">        <span class="keyword">if</span> (oldBasic != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getState().isAvailable() &amp;&amp; (oldBasic <span class="keyword">instanceof</span> Lifecycle)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ((Lifecycle) oldBasic).stop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                    log.error(sm.getString(<span class="string">"standardPipeline.basic.stop"</span>), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oldBasic <span class="keyword">instanceof</span> Contained) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ((Contained) oldBasic).setContainer(<span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    ExceptionUtils.handleThrowable(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the new component if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (valve == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//和Container进行关联</span></span><br><span class="line">        <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> Contained) &#123;</span><br><span class="line">            ((Contained) valve).setContainer(<span class="keyword">this</span>.container);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动新的阀门</span></span><br><span class="line">        <span class="keyword">if</span> (getState().isAvailable() &amp;&amp; valve <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Lifecycle) valve).start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">"standardPipeline.basic.start"</span>), e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历阀门链表将新的阀门取代旧的阀门</span></span><br><span class="line">        Valve current = first;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.getNext() == oldBasic) &#123;</span><br><span class="line">                current.setNext(valve);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将基础阀设置为新的阀门</span></span><br><span class="line">        <span class="keyword">this</span>.basic = valve;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向容器中添加Valve，在server.xml解析的时候也会调用该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addValve</span><span class="params">(Valve valve)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证Valve 关联Container</span></span><br><span class="line">        <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> Contained)</span><br><span class="line">            ((Contained) valve).setContainer(<span class="keyword">this</span>.container);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证组件状态，如果对的话 启动需要添加的Valve，调用start方法。</span></span><br><span class="line">        <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ((Lifecycle) valve).start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                    log.error(sm.getString(<span class="string">"standardPipeline.valve.start"</span>), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果 first变量为空，将valve赋值给first变量，并且设置 valve的下一个阀门为基础阀</span></span><br><span class="line">        <span class="comment">//之所以这样是因为，如果first为空说明这个容器只有一个基础阀，所以此次添加的阀门肯定是第一个非基础阀阀门</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = valve;</span><br><span class="line">            valve.setNext(basic);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则 遍历阀门链表，将要被添加的阀门设置在 基础阀之前。</span></span><br><span class="line">            Valve current = first;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current.getNext() == basic) &#123;</span><br><span class="line">                    current.setNext(valve);</span><br><span class="line">                    valve.setNext(basic);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                current = current.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//container触发添加阀门事件</span></span><br><span class="line">        container.fireContainerEvent(Container.ADD_VALVE_EVENT, valve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Valve[] getValves() &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Valve&gt; valveList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Valve current = first;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            current = basic;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valveList.add(current);</span><br><span class="line">            current = current.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valveList.toArray(<span class="keyword">new</span> Valve[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ObjectName[] getValveObjectNames() &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;ObjectName&gt; valveList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Valve current = first;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            current = basic;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">                valveList.add(((JmxEnabled) current).getObjectName());</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valveList.toArray(<span class="keyword">new</span> ObjectName[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeValve</span><span class="params">(Valve valve)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果first 是需要被移除的valve 那么将first的下一个阀门赋值给first，并且current 赋值null,否则current 赋值first</span></span><br><span class="line">        Valve current;</span><br><span class="line">        <span class="keyword">if</span>(first == valve) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////遍历阀门链表 查找需要被移除的阀门 如果之前first是被移除的话 current = null是不会进入该循环</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.getNext() == valve) &#123;</span><br><span class="line">                current.setNext(valve.getNext());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果first（此时已经指向下一个阀门）此时  == 基础阀，那么first置空</span></span><br><span class="line">        <span class="comment">//first指的是第一个阀门，即使整个container只有一个基础阀门也不会指向基础阀。</span></span><br><span class="line">        <span class="comment">//first严格定义是 除了基础阀的第一个阀门。</span></span><br><span class="line">        <span class="keyword">if</span> (first == basic) first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> Contained)</span><br><span class="line">            <span class="comment">//验证需要被移除的阀门 取消container关联</span></span><br><span class="line">            ((Contained) valve).setContainer(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">            <span class="comment">//验证需要被移除的阀门 取消container关联</span></span><br><span class="line">            <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ((Lifecycle) valve).stop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                    log.error(sm.getString(<span class="string">"standardPipeline.valve.stop"</span>), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Lifecycle) valve).destroy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">"standardPipeline.valve.destroy"</span>), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//触发container的移除valve事件。</span></span><br><span class="line">        container.fireContainerEvent(Container.REMOVE_VALVE_EVENT, valve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Valve <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> basic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个容器包含职责链对象Pipeline。</p>
<p>每个职责对象Valve的具体实现当中会包含下一个容器对象，相当于Valve对象内部会访问下一个容器，进而实现职责链传递。</p>
<p>整个Http请求被处理的流程：</p>
<ul>
<li>请求被Connector组件接收，创建Request和Response对象。</li>
<li>Connector将Request和Response交给Container,先通过Engine的pipeline组件流经内部的每个Valve。</li>
<li>请求流转到Host的pipeline组件中，并且经过内部Valve的过滤。</li>
<li>请求流转到Context的pipeline组件中，并且经过内部的Valve的过滤。</li>
<li>请求流转到Wrapper的pipeline组件中，并且经过内部的Valve的过滤。</li>
<li>Wrapper内部的WrapperValve创建FilterChain实例，调用指定的Servlet实例处理请求。</li>
<li>返回</li>
</ul>
<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><p>门面模式是对象的结构模式，外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p>
<p>Tomcat中门面模式的例子：</p>
<p><img src="https://img.huyunshun.com/img/20200412144024.png" alt="20200412144024"></p>
<p>RequestFacade作为Request的门面，内部包含Request对象。</p>
<p>这样的例子有：</p>
<p>  ResponseFacade作为Response的门面，内部包含Response对象。<br>  StandardSessionFacade作为HttpSession的门面，内部包含HttpSession对象。<br>  ApplicationContextFacade作为ApplicationContext的门面，内部包含ApplicaitonContext对象。</p>
<p>如Request源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFacade</span> <span class="keyword">implements</span> <span class="title">HttpServletRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestFacade</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Request request = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                            sm.getString(<span class="string">"requestFacade.nullRequest"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> request.getAttribute(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getAttributeNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                            sm.getString(<span class="string">"requestFacade.nullRequest"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED)&#123;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> GetAttributePrivilegedAction());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> request.getAttributeNames();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getContentLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                            sm.getString(<span class="string">"requestFacade.nullRequest"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> request.getContentLength();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">catalina</span>.<span class="title">servlet4preview</span>.<span class="title">http</span>.<span class="title">HttpServletRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest applicationRequest = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> RequestFacade facade = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpServletRequest <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (facade == <span class="keyword">null</span>) &#123;</span><br><span class="line">            facade = <span class="keyword">new</span> RequestFacade(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (applicationRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">            applicationRequest = facade;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> applicationRequest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

























          
        
      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2018/09/04/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" itemprop="url">Tomcat源码分析-加载和启动过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T00:00:00+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tomcat启动过程"><a href="#Tomcat启动过程" class="headerlink" title="Tomcat启动过程"></a>Tomcat启动过程</h2><p>Tomcat启动类入口是org.apache.catalina.startup.Bootstrap类，里面有main方法，还有静态代码块，初始化运行环境变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 获取系统变量</span></span><br><span class="line">    String userDir = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    String home = System.getProperty(Globals.CATALINA_HOME_PROP);</span><br><span class="line">    File homeFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取安装目录</span></span><br><span class="line">    <span class="keyword">if</span> (home != <span class="keyword">null</span>) &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(home);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            homeFile = f.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            homeFile = f.getAbsoluteFile();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// First fall-back. See if current directory is a bin directory</span></span><br><span class="line">        <span class="comment">// in a normal Tomcat install</span></span><br><span class="line">        File bootstrapJar = <span class="keyword">new</span> File(userDir, <span class="string">"bootstrap.jar"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bootstrapJar.exists()) &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(userDir, <span class="string">".."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Second fall-back. Use current directory</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(userDir);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            homeFile = f.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            homeFile = f.getAbsoluteFile();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置安装目录</span></span><br><span class="line">    catalinaHomeFile = homeFile;</span><br><span class="line">    System.setProperty(</span><br><span class="line">            Globals.CATALINA_HOME_PROP, catalinaHomeFile.getPath());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置工作目录</span></span><br><span class="line">    String base = System.getProperty(Globals.CATALINA_BASE_PROP);</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="keyword">null</span>) &#123;</span><br><span class="line">        catalinaBaseFile = catalinaHomeFile;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        File baseFile = <span class="keyword">new</span> File(base);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            baseFile = baseFile.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            baseFile = baseFile.getAbsoluteFile();</span><br><span class="line">        &#125;</span><br><span class="line">        catalinaBaseFile = baseFile;</span><br><span class="line">    &#125;</span><br><span class="line">    System.setProperty(</span><br><span class="line">            Globals.CATALINA_BASE_PROP, catalinaBaseFile.getPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (daemonLock) &#123;</span><br><span class="line">        <span class="comment">//创建主类 daemon是守护线程</span></span><br><span class="line">        <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Don't set daemon until init() has completed</span></span><br><span class="line">            <span class="comment">//Bootstrap实例化</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bootstrap.init();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleThrowable(t);</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            daemon = bootstrap;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When running as a service the call to stop will be on a new</span></span><br><span class="line">            <span class="comment">// thread so make sure the correct class loader is used to</span></span><br><span class="line">            <span class="comment">// prevent a range of class not found exceptions.</span></span><br><span class="line">            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String command = <span class="string">"start"</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            command = args[args.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (command.equals(<span class="string">"startd"</span>)) &#123;</span><br><span class="line">            args[args.length - <span class="number">1</span>] = <span class="string">"start"</span>;</span><br><span class="line">            daemon.load(args);</span><br><span class="line">            daemon.start();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"stopd"</span>)) &#123;</span><br><span class="line">            args[args.length - <span class="number">1</span>] = <span class="string">"stop"</span>;</span><br><span class="line">            daemon.stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"start"</span>)) &#123;</span><br><span class="line">            daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">            daemon.load(args);</span><br><span class="line">            daemon.start();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"stop"</span>)) &#123;</span><br><span class="line">            daemon.stopServer(args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"configtest"</span>)) &#123;</span><br><span class="line">            daemon.load(args);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"Bootstrap: command \""</span> + command + <span class="string">"\" does not exist."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                t.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = t.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">        handleThrowable(t);</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化整个环境"><a href="#初始化整个环境" class="headerlink" title="初始化整个环境"></a>初始化整个环境</h3><p>bootstrap.init();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//初始化类加载器</span></span><br><span class="line">    initClassLoaders();</span><br><span class="line">    <span class="comment">//设置上下文加载器</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line">    <span class="comment">//设置安全加载器</span></span><br><span class="line">    SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load our startup class and call its process() method</span></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Loading startup class"</span>);</span><br><span class="line">    <span class="comment">//反射的方式加载org.apache.catalina.startup.Catalina</span></span><br><span class="line">    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">"org.apache.catalina.startup.Catalina"</span>);</span><br><span class="line">    Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置共享扩展类加载器</span></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Setting startup class properties"</span>);</span><br><span class="line">    String methodName = <span class="string">"setParentClassLoader"</span>;</span><br><span class="line">    Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//设置父加载器</span></span><br><span class="line">    paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">"java.lang.ClassLoader"</span>);</span><br><span class="line">    Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">    paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">    Method method =</span><br><span class="line">        startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">    method.invoke(startupInstance, paramValues);</span><br><span class="line">    <span class="comment">//把实例赋予catalinaDaemon</span></span><br><span class="line">    catalinaDaemon = startupInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String[] arguments)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the load() method</span></span><br><span class="line">    String methodName = <span class="string">"load"</span>;</span><br><span class="line">    Object param[];</span><br><span class="line">    Class&lt;?&gt; paramTypes[];</span><br><span class="line">    <span class="keyword">if</span> (arguments==<span class="keyword">null</span> || arguments.length==<span class="number">0</span>) &#123;</span><br><span class="line">        paramTypes = <span class="keyword">null</span>;</span><br><span class="line">        param = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        paramTypes = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">        paramTypes[<span class="number">0</span>] = arguments.getClass();</span><br><span class="line">        param = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        param[<span class="number">0</span>] = arguments;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射执行了catalina的methodName（参数传过来）方法</span></span><br><span class="line">    Method method =</span><br><span class="line">        catalinaDaemon.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"Calling startup class "</span> + method);</span><br><span class="line">    &#125;</span><br><span class="line">    method.invoke(catalinaDaemon, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * load新服务器信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看是否load过</span></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    <span class="comment">//初始化目录</span></span><br><span class="line">    initDirs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before digester - it may be needed</span></span><br><span class="line">    <span class="comment">//初始化命名空间</span></span><br><span class="line">    initNaming();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载 解析 Server.xml文件，生成组件对象。</span></span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line"></span><br><span class="line">    InputSource inputSource = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    File file = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file = configFile();</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            inputSource = <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(sm.getString(<span class="string">"catalina.configFail"</span>, file), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream = getClass().getClassLoader()</span><br><span class="line">                    .getResourceAsStream(getConfigFile());</span><br><span class="line">                inputSource = <span class="keyword">new</span> InputSource</span><br><span class="line">                    (getClass().getClassLoader()</span><br><span class="line">                      .getResource(getConfigFile()).toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(sm.getString(<span class="string">"catalina.configFail"</span>,</span><br><span class="line">                            getConfigFile()), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This should be included in catalina.jar</span></span><br><span class="line">        <span class="comment">// Alternative: don't bother with xml, just create it manually.</span></span><br><span class="line">        <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream = getClass().getClassLoader()</span><br><span class="line">                        .getResourceAsStream(<span class="string">"server-embed.xml"</span>);</span><br><span class="line">                inputSource = <span class="keyword">new</span> InputSource</span><br><span class="line">                (getClass().getClassLoader()</span><br><span class="line">                        .getResource(<span class="string">"server-embed.xml"</span>).toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(sm.getString(<span class="string">"catalina.configFail"</span>,</span><br><span class="line">                            <span class="string">"server-embed.xml"</span>), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputStream == <span class="keyword">null</span> || inputSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>  (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">                log.warn(sm.getString(<span class="string">"catalina.configFail"</span>,</span><br><span class="line">                        getConfigFile() + <span class="string">"] or [server-embed.xml]"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(sm.getString(<span class="string">"catalina.configFail"</span>,</span><br><span class="line">                        file.getAbsolutePath()));</span><br><span class="line">                <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Permissions incorrect, read permission is not allowed on the file."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputSource.setByteStream(inputStream);</span><br><span class="line">            digester.push(<span class="keyword">this</span>);</span><br><span class="line">            digester.parse(inputSource);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SAXParseException spe) &#123;</span><br><span class="line">            log.warn(<span class="string">"Catalina.start using "</span> + getConfigFile() + <span class="string">": "</span> +</span><br><span class="line">                    spe.getMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Catalina.start using "</span> + getConfigFile() + <span class="string">": "</span> , e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置了工作目录和服务</span></span><br><span class="line">    getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stream redirection</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//初始化服务器</span></span><br><span class="line">        getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">"Catalina.start"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(<span class="string">"Initialization processed in "</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用LifecyleBase方法初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//真正的初始化容器方法</span></span><br><span class="line">        initInternal();</span><br><span class="line">        setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleSubClassException(t, <span class="string">"lifecycleBase.initFail"</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initInternal();每个容器继承LifecycleMBeanBase。实现自己的初始化。</p>
<p><img src="https://img.huyunshun.com/img/20200405112329.png" alt="20200405112329"></p>
<h3 id="初始化各个容器组件"><a href="#初始化各个容器组件" class="headerlink" title="初始化各个容器组件"></a>初始化各个容器组件</h3><p>Server-&gt;Service-&gt;(Engine/Executor/Connector-&gt;ProtocolHandler-&gt;EndPoint-&gt;绑定协议)</p>
<p>这里没有一直初始化Context下去，到Engine就停止，后面的子容器都是在启动的时候初始化的。</p>
<h4 id="初始化Server"><a href="#初始化Server" class="headerlink" title="初始化Server"></a>初始化Server</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">    onameStringCache = register(<span class="keyword">new</span> StringCache(), <span class="string">"type=StringCache"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the MBeanFactory 注册jMX 放到管理器</span></span><br><span class="line">    MBeanFactory factory = <span class="keyword">new</span> MBeanFactory();</span><br><span class="line">    factory.setContainer(<span class="keyword">this</span>);</span><br><span class="line">    onameMBeanFactory = register(factory, <span class="string">"type=MBeanFactory"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the naming resources</span></span><br><span class="line">    globalNamingResources.init();</span><br><span class="line">    <span class="keyword">if</span> (getCatalina() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassLoader cl = getCatalina().getParentClassLoader();</span><br><span class="line">        <span class="comment">// Walk the class loader hierarchy. Stop at the system class loader.</span></span><br><span class="line">        <span class="comment">// This will add the shared (if present) and common class loaders</span></span><br><span class="line">        <span class="keyword">while</span> (cl != <span class="keyword">null</span> &amp;&amp; cl != ClassLoader.getSystemClassLoader()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cl <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">                URL[] urls = ((URLClassLoader) cl).getURLs();</span><br><span class="line">                <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (url.getProtocol().equals(<span class="string">"file"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            File f = <span class="keyword">new</span> File (url.toURI());</span><br><span class="line">                            <span class="keyword">if</span> (f.isFile() &amp;&amp;</span><br><span class="line">                                    f.getName().endsWith(<span class="string">".jar"</span>)) &#123;</span><br><span class="line">                                ExtensionValidator.addSystemResource(f);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                            <span class="comment">// Ignore</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="comment">// Ignore</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cl = cl.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化我们定义的服务 可能有多个。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">        services[i].init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法又会初始化service</p>
<h4 id="初始化Service"><a href="#初始化Service" class="headerlink" title="初始化Service"></a>初始化Service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化 engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">        engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize any Executors 初始化线程池</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">            ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">        &#125;</span><br><span class="line">        executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化映射程序侦听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize our defined Connectors</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//初始化连接器</span></span><br><span class="line">                connector.init();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                String message = sm.getString(</span><br><span class="line">                        <span class="string">"standardService.connector.initFailed"</span>, connector);</span><br><span class="line">                log.error(message, e);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化Service时，也会初始化线程池，Engine和Connector。</p>
<h4 id="初始化Engine"><a href="#初始化Engine" class="headerlink" title="初始化Engine"></a>初始化Engine</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">// Ensure that a Realm is present before any attempt is made to start one. This will create the default NullRealm if necessary.</span></span><br><span class="line">    getRealm();</span><br><span class="line">    <span class="comment">//这里个之前初始化容器不同，前面都是父容器初始化子容器，这里不同，不再初始化后面的容器，后面容器在启动中初始化。</span></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用父类ContainerBase的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; startStopQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    startStopExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            getStartStopThreadsInternal(),</span><br><span class="line">            getStartStopThreadsInternal(), <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">            startStopQueue,</span><br><span class="line">            <span class="keyword">new</span> StartStopThreadFactory(getName() + <span class="string">"-startStop-"</span>));</span><br><span class="line">    startStopExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化Connector"><a href="#初始化Connector" class="headerlink" title="初始化Connector"></a>初始化Connector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接器初始化</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化适配器</span></span><br><span class="line">    adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</span><br><span class="line">    protocolHandler.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == parseBodyMethodsSet) &#123;</span><br><span class="line">        setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isInstanceCreated()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">"coyoteConnector.protocolHandlerNoAprListener"</span>,</span><br><span class="line">                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">"coyoteConnector.protocolHandlerNoAprLibrary"</span>,</span><br><span class="line">                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">            protocolHandler <span class="keyword">instanceof</span> AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">        AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler =</span><br><span class="line">                (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">        <span class="keyword">if</span> (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">                jsseProtocolHandler.getSslImplementationName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span></span><br><span class="line">            jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//protocolHandler初始化</span></span><br><span class="line">        protocolHandler.init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerInitializationFailed"</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里同时初始化了适配器CoyoteAdapter和AbstractProtocol.ProtocolHandler</p>
<p>而ProtocolHandler又会初始化EndPoint监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">        getLog().info(sm.getString(<span class="string">"abstractProtocolHandler.init"</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Component not pre-registered so register it</span></span><br><span class="line">        oname = createObjectName();</span><br><span class="line">        <span class="keyword">if</span> (oname != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rgOname = <span class="keyword">new</span> ObjectName(domain + <span class="string">":type=GlobalRequestProcessor,name="</span> + getName());</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(</span><br><span class="line">                getHandler().getGlobal(), rgOname, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听器初始化 来监听protocolHandler</span></span><br><span class="line">    endpoint.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面就是绑定协议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stopInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">        bind();</span><br><span class="line">        bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Register endpoint (as ThreadPool - historical name)</span></span><br><span class="line">        oname = <span class="keyword">new</span> ObjectName(domain + <span class="string">":type=ThreadPool,name=\""</span> + getName() + <span class="string">"\""</span>);</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        ObjectName socketPropertiesOname = <span class="keyword">new</span> ObjectName(domain +</span><br><span class="line">                <span class="string">":type=ThreadPool,name=\""</span> + getName() + <span class="string">"\",subType=SocketProperties"</span>);</span><br><span class="line">        socketProperties.setObjectName(socketPropertiesOname);</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(socketProperties, socketPropertiesOname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (SSLHostConfig sslHostConfig : findSslHostConfigs()) &#123;</span><br><span class="line">            registerJmx(sslHostConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.huyunshun.com/img/20200405112440.png" alt="20200405112440"></p>
<p>之后就是实例化ServerSocketl了。</p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>main方法中，启动daemon.start();其实是启动Catalina的start方法，之后启动服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (catalinaDaemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动Catalina守护进程。</span></span><br><span class="line">    Method method = catalinaDaemon.getClass().getMethod(<span class="string">"start"</span>, (Class [])<span class="keyword">null</span>);</span><br><span class="line">    method.invoke(catalinaDaemon, (Object [])<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实就是启动Catalina的start方法：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Start a new server instance.</span></span><br><span class="line"><span class="comment">  * 启动服务器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.fatal(<span class="string">"Cannot start server. Server instance is not configured."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.serverStartFail"</span>), e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getServer().destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e1) &#123;</span><br><span class="line">            log.debug(<span class="string">"destroy() failed for failed Server "</span>, e1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(<span class="string">"Server startup in "</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register shutdown hook</span></span><br><span class="line">    <span class="comment">//为了安全关闭</span></span><br><span class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">            shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If JULI is being used, disable JULI's shutdown hook since</span></span><br><span class="line">        <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">        <span class="comment">// if JULI's hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">        LogManager logManager = LogManager.getLogManager();</span><br><span class="line">        <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">            ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务启动，会调用LifecycleBean的start方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">//启动后生命周期的不同状态，又有不同的操作。</span></span><br><span class="line">    <span class="keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||</span><br><span class="line">            LifecycleState.STARTED.equals(state)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> LifecycleException();</span><br><span class="line">            log.debug(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">        stop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;</span><br><span class="line">            !state.equals(LifecycleState.STOPPED)) &#123;</span><br><span class="line">        invalidTransition(Lifecycle.BEFORE_START_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setStateInternal(LifecycleState.STARTING_PREP, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//最终启动的方法。不同的实现，分别启动实现。</span></span><br><span class="line">        startInternal();</span><br><span class="line">        <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">            <span class="comment">// This is a 'controlled' failure. The component put itself into the</span></span><br><span class="line">            <span class="comment">// FAILED state so call stop() to complete the clean-up.</span></span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.STARTING)) &#123;</span><br><span class="line">            <span class="comment">// Shouldn't be necessary but acts as a check that sub-classes are</span></span><br><span class="line">            <span class="comment">// doing what they are supposed to.</span></span><br><span class="line">            invalidTransition(Lifecycle.AFTER_START_EVENT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setStateInternal(LifecycleState.STARTED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// This is an 'uncontrolled' failure so put the component into the</span></span><br><span class="line">        <span class="comment">// FAILED state and throw an exception.</span></span><br><span class="line">        handleSubClassException(t, <span class="string">"lifecycleBase.startFail"</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="启动子组件"><a href="#启动子组件" class="headerlink" title="启动子组件"></a>启动子组件</h4><h4 id="启动server"><a href="#启动server" class="headerlink" title="启动server"></a>启动server</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">//监听器做相应的处理</span></span><br><span class="line">    fireLifecycleEvent(CONFIGURE_START_EVENT, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//设置状态</span></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    globalNamingResources.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start our defined Services</span></span><br><span class="line">    <span class="keyword">synchronized</span> (servicesLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">            services[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="启动service"><a href="#启动service" class="headerlink" title="启动service"></a>启动service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled())</span><br><span class="line">        log.info(sm.getString(<span class="string">"standardService.start.name"</span>, <span class="keyword">this</span>.name));</span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// engine启动</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (engine) &#123;</span><br><span class="line">            engine.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动线程池</span></span><br><span class="line">    <span class="keyword">synchronized</span> (executors) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Executor executor: executors) &#123;</span><br><span class="line">            executor.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动mapperListener监听器 主要用于处理映射关系</span></span><br><span class="line">    mapperListener.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动连接器 对应是在server.xml中</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector: connectors) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// If it has already failed, don't try and start it</span></span><br><span class="line">                <span class="keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">                    connector.start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(sm.getString(</span><br><span class="line">                        <span class="string">"standardService.connector.startFailed"</span>,</span><br><span class="line">                        connector), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="启动Engine"><a href="#启动Engine" class="headerlink" title="启动Engine"></a>启动Engine</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log our server identification information</span></span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled())</span><br><span class="line">        log.info( <span class="string">"Starting Servlet Engine: "</span> + ServerInfo.getServerInfo());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Standard container startup</span></span><br><span class="line">    <span class="keyword">super</span>.startInternal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不在启动子容器，而是执行父类方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start our subordinate components, if any</span></span><br><span class="line">    logger = <span class="keyword">null</span>;</span><br><span class="line">    getLogger();</span><br><span class="line">    <span class="comment">//有集群启动集群</span></span><br><span class="line">    Cluster cluster = getClusterInternal();</span><br><span class="line">    <span class="keyword">if</span> (cluster <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">        ((Lifecycle) cluster).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Realm realm = getRealmInternal();</span><br><span class="line">    <span class="keyword">if</span> (realm <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">        ((Lifecycle) realm).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动子容器 使用Future同步执行</span></span><br><span class="line">    Container children[] = findChildren();</span><br><span class="line">    List&lt;Future&lt;Void&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">        results.add(startStopExecutor.submit(<span class="keyword">new</span> StartChild(children[i])));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MultiThrowable multiThrowable = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Void&gt; result : results) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"containerBase.threadedStartFailed"</span>), e);</span><br><span class="line">            <span class="keyword">if</span> (multiThrowable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                multiThrowable = <span class="keyword">new</span> MultiThrowable();</span><br><span class="line">            &#125;</span><br><span class="line">            multiThrowable.add(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (multiThrowable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">"containerBase.threadedStartFailed"</span>),</span><br><span class="line">                multiThrowable.getThrowable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直到所有的子组件启动完成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动我们管道中的阀门（包括基本阀门）pipeline</span></span><br><span class="line">    <span class="keyword">if</span> (pipeline <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">        ((Lifecycle) pipeline).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置生命周期</span></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start our thread</span></span><br><span class="line">    threadStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="启动Connector"><a href="#启动Connector" class="headerlink" title="启动Connector"></a>启动Connector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">    setProtocol(protocol);</span><br><span class="line">    <span class="comment">// 实例化协议处理程序</span></span><br><span class="line">    ProtocolHandler p = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//org.apache.coyote.http11.Http11NioProtocol</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(protocolHandlerClassName);</span><br><span class="line">        p = (ProtocolHandler) clazz.getConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(sm.getString(</span><br><span class="line">                <span class="string">"coyoteConnector.protocolHandlerInstantiationFailed"</span>), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.protocolHandler = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Globals.STRICT_SERVLET_COMPLIANCE) &#123;</span><br><span class="line">        uriCharset = StandardCharsets.ISO_8859_1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        uriCharset = StandardCharsets.UTF_8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接器构造方法中实例化了一个ProtocolHandler协议处理器，用来处理请求。然后在启动方法中启动协议处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate settings before starting</span></span><br><span class="line">    <span class="keyword">if</span> (getPort() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(</span><br><span class="line">                <span class="string">"coyoteConnector.invalidPort"</span>, Integer.valueOf(getPort())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        protocolHandler.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                sm.getString(<span class="string">"coyoteConnector.protocolHandlerStartFailed"</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些容器启动流程如下：<br><img src="https://img.huyunshun.com/img/20200405225231.png" alt="20200405225231"></p>
<h3 id="启动子容器"><a href="#启动子容器" class="headerlink" title="启动子容器"></a>启动子容器</h3><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    String errorValve = getErrorReportValveClass();</span><br><span class="line">    <span class="keyword">if</span> ((errorValve != <span class="keyword">null</span>) &amp;&amp; (!errorValve.equals(<span class="string">""</span>))) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// Pipeline职责链</span></span><br><span class="line">            Valve[] valves = getPipeline().getValves();</span><br><span class="line">            <span class="keyword">for</span> (Valve valve : valves) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errorValve.equals(valve.getClass().getName())) &#123;</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!found) &#123;</span><br><span class="line">                Valve valve =</span><br><span class="line">                    (Valve) Class.forName(errorValve).getConstructor().newInstance();</span><br><span class="line">                getPipeline().addValve(valve);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            log.error(sm.getString(</span><br><span class="line">                    <span class="string">"standardHost.invalidErrorReportValveClass"</span>,</span><br><span class="line">                    errorValve), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.startInternal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续调用父类的startInternal</p>
<p>分层调用，子容器再掉父类startInternal，直到Context-&gt;Wrapper-&gt;没有子容器。结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置生命周期 后会激发监听器。</span></span><br><span class="line">setState(LifecycleState.STARTING);</span><br></pre></td></tr></table></figure>
<p>激活监听器后，回执行HostConfig中执行start</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(sm.getString(<span class="string">"hostConfig.start"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册事件</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ObjectName hostON = host.getObjectName();</span><br><span class="line">        oname = <span class="keyword">new</span> ObjectName</span><br><span class="line">            (hostON.getDomain() + <span class="string">":type=Deployer,host="</span> + host.getName());</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent</span><br><span class="line">            (<span class="keyword">this</span>, oname, <span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(sm.getString(<span class="string">"hostConfig.jmx.register"</span>, oname), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主机处理</span></span><br><span class="line">    <span class="keyword">if</span> (!host.getAppBaseFile().isDirectory()) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"hostConfig.appBase"</span>, host.getName(),</span><br><span class="line">                host.getAppBaseFile().getPath()));</span><br><span class="line">        host.setDeployOnStartup(<span class="keyword">false</span>);</span><br><span class="line">        host.setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//部署</span></span><br><span class="line">    <span class="keyword">if</span> (host.getDeployOnStartup())</span><br><span class="line">        deployApps();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为“应用程序根”目录中的任何目录或WAR文件部署应用程序。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deployApps</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    File appBase = host.getAppBaseFile();</span><br><span class="line">    File configBase = host.getConfigBaseFile();</span><br><span class="line">    String[] filteredAppPaths = filterAppPaths(appBase.list());</span><br><span class="line">    <span class="comment">//3中部署方式</span></span><br><span class="line">    <span class="comment">// 读取xml文件中Host &lt;Context&gt;</span></span><br><span class="line">    deployDescriptors(configBase, configBase.list());</span><br><span class="line">    <span class="comment">// Deploy WARs</span></span><br><span class="line">    deployWARs(appBase, filteredAppPaths);</span><br><span class="line">    <span class="comment">// Deploy expanded folders</span></span><br><span class="line">    deployDirectories(appBase, filteredAppPaths);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deployDirectories</span><span class="params">(File appBase, String[] files)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (files == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//启动一个线程池</span></span><br><span class="line">    ExecutorService es = host.getStartStopExecutor();</span><br><span class="line">    <span class="comment">//运用同步的方式去部署。</span></span><br><span class="line">    List&lt;Future&lt;?&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (files[i].equalsIgnoreCase(<span class="string">"META-INF"</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (files[i].equalsIgnoreCase(<span class="string">"WEB-INF"</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(appBase, files[i]);</span><br><span class="line">        <span class="keyword">if</span> (dir.isDirectory()) &#123;</span><br><span class="line">            ContextName cn = <span class="keyword">new</span> ContextName(files[i], <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isServiced(cn.getName()) || deploymentExists(cn.getName()))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            results.add(es.submit(<span class="keyword">new</span> DeployDirectory(<span class="keyword">this</span>, cn, dir)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Future&lt;?&gt; result : results) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(sm.getString(</span><br><span class="line">                    <span class="string">"hostConfig.deployDir.threaded.error"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一个内部类来部署应用程序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeployDirectory</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HostConfig config;</span><br><span class="line">    <span class="keyword">private</span> ContextName cn;</span><br><span class="line">    <span class="keyword">private</span> File dir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeployDirectory</span><span class="params">(HostConfig config, ContextName cn, File dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="keyword">this</span>.cn = cn;</span><br><span class="line">        <span class="keyword">this</span>.dir = dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        config.deployDirectory(cn, dir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部署启动应用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deployDirectory</span><span class="params">(ContextName cn, File dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Deploy the application in this directory</span></span><br><span class="line">    <span class="keyword">if</span>( log.isInfoEnabled() ) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        log.info(sm.getString(<span class="string">"hostConfig.deployDir"</span>,</span><br><span class="line">                dir.getAbsolutePath()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Context context = <span class="keyword">null</span>;</span><br><span class="line">    File xml = <span class="keyword">new</span> File(dir, Constants.ApplicationContextXml);</span><br><span class="line">    File xmlCopy =</span><br><span class="line">            <span class="keyword">new</span> File(host.getConfigBaseFile(), cn.getBaseName() + <span class="string">".xml"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DeployedApplication deployedApp;</span><br><span class="line">    <span class="keyword">boolean</span> copyThisXml = isCopyXML();</span><br><span class="line">    <span class="keyword">boolean</span> deployThisXML = isDeployThisXML(dir, cn);</span><br><span class="line">    <span class="comment">//拿到Context 开始部署。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//实例化StandardContext</span></span><br><span class="line">        <span class="keyword">if</span> (deployThisXML &amp;&amp; xml.exists()) &#123;</span><br><span class="line">            <span class="comment">///解析这个context节点  就是解析xml</span></span><br><span class="line">            <span class="keyword">synchronized</span> (digesterLock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    context = (Context) digester.parse(xml);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(sm.getString(</span><br><span class="line">                            <span class="string">"hostConfig.deployDescriptor.error"</span>,</span><br><span class="line">                            xml), e);</span><br><span class="line">                    context = <span class="keyword">new</span> FailedContext();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    digester.reset();</span><br><span class="line">                    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        context = <span class="keyword">new</span> FailedContext();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copyThisXml == <span class="keyword">false</span> &amp;&amp; context <span class="keyword">instanceof</span> StandardContext) &#123;</span><br><span class="line">                <span class="comment">// Host is using default value. Context may override it.</span></span><br><span class="line">                copyThisXml = ((StandardContext) context).getCopyXML();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copyThisXml) &#123;</span><br><span class="line">                Files.copy(xml.toPath(), xmlCopy.toPath());</span><br><span class="line">                context.setConfigFile(xmlCopy.toURI().toURL());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                context.setConfigFile(xml.toURI().toURL());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!deployThisXML &amp;&amp; xml.exists()) &#123;</span><br><span class="line">            <span class="comment">// Block deployment as META-INF/context.xml may contain security</span></span><br><span class="line">            <span class="comment">// configuration necessary for a secure deployment.</span></span><br><span class="line">            log.error(sm.getString(<span class="string">"hostConfig.deployDescriptor.blocked"</span>,</span><br><span class="line">                    cn.getPath(), xml, xmlCopy));</span><br><span class="line">            context = <span class="keyword">new</span> FailedContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = (Context) Class.forName(contextClass).getConstructor().newInstance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(host.getConfigClass());</span><br><span class="line">        LifecycleListener listener = (LifecycleListener) clazz.getConstructor().newInstance();</span><br><span class="line">        context.addLifecycleListener(listener);</span><br><span class="line"></span><br><span class="line">        context.setName(cn.getName());</span><br><span class="line">        context.setPath(cn.getPath());</span><br><span class="line">        context.setWebappVersion(cn.getVersion());</span><br><span class="line">        context.setDocBase(cn.getBaseName());</span><br><span class="line">        <span class="comment">//解析完成添加到Host中，进而把Context启动</span></span><br><span class="line">        host.addChild(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.error(sm.getString(<span class="string">"hostConfig.deployDir.error"</span>,</span><br><span class="line">                dir.getAbsolutePath()), t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        deployedApp = <span class="keyword">new</span> DeployedApplication(cn.getName(),</span><br><span class="line">                xml.exists() &amp;&amp; deployThisXML &amp;&amp; copyThisXml);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fake re-deploy resource to detect if a WAR is added at a later</span></span><br><span class="line">        <span class="comment">// point</span></span><br><span class="line">        deployedApp.redeployResources.put(dir.getAbsolutePath() + <span class="string">".war"</span>,</span><br><span class="line">                Long.valueOf(<span class="number">0</span>));</span><br><span class="line">        deployedApp.redeployResources.put(dir.getAbsolutePath(),</span><br><span class="line">                Long.valueOf(dir.lastModified()));</span><br><span class="line">        <span class="keyword">if</span> (deployThisXML &amp;&amp; xml.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copyThisXml) &#123;</span><br><span class="line">                deployedApp.redeployResources.put(</span><br><span class="line">                        xmlCopy.getAbsolutePath(),</span><br><span class="line">                        Long.valueOf(xmlCopy.lastModified()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                deployedApp.redeployResources.put(</span><br><span class="line">                        xml.getAbsolutePath(),</span><br><span class="line">                        Long.valueOf(xml.lastModified()));</span><br><span class="line">                <span class="comment">// Fake re-deploy resource to detect if a context.xml file is</span></span><br><span class="line">                <span class="comment">// added at a later point</span></span><br><span class="line">                deployedApp.redeployResources.put(</span><br><span class="line">                        xmlCopy.getAbsolutePath(),</span><br><span class="line">                        Long.valueOf(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Fake re-deploy resource to detect if a context.xml file is</span></span><br><span class="line">            <span class="comment">// added at a later point</span></span><br><span class="line">            deployedApp.redeployResources.put(</span><br><span class="line">                    xmlCopy.getAbsolutePath(),</span><br><span class="line">                    Long.valueOf(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (!xml.exists()) &#123;</span><br><span class="line">                deployedApp.redeployResources.put(</span><br><span class="line">                        xml.getAbsolutePath(),</span><br><span class="line">                        Long.valueOf(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addWatchedResources(deployedApp, dir.getAbsolutePath(), context);</span><br><span class="line">        <span class="comment">// Add the global redeploy resources (which are never deleted) at</span></span><br><span class="line">        <span class="comment">// the end so they don't interfere with the deletion process</span></span><br><span class="line">        addGlobalRedeployResources(deployedApp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deployed.put(cn.getName(), deployedApp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( log.isInfoEnabled() ) &#123;</span><br><span class="line">        log.info(sm.getString(<span class="string">"hostConfig.deployDir.finished"</span>,</span><br><span class="line">                dir.getAbsolutePath(), Long.valueOf(System.currentTimeMillis() - startTime)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>前面context部署完成后启动,StandardContext类中的启动方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Starting "</span> + getBaseName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send j2ee.state.starting notification</span></span><br><span class="line">    <span class="comment">//发布启动状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getObjectName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Notification notification = <span class="keyword">new</span> Notification(<span class="string">"j2ee.state.starting"</span>,</span><br><span class="line">                <span class="keyword">this</span>.getObjectName(), sequenceNumber.getAndIncrement());</span><br><span class="line">        broadcaster.sendNotification(notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setConfigured(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">boolean</span> ok = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Currently this is effectively a NO-OP but needs to be called to ensure the NamingResources follows the correct lifecycle</span></span><br><span class="line">    <span class="comment">//启动命名空间资源</span></span><br><span class="line">    <span class="keyword">if</span> (namingResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        namingResources.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post work directory 工作目录</span></span><br><span class="line">    postWorkDirectory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加资源组件</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源有4种:</span></span><br><span class="line"><span class="comment">     * Context.xml中的 &lt;PrePresource&gt;&lt;/PrePresource&gt;</span></span><br><span class="line"><span class="comment">     * WEB-INF/lib</span></span><br><span class="line"><span class="comment">     * Jar:&lt;JarResource&gt;&lt;/JarResource&gt;</span></span><br><span class="line"><span class="comment">     * post:&lt;PostResource&gt;&lt;/PostResource&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (getResources() == <span class="keyword">null</span>) &#123;   <span class="comment">// (1) Required by Loader</span></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">            log.debug(<span class="string">"Configuring default Resources"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setResources(<span class="keyword">new</span> StandardRoot(<span class="keyword">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"standardContext.resourcesInit"</span>), e);</span><br><span class="line">            ok = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        <span class="comment">//启动资源</span></span><br><span class="line">        resourcesStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载webapp 加载器 父类是shareClassLoader</span></span><br><span class="line">    <span class="keyword">if</span> (getLoader() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        WebappLoader webappLoader = <span class="keyword">new</span> WebappLoader();</span><br><span class="line">        webappLoader.setDelegate(getDelegate());</span><br><span class="line">        setLoader(webappLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An explicit cookie processor hasn't been specified; use the default</span></span><br><span class="line">    <span class="keyword">if</span> (cookieProcessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//初始化cookie</span></span><br><span class="line">        cookieProcessor = <span class="keyword">new</span> Rfc6265CookieProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化字符集映射器</span></span><br><span class="line">    getCharsetMapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate required extensions</span></span><br><span class="line">    <span class="keyword">boolean</span> dependencyCheck = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dependencyCheck = ExtensionValidator.validateApplication</span><br><span class="line">            (getResources(), <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"standardContext.extensionValidationError"</span>), ioe);</span><br><span class="line">        dependencyCheck = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查依赖</span></span><br><span class="line">    <span class="keyword">if</span> (!dependencyCheck) &#123;</span><br><span class="line">        <span class="comment">// do not make application available if dependency check fails</span></span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取“catalina.useNaming”环境变量</span></span><br><span class="line">    String useNamingProperty = System.getProperty(<span class="string">"catalina.useNaming"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((useNamingProperty != <span class="keyword">null</span>)</span><br><span class="line">        &amp;&amp; (useNamingProperty.equals(<span class="string">"false"</span>))) &#123;</span><br><span class="line">        useNaming = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok &amp;&amp; isUseNaming()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getNamingContextListener() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            NamingContextListener ncl = <span class="keyword">new</span> NamingContextListener();</span><br><span class="line">            ncl.setName(getNamingContextName());</span><br><span class="line">            ncl.setExceptionOnFailedWrite(getJndiExceptionOnFailedWrite());</span><br><span class="line">            addLifecycleListener(ncl);</span><br><span class="line">            setNamingContextListener(ncl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准容器启动</span></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">        log.debug(<span class="string">"Processing standard container startup"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binding thread</span></span><br><span class="line">    ClassLoader oldCCL = bindThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            <span class="comment">// 启动我们的下属组件（如果有）</span></span><br><span class="line">            Loader loader = getLoader();</span><br><span class="line">            <span class="keyword">if</span> (loader <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">                ((Lifecycle) loader).start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// since the loader just started, the webapp classloader is now</span></span><br><span class="line">            <span class="comment">// created.</span></span><br><span class="line">            <span class="comment">//类加载器属性设置</span></span><br><span class="line">            setClassLoaderProperty(<span class="string">"clearReferencesRmiTargets"</span>,</span><br><span class="line">                    getClearReferencesRmiTargets());</span><br><span class="line">            setClassLoaderProperty(<span class="string">"clearReferencesStopThreads"</span>,</span><br><span class="line">                    getClearReferencesStopThreads());</span><br><span class="line">            setClassLoaderProperty(<span class="string">"clearReferencesStopTimerThreads"</span>,</span><br><span class="line">                    getClearReferencesStopTimerThreads());</span><br><span class="line">            setClassLoaderProperty(<span class="string">"clearReferencesHttpClientKeepAliveThread"</span>,</span><br><span class="line">                    getClearReferencesHttpClientKeepAliveThread());</span><br><span class="line">            setClassLoaderProperty(<span class="string">"clearReferencesObjectStreamClassCaches"</span>,</span><br><span class="line">                    getClearReferencesObjectStreamClassCaches());</span><br><span class="line">            setClassLoaderProperty(<span class="string">"clearReferencesThreadLocals"</span>,</span><br><span class="line">                    getClearReferencesThreadLocals());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// By calling unbindThread and bindThread in a row, we setup the</span></span><br><span class="line">            <span class="comment">// current Thread CCL to be the webapp classloader</span></span><br><span class="line">            unbindThread(oldCCL);</span><br><span class="line">            oldCCL = bindThread();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize logger again. Other components might have used it too early, so it should be reset.</span></span><br><span class="line">            logger = <span class="keyword">null</span>;</span><br><span class="line">            getLogger();</span><br><span class="line">            <span class="comment">//域设置</span></span><br><span class="line">            Realm realm = getRealmInternal();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != realm) &#123;</span><br><span class="line">                <span class="keyword">if</span> (realm <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">                    ((Lifecycle) realm).start();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Place the CredentialHandler into the ServletContext so</span></span><br><span class="line">                <span class="comment">// applications can have access to it. Wrap it in a "safe"</span></span><br><span class="line">                <span class="comment">// handler so application's can't modify it.</span></span><br><span class="line">                CredentialHandler safeHandler = <span class="keyword">new</span> CredentialHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String inputCredentials, String storedCredentials)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> getRealmInternal().getCredentialHandler().matches(inputCredentials, storedCredentials);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">mutate</span><span class="params">(String inputCredentials)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> getRealmInternal().getCredentialHandler().mutate(inputCredentials);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                context.setAttribute(Globals.CREDENTIAL_HANDLER, safeHandler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送一个生命周期事件，之后，ContextConfig就会启动了  和之前Host套路一致,,调用ContextConfig的webConfig方法</span></span><br><span class="line">            fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动子容器</span></span><br><span class="line">            <span class="keyword">for</span> (Container child : findChildren()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!child.getState().isAvailable()) &#123;</span><br><span class="line">                    child.start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动我们管道中的阀门（包括基本阀门），</span></span><br><span class="line">            <span class="keyword">if</span> (pipeline <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">                ((Lifecycle) pipeline).start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取群集管理器</span></span><br><span class="line">            Manager contextManager = <span class="keyword">null</span>;</span><br><span class="line">            Manager manager = getManager();</span><br><span class="line">            <span class="keyword">if</span> (manager == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(sm.getString(<span class="string">"standardContext.cluster.noManager"</span>,</span><br><span class="line">                            Boolean.valueOf((getCluster() != <span class="keyword">null</span>)),</span><br><span class="line">                            Boolean.valueOf(distributable)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((getCluster() != <span class="keyword">null</span>) &amp;&amp; distributable) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        contextManager = getCluster().createManager(getName());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        log.error(<span class="string">"standardContext.clusterFail"</span>, ex);</span><br><span class="line">                        ok = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    contextManager = <span class="keyword">new</span> StandardManager();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Configure default manager if none was specified</span></span><br><span class="line">            <span class="keyword">if</span> (contextManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(sm.getString(<span class="string">"standardContext.manager"</span>,</span><br><span class="line">                            contextManager.getClass().getName()));</span><br><span class="line">                &#125;</span><br><span class="line">                setManager(contextManager);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (manager!=<span class="keyword">null</span> &amp;&amp; (getCluster() != <span class="keyword">null</span>) &amp;&amp; distributable) &#123;</span><br><span class="line">                <span class="comment">//let the cluster know that there is a context that is distributable</span></span><br><span class="line">                <span class="comment">//and that it has its own manager</span></span><br><span class="line">                getCluster().registerManager(manager);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!getConfigured()) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"standardContext.configurationFail"</span>));</span><br><span class="line">            ok = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取资源，并且加入到上下文中</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            getServletContext().setAttribute</span><br><span class="line">                (Globals.RESOURCES_ATTR, getResources());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (getInstanceManager() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                javax.naming.Context context = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (isUseNaming() &amp;&amp; getNamingContextListener() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    context = getNamingContextListener().getEnvContext();</span><br><span class="line">                &#125;</span><br><span class="line">                Map&lt;String, Map&lt;String, String&gt;&gt; injectionMap = buildInjectionMap(</span><br><span class="line">                        getIgnoreAnnotations() ? <span class="keyword">new</span> NamingResourcesImpl(): getNamingResources());</span><br><span class="line">                setInstanceManager(<span class="keyword">new</span> DefaultInstanceManager(context,</span><br><span class="line">                        injectionMap, <span class="keyword">this</span>, <span class="keyword">this</span>.getClass().getClassLoader()));</span><br><span class="line">            &#125;</span><br><span class="line">            getServletContext().setAttribute(</span><br><span class="line">                    InstanceManager<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">getInstanceManager</span>())</span>;</span><br><span class="line">            InstanceManagerBindings.bind(getLoader().getClassLoader(), getInstanceManager());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建所需的上下文属性</span></span><br><span class="line">            getServletContext().setAttribute(</span><br><span class="line">                    JarScanner<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">getJarScanner</span>())</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make the version info available</span></span><br><span class="line">            getServletContext().setAttribute(Globals.WEBAPP_VERSION, getWebappVersion());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up the context init params</span></span><br><span class="line">        mergeParameters();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call ServletContainerInitializers</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">            initializers.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建application context</span></span><br><span class="line">                entry.getKey().onStartup(entry.getValue(),</span><br><span class="line">                        getServletContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">"standardContext.sciFail"</span>), e);</span><br><span class="line">                ok = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure and call application event listeners</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!listenerStart()) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">"standardContext.listenerFail"</span>));</span><br><span class="line">                ok = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check constraints for uncovered HTTP methods</span></span><br><span class="line">        <span class="comment">// Needs to be after SCIs and listeners as they may programmatically</span></span><br><span class="line">        <span class="comment">// change constraints</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            checkConstraintsForUncoveredMethods(findConstraints());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Start manager</span></span><br><span class="line">            Manager manager = getManager();</span><br><span class="line">            <span class="keyword">if</span> (manager <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">                ((Lifecycle) manager).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"standardContext.managerFail"</span>), e);</span><br><span class="line">            ok = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure and call application filters</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!filterStart()) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">"standardContext.filterFail"</span>));</span><br><span class="line">                ok = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load and initialize all "load on startup" servlets</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadOnStartup(findChildren()))&#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">"standardContext.servletFail"</span>));</span><br><span class="line">                ok = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start ContainerBackgroundProcessor thread</span></span><br><span class="line">        <span class="keyword">super</span>.threadStart();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Unbinding thread</span></span><br><span class="line">        unbindThread(oldCCL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set available status depending upon startup success</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">            log.debug(<span class="string">"Starting completed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(sm.getString(<span class="string">"standardContext.startFailed"</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startTime=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send j2ee.state.running notification</span></span><br><span class="line">    <span class="keyword">if</span> (ok &amp;&amp; (<span class="keyword">this</span>.getObjectName() != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        Notification notification =</span><br><span class="line">            <span class="keyword">new</span> Notification(<span class="string">"j2ee.state.running"</span>, <span class="keyword">this</span>.getObjectName(),</span><br><span class="line">                             sequenceNumber.getAndIncrement());</span><br><span class="line">        broadcaster.sendNotification(notification);</span><br><span class="line">    &#125;</span><br><span class="line">    getResources().gc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reinitializing if something went wrong</span></span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">        setState(LifecycleState.FAILED);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setState(LifecycleState.STARTING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面设置生命周期状态后，启动监听器，会执行ContextConfig中的webConfig()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">webConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析每个项目的web.xml  web3.0后有注解方式，所以有两种，有web.xml的情况，解析它，还要解析注解。</span></span><br><span class="line">    WebXmlParser webXmlParser = <span class="keyword">new</span> WebXmlParser(context.getXmlNamespaceAware(),</span><br><span class="line">            context.getXmlValidation(), context.getXmlBlockExternal());</span><br><span class="line"></span><br><span class="line">    Set&lt;WebXml&gt; defaults = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    defaults.add(getDefaultWebXmlFragment(webXmlParser));</span><br><span class="line"></span><br><span class="line">    WebXml webXml = createWebXml();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 web.xml</span></span><br><span class="line">    InputSource contextWebXml = getContextWebXmlSource();</span><br><span class="line">    <span class="keyword">if</span> (!webXmlParser.parseWebXml(contextWebXml, webXml, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServletContext sContext = context.getServletContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1. Identify all the JARs packaged with the application and those provided by the container. If any of the application JARs have a web-fragment.xml</span></span><br><span class="line">    <span class="comment">// it will be parsed at this point. web-fragment.xml files are ignored for container provided JARs.</span></span><br><span class="line">    Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(webXml, webXmlParser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2. Order the fragments.</span></span><br><span class="line">    Set&lt;WebXml&gt; orderedFragments = <span class="keyword">null</span>;</span><br><span class="line">    orderedFragments =</span><br><span class="line">            WebXml.orderWebFragments(webXml, fragments, sContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3. Look for ServletContainerInitializer implementations</span></span><br><span class="line">    <span class="comment">// 锁定servlet容器</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        processServletContainerInitializers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  (!webXml.isMetadataComplete() || typeInitializerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Steps 4 &amp; 5. 把web资源加载进来</span></span><br><span class="line">        processClasses(webXml, orderedFragments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!webXml.isMetadataComplete()) &#123;</span><br><span class="line">        <span class="comment">// Step 6. Merge web-fragment.xml files into the main web.xml</span></span><br><span class="line">        <span class="comment">//将web-fragment.xml文件合并到主web.xml中</span></span><br><span class="line">        <span class="comment">// file.</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            ok = webXml.merge(orderedFragments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 7. Apply global defaults Have to merge defaults before JSP conversion since defaults provide JSP servlet definition.</span></span><br><span class="line">        webXml.merge(defaults);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 8. Convert explicitly mentioned jsps to servlets</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            convertJsps(webXml);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 9. Apply merged web.xml to Context</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            configureContext(webXml);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        webXml.merge(defaults);</span><br><span class="line">        convertJsps(webXml);</span><br><span class="line">        configureContext(webXml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.getLogEffectiveWebXml()) &#123;</span><br><span class="line">        log.info(<span class="string">"web.xml:\n"</span> + webXml.toXml());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always need to look for static resources</span></span><br><span class="line">    <span class="comment">//查找打包在jar中的静态资源</span></span><br><span class="line">    <span class="comment">// Step 10. Look for static resources packaged in JARs</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        <span class="comment">// Spec does not define an order. Use ordered JARs followed by remaining JARs</span></span><br><span class="line">        Set&lt;WebXml&gt; resourceJars = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (WebXml fragment : orderedFragments) &#123;</span><br><span class="line">            resourceJars.add(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (WebXml fragment : fragments.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!resourceJars.contains(fragment)) &#123;</span><br><span class="line">                resourceJars.add(fragment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        processResourceJARs(resourceJars);</span><br><span class="line">        <span class="comment">// See also StandardContext.resourcesStart() for</span></span><br><span class="line">        <span class="comment">// WEB-INF/classes/META-INF/resources configuration</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 11. Apply the ServletContainerInitializer config to the</span></span><br><span class="line">    <span class="comment">// context</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer,</span><br><span class="line">                Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">                    initializerClassMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue().isEmpty()) &#123;</span><br><span class="line">                context.addServletContainerInitializer(</span><br><span class="line">                        entry.getKey(), <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                context.addServletContainerInitializer(</span><br><span class="line">                        entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processClasses</span><span class="params">(WebXml webXml, Set&lt;WebXml&gt; orderedFragments)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Step 4. Process /WEB-INF/classes for annotations and</span></span><br><span class="line">    <span class="comment">// @HandlesTypes matches</span></span><br><span class="line">    Map&lt;String, JavaClassCacheEntry&gt; javaClassCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        <span class="comment">///WEB-INF/classes下所有资源</span></span><br><span class="line">        WebResource[] webResources =</span><br><span class="line">                context.getResources().listResources(<span class="string">"/WEB-INF/classes"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (WebResource webResource : webResources) &#123;</span><br><span class="line">            <span class="comment">// Skip the META-INF directory from any JARs that have been</span></span><br><span class="line">            <span class="comment">// expanded in to WEB-INF/classes (sometimes IDEs do this).</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"META-INF"</span>.equals(webResource.getName())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理注解的资源</span></span><br><span class="line">            processAnnotationsWebResource(webResource, webXml,</span><br><span class="line">                    webXml.isMetadataComplete(), javaClassCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5. Process JARs for annotations and</span></span><br><span class="line">    <span class="comment">// @HandlesTypes matches - only need to process those fragments we</span></span><br><span class="line">    <span class="comment">// are going to use (remember orderedFragments includes any</span></span><br><span class="line">    <span class="comment">// container fragments)</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        processAnnotations(</span><br><span class="line">                orderedFragments, webXml.isMetadataComplete(), javaClassCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache, if used, is no longer required so clear it</span></span><br><span class="line">    javaClassCache.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send j2ee.state.starting notification 发送监听通知</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getObjectName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Notification notification = <span class="keyword">new</span> Notification(<span class="string">"j2ee.state.starting"</span>,</span><br><span class="line">                                                    <span class="keyword">this</span>.getObjectName(),</span><br><span class="line">                                                    sequenceNumber++);</span><br><span class="line">        broadcaster.sendNotification(notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行父类方法</span></span><br><span class="line">    <span class="keyword">super</span>.startInternal();</span><br><span class="line"></span><br><span class="line">    setAvailable(<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send j2ee.state.running notification</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getObjectName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Notification notification =</span><br><span class="line">            <span class="keyword">new</span> Notification(<span class="string">"j2ee.state.running"</span>, <span class="keyword">this</span>.getObjectName(),</span><br><span class="line">                            sequenceNumber++);</span><br><span class="line">        broadcaster.sendNotification(notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    instance = loadServlet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!instanceInitialized) &#123;</span><br><span class="line">        initServlet(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isJspServlet) &#123;</span><br><span class="line">        StringBuilder oname = <span class="keyword">new</span> StringBuilder(getDomain());</span><br><span class="line"></span><br><span class="line">        oname.append(<span class="string">":type=JspMonitor"</span>);</span><br><span class="line"></span><br><span class="line">        oname.append(getWebModuleKeyProperties());</span><br><span class="line"></span><br><span class="line">        oname.append(<span class="string">",name="</span>);</span><br><span class="line">        oname.append(getName());</span><br><span class="line"></span><br><span class="line">        oname.append(getJ2EEKeyProperties());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jspMonitorON = <span class="keyword">new</span> ObjectName(oname.toString());</span><br><span class="line">            Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(instance, jspMonitorON, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.warn(<span class="string">"Error registering JSP monitoring with jmx "</span> + instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动子容器流程如下：<br><img src="https://img.huyunshun.com/img/20200405213810.png" alt="20200405213810"></p>

          
        
      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2018/09/01/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/01/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" itemprop="url">Tomcat源码环境idea配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-01T00:00:00+08:00">
                2018-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a> 下载源码，解压。</p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>新建一个目录，把解压好的文件目录复制进去，新建一个文件，主要把源代码里面的conf复制，其他随意，结果是这个样子：（也可以不用分离，分离开好管理）</p>
<p><img src="https://img.huyunshun.com/img/20200404225435.png" alt="20200404225435"></p>
<p>在外层目录新建pom文件，让源代码目录成为idea的模块。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.huf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apache-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>apache-tomcat-source<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>apache-tomcat-8.5.53-src<span class="tag">&lt;/<span class="name">module</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在源码中新建pom文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Tomcat8.5.53<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Tomcat8.5.53<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>Tomcat8.5<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>test<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>test<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">    </span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.easymock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easymock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>wsdl4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wsdl4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxrpc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ecj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>在idea中打开，自动状态maven项目。</p>
<p><img src="https://img.huyunshun.com/img/20200404232607.png" alt="20200404232607"></p>
<p>catalina目录是运行环境，构建完成后配置运行环境。</p>
<p>新建配置</p>
<p><img src="https://img.huyunshun.com/img/20200404230428.png" alt="20200404230428"></p>
<p>配置如下：</p>
<p><img src="https://img.huyunshun.com/img/20200404232546.png" alt="20200404232546"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home&#x3D;catalina</span><br><span class="line">-Dcatalina.base&#x3D;catalina</span><br><span class="line">-Djava.endorsed.dirs&#x3D;catalina&#x2F;endorsed</span><br><span class="line">-Djava.io.tmpdir&#x3D;catalina&#x2F;temp</span><br><span class="line">-Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file&#x3D;catalina&#x2F;conf&#x2F;logging.properties</span><br><span class="line">-Dfile.encoding&#x3D;UTF-8</span><br></pre></td></tr></table></figure>

<p>启动，开始构建，构建过程如果test报错，把pom中的test移除。</p>
<p>启动成功后，浏览，报错HTTP Status 500 â Internal Server Error</p>
<p>这是因为8以后版本，JSP引擎没有初始化进去，手动增加代码初始化：</p>
<p>org/apache/catalina/startup/ContextConfig.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webConfig();</span><br><span class="line"><span class="comment">//添加初始化JasperInitializer</span></span><br><span class="line">context.addServletContainerInitializer(<span class="keyword">new</span> JasperInitializer(), <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.huyunshun.com/img/20200404232406.png" alt="20200404232406"><br>重启后，即可。<br><img src="https://img.huyunshun.com/img/20200404232341.png" alt="20200404232341"></p>

          
        
      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/13/">下一页</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://img.huyunshun.com/img/20200522182348.png"
                alt="初晨" />
            
              <p class="site-author-name" itemprop="name">初晨</p>
              <p class="site-description motion-element" itemprop="description">永远不要说你知道本质，更别说真相了。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">249</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">109</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
<!--近期文章版块-->
            
                <div class="links-of-blogroll motion-element links-of-blogroll-block">
                  <div class="links-of-blogroll-title">
                    <!-- modify icon to fire by szw -->
                    <i class="fa fa-history fa-" aria-hidden="true"></i>
                    近期文章
                  </div>
                  <ul class="links-of-blogroll-list">
                    
                    
                      <li>
                        <a href="/2020/05/22/WebSocket%E3%80%81Socket%E3%80%81TCP%E3%80%81HTTP%E5%8C%BA%E5%88%AB/" title="WebSocket、Socket、TCP、HTTP区别" target="_blank">WebSocket、Socket、TCP、HTTP区别</a>
                      </li>
                    
                      <li>
                        <a href="/2020/05/19/Springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E9%98%B2%E5%88%B7/" title="Springboot项目的接口防刷" target="_blank">Springboot项目的接口防刷</a>
                      </li>
                    
                      <li>
                        <a href="/2020/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="深入理解Volatile关键字及其实现原理" target="_blank">深入理解Volatile关键字及其实现原理</a>
                      </li>
                    
                      <li>
                        <a href="/2020/04/20/%E4%BD%BF%E7%94%A8vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83/" title="使用vscode搭建个人笔记环境" target="_blank">使用vscode搭建个人笔记环境</a>
                      </li>
                    
                      <li>
                        <a href="/2020/01/20/HBase%E4%BB%8B%E7%BB%8D%E5%AE%89%E8%A3%85%E4%B8%8E%E6%93%8D%E4%BD%9C/" title="HBase介绍安装与操作" target="_blank">HBase介绍安装与操作</a>
                      </li>
                    
                  </ul>
                </div>
            
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Copyright</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


</body>
</html>
