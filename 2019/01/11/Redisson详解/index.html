<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Redisson," />










<meta name="description" content="一、介绍Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore,">
<meta property="og:type" content="article">
<meta property="og:title" content="Redisson详解">
<meta property="og:url" content="https://huyunshun.com/2019/01/11/Redisson%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="简">
<meta property="og:description" content="一、介绍Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore,">
<meta property="og:image" content="https://img.huyunshun.com/img/20200423150409.png">
<meta property="article:published_time" content="2019-01-10T16:00:00.000Z">
<meta property="article:modified_time" content="2020-05-20T10:04:24.712Z">
<meta property="article:author" content="初晨">
<meta property="article:tag" content="Redisson">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.huyunshun.com/img/20200423150409.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://huyunshun.com/2019/01/11/Redisson详解/"/>





  <title>Redisson详解 | 简</title>
  








  <script type="text/javascript" src="/js/src/love.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

  <!-- 看板娘 -->
    
        <script async src="/live2d-widget/autoload.js"></script>
    
 <!-- 飘动的彩带） -->
  <script src="/js/src/piao.js" type="text/javascript"></script>
<meta name="generator" content="Hexo 4.2.1"></head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">简</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">人生短暂，学海无边，而大道至简。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huyunshun.com/2019/01/11/Redisson%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="初晨">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://img.huyunshun.com/img/20200522182348.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redisson详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T00:00:00+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。</p>
<p>Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><h3 id="1、程序配置方式"><a href="#1、程序配置方式" class="headerlink" title="1、程序配置方式"></a>1、程序配置方式</h3><p>通过类代码来构建配置：通过构建Config对象实例来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.setTransportMode(TransportMode.EPOLL);</span><br><span class="line">config.useClusterServers()</span><br><span class="line">      <span class="comment">//可以用"rediss://"来启用SSL连接</span></span><br><span class="line">      .addNodeAddress(<span class="string">"redis://127.0.0.1:7181"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2、配置文件方式"><a href="#2、配置文件方式" class="headerlink" title="2、配置文件方式"></a>2、配置文件方式</h3><p>Redisson的配置文件可以是JSON格式或YAML格式。 可以通过调用Config.fromJSON方法并指定一个File实例来实现读取JSON格式的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Config config &#x3D; Config.fromJSON(new File(&quot;config-file.json&quot;));</span><br><span class="line">RedissonClient redisson &#x3D; Redisson.create(config);</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Config config &#x3D; Config.fromYAML(new File(&quot;config-file.yaml&quot;));</span><br><span class="line">RedissonClient redisson &#x3D; Redisson.create(config);</span><br></pre></td></tr></table></figure>
<p> 通过Spring XML命名空间配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client&gt;</span><br><span class="line">    &lt;redisson:single-server ... &#x2F;&gt;</span><br><span class="line">    &lt;!-- 或者 --&gt;</span><br><span class="line">    &lt;redisson:master-slave-servers ... &#x2F;&gt;</span><br><span class="line">    &lt;!-- 或者 --&gt;</span><br><span class="line">    &lt;redisson:sentinel-servers ... &#x2F;&gt;</span><br><span class="line">    &lt;!-- 或者 --&gt;</span><br><span class="line">    &lt;redisson:cluster-servers ... &#x2F;&gt;</span><br><span class="line">    &lt;!-- 或者 --&gt;</span><br><span class="line">    &lt;redisson:replicated-servers ... &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3、常用设置"><a href="#3、常用设置" class="headerlink" title="3、常用设置"></a>3、常用设置</h3><p>以下是关于org.redisson.Config类的配置参数，它适用于所有Redis组态模式（单机，集群和哨兵）</p>
<h4 id="codec（编码）"><a href="#codec（编码）" class="headerlink" title="codec（编码）"></a>codec（编码）</h4><p>默认值: org.redisson.codec.JsonJacksonCodec</p>
<p>可选：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">编码类名称	说明</span><br><span class="line">org.redisson.codec.JsonJacksonCodec	Jackson JSON 编码 默认编码</span><br><span class="line">org.redisson.codec.AvroJacksonCodec	Avro 一个二进制的JSON编码</span><br><span class="line">org.redisson.codec.SmileJacksonCodec	Smile 另一个二进制的JSON编码</span><br><span class="line">org.redisson.codec.CborJacksonCodec	CBOR 又一个二进制的JSON编码</span><br><span class="line">org.redisson.codec.MsgPackJacksonCodec	MsgPack 再来一个二进制的JSON编码</span><br><span class="line">org.redisson.codec.IonJacksonCodec	Amazon Ion 亚马逊的Ion编码，格式与JSON类似</span><br><span class="line">org.redisson.codec.KryoCodec	Kryo 二进制对象序列化编码</span><br><span class="line">org.redisson.codec.SerializationCodec	JDK序列化编码</span><br><span class="line">org.redisson.codec.FstCodec	FST 10倍于JDK序列化性能而且100%兼容的编码</span><br><span class="line">org.redisson.codec.LZ4Codec	LZ4 压缩型序列化对象编码</span><br><span class="line">org.redisson.codec.SnappyCodec	Snappy 另一个压缩型序列化对象编码</span><br><span class="line">org.redisson.client.codec.JsonJacksonMapCodec	基于Jackson的映射类使用的编码。可用于避免序列化类的信息，以及用于解决使用byte[]遇到的问题。</span><br><span class="line">org.redisson.client.codec.StringCodec	纯字符串编码（无转换）</span><br><span class="line">org.redisson.client.codec.LongCodec	纯整长型数字编码（无转换）</span><br><span class="line">org.redisson.client.codec.ByteArrayCodec	字节数组编码</span><br><span class="line">org.redisson.codec.CompositeCodec	用来组合多种不同编码在一起</span><br></pre></td></tr></table></figure>
<h4 id="threads（线程池数量）"><a href="#threads（线程池数量）" class="headerlink" title="threads（线程池数量）"></a>threads（线程池数量）</h4><p>默认值: 当前处理核数量 * 2</p>
<p>这个线程池数量被所有RTopic对象监听器，RRemoteService调用者和RExecutorService任务共同共享。</p>
<h4 id="nettyThreads-（Netty线程池数量）"><a href="#nettyThreads-（Netty线程池数量）" class="headerlink" title="nettyThreads （Netty线程池数量）"></a>nettyThreads （Netty线程池数量）</h4><p>默认值: 当前处理核数量 * 2</p>
<p>这个线程池数量是在一个Redisson实例内，被其创建的所有分布式数据类型和服务，以及底层客户端所一同共享的线程池里保存的线程数量。</p>
<h4 id="executor（线程池）"><a href="#executor（线程池）" class="headerlink" title="executor（线程池）"></a>executor（线程池）</h4><p>单独提供一个用来执行所有RTopic对象监听器，RRemoteService调用者和RExecutorService任务的线程池（ExecutorService）实例。</p>
<h4 id="eventLoopGroup"><a href="#eventLoopGroup" class="headerlink" title="eventLoopGroup"></a>eventLoopGroup</h4><p>用于特别指定一个EventLoopGroup. EventLoopGroup是用来处理所有通过Netty与Redis服务之间的连接发送和接受的消息。每一个Redisson都会在默认情况下自己创建管理一个EventLoopGroup实例。因此，如果在同一个JVM里面可能存在多个Redisson实例的情况下，采取这个配置实现多个Redisson实例共享一个EventLoopGroup的目的。</p>
<p>只有io.netty.channel.epoll.EpollEventLoopGroup或io.netty.channel.nio.NioEventLoopGroup才是允许的类型。</p>
<h4 id="transportMode（传输模式）"><a href="#transportMode（传输模式）" class="headerlink" title="transportMode（传输模式）"></a>transportMode（传输模式）</h4><p>默认值：TransportMode.NIO</p>
<p>可选参数：<br>TransportMode.NIO,<br>TransportMode.EPOLL - 需要依赖里有netty-transport-native-epoll包（Linux） TransportMode.KQUEUE - 需要依赖里有 netty-transport-native-kqueue包（macOS）</p>
<h4 id="lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）"><a href="#lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）" class="headerlink" title="lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）"></a>lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）</h4><p>默认值：30000</p>
<p>监控锁的看门狗超时时间单位为毫秒。该参数只适用于分布式锁的加锁请求中未明确使用leaseTimeout参数的情况。如果该看门口未使用lockWatchdogTimeout去重新调整一个分布式锁的lockWatchdogTimeout超时，那么这个锁将变为失效状态。这个参数可以用来避免由Redisson客户端节点宕机或其他原因造成死锁的情况。</p>
<h4 id="keepPubSubOrder（保持订阅发布顺序）"><a href="#keepPubSubOrder（保持订阅发布顺序）" class="headerlink" title="keepPubSubOrder（保持订阅发布顺序）"></a>keepPubSubOrder（保持订阅发布顺序）</h4><p>默认值：true</p>
<p>通过该参数来修改是否按订阅发布消息的接收顺序出来消息，如果选否将对消息实行并行处理，该参数只适用于订阅发布消息的情况。</p>
<h4 id="performanceMode（高性能模式）"><a href="#performanceMode（高性能模式）" class="headerlink" title="performanceMode（高性能模式）"></a>performanceMode（高性能模式）</h4><p>默认值：HIGHER_THROUGHPUT</p>
<p>用来指定高性能引擎的行为。由于该变量值的选用与使用场景息息相关（NORMAL除外）我们建议对每个参数值都进行尝试。</p>
<p>该参数仅限于Redisson PRO版本。</p>
<p>可选模式：<br>HIGHER_THROUGHPUT - 将高性能引擎切换到 高通量 模式。 LOWER_LATENCY_AUTO - 将高性能引擎切换到 低延时 模式并自动探测最佳设定。 LOWER_LATENCY_MODE_1 - 将高性能引擎切换到 低延时 模式并调整到预设模式1。 LOWER_LATENCY_MODE_2 - 将高性能引擎切换到 低延时 模式并调整到预设模式2。 NORMAL - 将高性能引擎切换到 普通 模式</p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><h3 id="1、程序方式"><a href="#1、程序方式" class="headerlink" title="1、程序方式"></a>1、程序方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useClusterServers()</span><br><span class="line">    .setScanInterval(<span class="number">2000</span>) <span class="comment">// 集群状态扫描间隔时间，单位是毫秒</span></span><br><span class="line">    <span class="comment">//可以用"rediss://"来启用SSL连接</span></span><br><span class="line">    .addNodeAddress(<span class="string">"redis://127.0.0.1:7000"</span>, <span class="string">"redis://127.0.0.1:7001"</span>)</span><br><span class="line">    .addNodeAddress(<span class="string">"redis://127.0.0.1:7002"</span>);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br></pre></td></tr></table></figure>
<h3 id="2、通过文件配置集群模式"><a href="#2、通过文件配置集群模式" class="headerlink" title="2、通过文件配置集群模式"></a>2、通过文件配置集群模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;clusterServersConfig&quot;:&#123;</span><br><span class="line">      &quot;idleConnectionTimeout&quot;:10000,</span><br><span class="line">      &quot;pingTimeout&quot;:1000,</span><br><span class="line">      &quot;connectTimeout&quot;:10000,</span><br><span class="line">      &quot;timeout&quot;:3000,</span><br><span class="line">      &quot;retryAttempts&quot;:3,</span><br><span class="line">      &quot;retryInterval&quot;:1500,</span><br><span class="line">      &quot;reconnectionTimeout&quot;:3000,</span><br><span class="line">      &quot;failedAttempts&quot;:3,</span><br><span class="line">      &quot;password&quot;:null,</span><br><span class="line">      &quot;subscriptionsPerConnection&quot;:5,</span><br><span class="line">      &quot;clientName&quot;:null,</span><br><span class="line">      &quot;loadBalancer&quot;:&#123;</span><br><span class="line">         &quot;class&quot;:&quot;org.redisson.connection.balancer.RoundRobinLoadBalancer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;slaveSubscriptionConnectionMinimumIdleSize&quot;:1,</span><br><span class="line">      &quot;slaveSubscriptionConnectionPoolSize&quot;:50,</span><br><span class="line">      &quot;slaveConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;slaveConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;masterConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;masterConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;readMode&quot;:&quot;SLAVE&quot;,</span><br><span class="line">      &quot;nodeAddresses&quot;:[</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:7004&quot;,</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:7001&quot;,</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:7000&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;scanInterval&quot;:1000</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;threads&quot;:0,</span><br><span class="line">   &quot;nettyThreads&quot;: 0,</span><br><span class="line">   &quot;codec&quot;:&#123;</span><br><span class="line">      &quot;class&quot;:&quot;org.redisson.codec.JsonJacksonCodec&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;transportMode&quot;:&quot;NIO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">clusterServersConfig:</span><br><span class="line">  idleConnectionTimeout: 10000</span><br><span class="line">  pingTimeout: 1000</span><br><span class="line">  connectTimeout: 10000</span><br><span class="line">  timeout: 3000</span><br><span class="line">  retryAttempts: 3</span><br><span class="line">  retryInterval: 1500</span><br><span class="line">  reconnectionTimeout: 3000</span><br><span class="line">  failedAttempts: 3</span><br><span class="line">  password: null</span><br><span class="line">  subscriptionsPerConnection: 5</span><br><span class="line">  clientName: null</span><br><span class="line">  loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; &#123;&#125;</span><br><span class="line">  slaveSubscriptionConnectionMinimumIdleSize: 1</span><br><span class="line">  slaveSubscriptionConnectionPoolSize: 50</span><br><span class="line">  slaveConnectionMinimumIdleSize: 32</span><br><span class="line">  slaveConnectionPoolSize: 64</span><br><span class="line">  masterConnectionMinimumIdleSize: 32</span><br><span class="line">  masterConnectionPoolSize: 64</span><br><span class="line">  readMode: &quot;SLAVE&quot;</span><br><span class="line">  nodeAddresses:</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:7004&quot;</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:7001&quot;</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:7000&quot;</span><br><span class="line">  scanInterval: 1000</span><br><span class="line">threads: 0</span><br><span class="line">nettyThreads: 0</span><br><span class="line">codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;</span><br><span class="line">&quot;transportMode&quot;:&quot;NIO&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client</span><br><span class="line">    id&#x3D;&quot;redisson&quot;</span><br><span class="line">    name&#x3D;&quot;redisson1,redisson2&quot;</span><br><span class="line">    threads&#x3D;&quot;0&quot;</span><br><span class="line">    netty-threads&#x3D;&quot;0&quot;</span><br><span class="line">    codec-ref&#x3D;&quot;myCodec&quot; </span><br><span class="line">    transport-mode&#x3D;&quot;NIO&quot;</span><br><span class="line">    redisson-reference-enabled&#x3D;&quot;true&quot;</span><br><span class="line">    codec-provider-ref&#x3D;&quot;myCodecProvider&quot;</span><br><span class="line">    resolver-provider-ref&#x3D;&quot;myResolverProvider&quot;</span><br><span class="line">    executor-ref&#x3D;&quot;myExecutor&quot;</span><br><span class="line">    event-loop-group-ref&#x3D;&quot;myEventLoopGroup&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    这里的name属性和qualifier子元素不能同时使用。</span><br><span class="line"></span><br><span class="line">    id和name的属性都可以被用来作为qualifier的备选值。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--&lt;qualifier value&#x3D;&quot;redisson3&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    &lt;redisson:cluster-servers</span><br><span class="line">        idle-connection-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        ping-timeout&#x3D;&quot;1000&quot;</span><br><span class="line">        connect-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        retry-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        retry-interval&#x3D;&quot;1500&quot;</span><br><span class="line">        reconnection-timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        failed-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        password&#x3D;&quot;do_not_use_if_it_is_not_set&quot;</span><br><span class="line">        subscriptions-per-connection&#x3D;&quot;5&quot;</span><br><span class="line">        client-name&#x3D;&quot;none&quot;</span><br><span class="line">        load-balancer-ref&#x3D;&quot;myLoadBalancer&quot;</span><br><span class="line">        subscription-connection-minimum-idle-size&#x3D;&quot;1&quot;</span><br><span class="line">        subscription-connection-pool-size&#x3D;&quot;50&quot;</span><br><span class="line">        slave-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        slave-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        master-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        master-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        read-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        subscription-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        scan-interval&#x3D;&quot;1000&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;redisson:cluster-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最基本配置 --&gt;</span><br><span class="line">&lt;redisson:client&gt;</span><br><span class="line">    &lt;redisson:cluster-servers&gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:node-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;&#x2F;redisson:cluster-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3、设置"><a href="#3、设置" class="headerlink" title="3、设置"></a>3、设置</h3><p>Redis集群组态的最低要求是必须有三个主节点。Redisson的集群模式的使用方法如下：ClusterServersConfig clusterConfig = config.useClusterServers();</p>
<p>ClusterServersConfig 类的设置参数如下：</p>
<h4 id="nodeAddresses（添加节点地址）"><a href="#nodeAddresses（添加节点地址）" class="headerlink" title="nodeAddresses（添加节点地址）"></a>nodeAddresses（添加节点地址）</h4><p>可以通过host:port的格式来添加Redis集群节点的地址。多个节点可以一次性批量添加。</p>
<h4 id="scanInterval（集群扫描间隔时间）"><a href="#scanInterval（集群扫描间隔时间）" class="headerlink" title="scanInterval（集群扫描间隔时间）"></a>scanInterval（集群扫描间隔时间）</h4><p>默认值： 1000</p>
<p>对Redis集群节点状态扫描的时间间隔。单位是毫秒。</p>
<h4 id="slots（分片数量）"><a href="#slots（分片数量）" class="headerlink" title="slots（分片数量）"></a>slots（分片数量）</h4><p>默认值： 231 用于指定数据分片过程中的分片数量。支持数据分片/框架结构有：集（Set）、映射（Map）、BitSet、Bloom filter, Spring Cache和Hibernate Cache等.</p>
<h4 id="readMode（读取操作的负载均衡模式）"><a href="#readMode（读取操作的负载均衡模式）" class="headerlink" title="readMode（读取操作的负载均衡模式）"></a>readMode（读取操作的负载均衡模式）</h4><p>默认值： SLAVE（只在从服务节点里读取）</p>
<p>注：在从服务节点里读取的数据说明已经至少有两个节点保存了该数据，确保了数据的高可用性。</p>
<p>设置读取操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里读取。 MASTER - 只在主服务节点里读取。 MASTER_SLAVE - 在主从服务节点里都可以读取。</p>
<h4 id="subscriptionMode（订阅操作的负载均衡模式）"><a href="#subscriptionMode（订阅操作的负载均衡模式）" class="headerlink" title="subscriptionMode（订阅操作的负载均衡模式）"></a>subscriptionMode（订阅操作的负载均衡模式）</h4><p>默认值：SLAVE（只在从服务节点里订阅）</p>
<p>设置订阅操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里订阅。 MASTER - 只在主服务节点里订阅。</p>
<h4 id="loadBalancer（负载均衡算法类的选择）"><a href="#loadBalancer（负载均衡算法类的选择）" class="headerlink" title="loadBalancer（负载均衡算法类的选择）"></a>loadBalancer（负载均衡算法类的选择）</h4><p>默认值： org.redisson.connection.balancer.RoundRobinLoadBalancer</p>
<p>在多Redis服务节点的环境里，可以选用以下几种负载均衡方式选择一个节点： org.redisson.connection.balancer.WeightedRoundRobinBalancer - 权重轮询调度算法 org.redisson.connection.balancer.RoundRobinLoadBalancer - 轮询调度算法 org.redisson.connection.balancer.RandomLoadBalancer - 随机调度算法</p>
<h4 id="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）"><a href="#subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）" class="headerlink" title="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）"></a>subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）</h4><p>默认值：1</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。</p>
<h4 id="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）"><a href="#subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）" class="headerlink" title="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）"></a>subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）</h4><p>默认值：50</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）"><a href="#slaveConnectionMinimumIdleSize（从节点最小空闲连接数）" class="headerlink" title="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）"></a>slaveConnectionMinimumIdleSize（从节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时读取反映速度。</p>
<h4 id="slaveConnectionPoolSize（从节点连接池大小）"><a href="#slaveConnectionPoolSize（从节点连接池大小）" class="headerlink" title="slaveConnectionPoolSize（从节点连接池大小）"></a>slaveConnectionPoolSize（从节点连接池大小）</h4><p>默认值：64</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="masterConnectionMinimumIdleSize（主节点最小空闲连接数）"><a href="#masterConnectionMinimumIdleSize（主节点最小空闲连接数）" class="headerlink" title="masterConnectionMinimumIdleSize（主节点最小空闲连接数）"></a>masterConnectionMinimumIdleSize（主节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多节点的环境里，每个 主节点的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。</p>
<h4 id="masterConnectionPoolSize（主节点连接池大小）"><a href="#masterConnectionPoolSize（主节点连接池大小）" class="headerlink" title="masterConnectionPoolSize（主节点连接池大小）"></a>masterConnectionPoolSize（主节点连接池大小）</h4><p>默认值：64</p>
<p>多主节点的环境里，每个 主节点的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="idleConnectionTimeout（连接空闲超时，单位：毫秒）"><a href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）" class="headerlink" title="idleConnectionTimeout（连接空闲超时，单位：毫秒）"></a>idleConnectionTimeout（连接空闲超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>如果当前连接池里的连接数量超过了最小空闲连接数，而同时有连接空闲时间超过了该数值，那么这些连接将会自动被关闭，并从连接池里去掉。时间单位是毫秒。</p>
<h4 id="connectTimeout（连接超时，单位：毫秒）"><a href="#connectTimeout（连接超时，单位：毫秒）" class="headerlink" title="connectTimeout（连接超时，单位：毫秒）"></a>connectTimeout（连接超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>同任何节点建立连接时的等待超时。时间单位是毫秒。</p>
<h4 id="timeout（命令等待超时，单位：毫秒）"><a href="#timeout（命令等待超时，单位：毫秒）" class="headerlink" title="timeout（命令等待超时，单位：毫秒）"></a>timeout（命令等待超时，单位：毫秒）</h4><p>默认值：3000</p>
<p>等待节点回复命令的时间。该时间从命令发送成功时开始计时。</p>
<h4 id="retryAttempts（命令失败重试次数）"><a href="#retryAttempts（命令失败重试次数）" class="headerlink" title="retryAttempts（命令失败重试次数）"></a>retryAttempts（命令失败重试次数）</h4><p>默认值：3</p>
<p>如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。</p>
<h4 id="retryInterval（命令重试发送时间间隔，单位：毫秒）"><a href="#retryInterval（命令重试发送时间间隔，单位：毫秒）" class="headerlink" title="retryInterval（命令重试发送时间间隔，单位：毫秒）"></a>retryInterval（命令重试发送时间间隔，单位：毫秒）</h4><p>默认值：1500</p>
<p>在一条命令发送失败以后，等待重试发送的时间间隔。时间单位是毫秒。</p>
<h4 id="reconnectionTimeout（重新连接时间间隔，单位：毫秒）"><a href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）" class="headerlink" title="reconnectionTimeout（重新连接时间间隔，单位：毫秒）"></a>reconnectionTimeout（重新连接时间间隔，单位：毫秒）</h4><p>默认值：3000</p>
<p>当与某个节点的连接断开时，等待与其重新建立连接的时间间隔。时间单位是毫秒。</p>
<h4 id="failedAttempts（执行失败最大次数）"><a href="#failedAttempts（执行失败最大次数）" class="headerlink" title="failedAttempts（执行失败最大次数）"></a>failedAttempts（执行失败最大次数）</h4><p>默认值：3</p>
<p>在某个节点执行相同或不同命令时，连续 失败 failedAttempts（执行失败最大次数） 时，该节点将被从可用节点列表里清除，直到 reconnectionTimeout（重新连接时间间隔） 超时以后再次尝试。</p>
<h4 id="password（密码）"><a href="#password（密码）" class="headerlink" title="password（密码）"></a>password（密码）</h4><p>默认值：null</p>
<p>用于节点身份验证的密码。</p>
<h4 id="subscriptionsPerConnection（单个连接最大订阅数量）"><a href="#subscriptionsPerConnection（单个连接最大订阅数量）" class="headerlink" title="subscriptionsPerConnection（单个连接最大订阅数量）"></a>subscriptionsPerConnection（单个连接最大订阅数量）</h4><p>默认值：5</p>
<p>每个连接的最大订阅数量。</p>
<h4 id="clientName（客户端名称）"><a href="#clientName（客户端名称）" class="headerlink" title="clientName（客户端名称）"></a>clientName（客户端名称）</h4><p>默认值：null</p>
<p>在Redis节点里显示的客户端名称。</p>
<h4 id="sslEnableEndpointIdentification（启用SSL终端识别）"><a href="#sslEnableEndpointIdentification（启用SSL终端识别）" class="headerlink" title="sslEnableEndpointIdentification（启用SSL终端识别）"></a>sslEnableEndpointIdentification（启用SSL终端识别）</h4><p>默认值：true</p>
<p>开启SSL终端识别能力。</p>
<h4 id="sslProvider（SSL实现方式）"><a href="#sslProvider（SSL实现方式）" class="headerlink" title="sslProvider（SSL实现方式）"></a>sslProvider（SSL实现方式）</h4><p>默认值：JDK</p>
<p>确定采用哪种方式（JDK或OPENSSL）来实现SSL连接。</p>
<h4 id="sslTruststore（SSL信任证书库路径）"><a href="#sslTruststore（SSL信任证书库路径）" class="headerlink" title="sslTruststore（SSL信任证书库路径）"></a>sslTruststore（SSL信任证书库路径）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的路径。</p>
<h4 id="sslTruststorePassword（SSL信任证书库密码）"><a href="#sslTruststorePassword（SSL信任证书库密码）" class="headerlink" title="sslTruststorePassword（SSL信任证书库密码）"></a>sslTruststorePassword（SSL信任证书库密码）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的密码。</p>
<h4 id="sslKeystore（SSL钥匙库路径）"><a href="#sslKeystore（SSL钥匙库路径）" class="headerlink" title="sslKeystore（SSL钥匙库路径）"></a>sslKeystore（SSL钥匙库路径）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的路径。</p>
<h4 id="sslKeystorePassword（SSL钥匙库密码）"><a href="#sslKeystorePassword（SSL钥匙库密码）" class="headerlink" title="sslKeystorePassword（SSL钥匙库密码）"></a>sslKeystorePassword（SSL钥匙库密码）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的密码。</p>
<h2 id="单Redis节点模式"><a href="#单Redis节点模式" class="headerlink" title="单Redis节点模式"></a>单Redis节点模式</h2><h3 id="1、程序化配置"><a href="#1、程序化配置" class="headerlink" title="1、程序化配置"></a>1、程序化配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认连接地址 127.0.0.1:6379</span></span><br><span class="line">RedissonClient redisson = Redisson.create();</span><br><span class="line"></span><br><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">"myredisserver:6379"</span>);</span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br></pre></td></tr></table></figure>
<h3 id="2、单节点设置"><a href="#2、单节点设置" class="headerlink" title="2、单节点设置"></a>2、单节点设置</h3><p>SingleServerConfig 类的设置参数如下：</p>
<h4 id="address（节点地址）"><a href="#address（节点地址）" class="headerlink" title="address（节点地址）"></a>address（节点地址）</h4><p>可以通过host:port的格式来指定节点地址。</p>
<h4 id="subscriptionConnectionMinimumIdleSize（发布和订阅连接的最小空闲连接数）"><a href="#subscriptionConnectionMinimumIdleSize（发布和订阅连接的最小空闲连接数）" class="headerlink" title="subscriptionConnectionMinimumIdleSize（发布和订阅连接的最小空闲连接数）"></a>subscriptionConnectionMinimumIdleSize（发布和订阅连接的最小空闲连接数）</h4><p>默认值：1</p>
<p>用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。</p>
<h4 id="subscriptionConnectionPoolSize（发布和订阅连接池大小）"><a href="#subscriptionConnectionPoolSize（发布和订阅连接池大小）" class="headerlink" title="subscriptionConnectionPoolSize（发布和订阅连接池大小）"></a>subscriptionConnectionPoolSize（发布和订阅连接池大小）</h4><p>默认值：50</p>
<p>用于发布和订阅连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="connectionMinimumIdleSize（最小空闲连接数）"><a href="#connectionMinimumIdleSize（最小空闲连接数）" class="headerlink" title="connectionMinimumIdleSize（最小空闲连接数）"></a>connectionMinimumIdleSize（最小空闲连接数）</h4><p>默认值：32</p>
<p>最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。</p>
<h4 id="connectionPoolSize（连接池大小）"><a href="#connectionPoolSize（连接池大小）" class="headerlink" title="connectionPoolSize（连接池大小）"></a>connectionPoolSize（连接池大小）</h4><p>默认值：64</p>
<p>连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="dnsMonitoring（是否启用DNS监测）"><a href="#dnsMonitoring（是否启用DNS监测）" class="headerlink" title="dnsMonitoring（是否启用DNS监测）"></a>dnsMonitoring（是否启用DNS监测）</h4><p>默认值：false</p>
<p>在启用该功能以后，Redisson将会监测DNS的变化情况。</p>
<h4 id="dnsMonitoringInterval（DNS监测时间间隔，单位：毫秒）"><a href="#dnsMonitoringInterval（DNS监测时间间隔，单位：毫秒）" class="headerlink" title="dnsMonitoringInterval（DNS监测时间间隔，单位：毫秒）"></a>dnsMonitoringInterval（DNS监测时间间隔，单位：毫秒）</h4><p>默认值：5000</p>
<p>监测DNS的变化情况的时间间隔。</p>
<h4 id="idleConnectionTimeout（连接空闲超时，单位：毫秒）-1"><a href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）-1" class="headerlink" title="idleConnectionTimeout（连接空闲超时，单位：毫秒）"></a>idleConnectionTimeout（连接空闲超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>如果当前连接池里的连接数量超过了最小空闲连接数，而同时有连接空闲时间超过了该数值，那么这些连接将会自动被关闭，并从连接池里去掉。时间单位是毫秒。</p>
<h4 id="connectTimeout（连接超时，单位：毫秒）-1"><a href="#connectTimeout（连接超时，单位：毫秒）-1" class="headerlink" title="connectTimeout（连接超时，单位：毫秒）"></a>connectTimeout（连接超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>同节点建立连接时的等待超时。时间单位是毫秒。</p>
<h4 id="timeout（命令等待超时，单位：毫秒）-1"><a href="#timeout（命令等待超时，单位：毫秒）-1" class="headerlink" title="timeout（命令等待超时，单位：毫秒）"></a>timeout（命令等待超时，单位：毫秒）</h4><p>默认值：3000</p>
<p>等待节点回复命令的时间。该时间从命令发送成功时开始计时。</p>
<h4 id="retryAttempts（命令失败重试次数）-1"><a href="#retryAttempts（命令失败重试次数）-1" class="headerlink" title="retryAttempts（命令失败重试次数）"></a>retryAttempts（命令失败重试次数）</h4><p>默认值：3</p>
<p>如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。</p>
<h4 id="retryInterval（命令重试发送时间间隔，单位：毫秒）-1"><a href="#retryInterval（命令重试发送时间间隔，单位：毫秒）-1" class="headerlink" title="retryInterval（命令重试发送时间间隔，单位：毫秒）"></a>retryInterval（命令重试发送时间间隔，单位：毫秒）</h4><p>默认值：1500</p>
<p>在一条命令发送失败以后，等待重试发送的时间间隔。时间单位是毫秒。</p>
<h4 id="reconnectionTimeout（重新连接时间间隔，单位：毫秒）-1"><a href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）-1" class="headerlink" title="reconnectionTimeout（重新连接时间间隔，单位：毫秒）"></a>reconnectionTimeout（重新连接时间间隔，单位：毫秒）</h4><p>默认值：3000</p>
<p>当与某个节点的连接断开时，等待与其重新建立连接的时间间隔。时间单位是毫秒。</p>
<h4 id="failedAttempts（执行失败最大次数）-1"><a href="#failedAttempts（执行失败最大次数）-1" class="headerlink" title="failedAttempts（执行失败最大次数）"></a>failedAttempts（执行失败最大次数）</h4><p>默认值：3</p>
<p>在某个节点执行相同或不同命令时，连续 失败 failedAttempts（执行失败最大次数） 时，该节点将被从可用节点列表里清除，直到 reconnectionTimeout（重新连接时间间隔） 超时以后再次尝试。</p>
<h4 id="database（数据库编号）"><a href="#database（数据库编号）" class="headerlink" title="database（数据库编号）"></a>database（数据库编号）</h4><p>默认值：0</p>
<p>尝试连接的数据库编号。</p>
<h4 id="password（密码）-1"><a href="#password（密码）-1" class="headerlink" title="password（密码）"></a>password（密码）</h4><p>默认值：null</p>
<p>用于节点身份验证的密码。</p>
<h4 id="subscriptionsPerConnection（单个连接最大订阅数量）-1"><a href="#subscriptionsPerConnection（单个连接最大订阅数量）-1" class="headerlink" title="subscriptionsPerConnection（单个连接最大订阅数量）"></a>subscriptionsPerConnection（单个连接最大订阅数量）</h4><p>默认值：5</p>
<p>每个连接的最大订阅数量。</p>
<h4 id="clientName（客户端名称）-1"><a href="#clientName（客户端名称）-1" class="headerlink" title="clientName（客户端名称）"></a>clientName（客户端名称）</h4><p>默认值：null</p>
<p>在Redis节点里显示的客户端名称。</p>
<h4 id="sslEnableEndpointIdentification（启用SSL终端识别）-1"><a href="#sslEnableEndpointIdentification（启用SSL终端识别）-1" class="headerlink" title="sslEnableEndpointIdentification（启用SSL终端识别）"></a>sslEnableEndpointIdentification（启用SSL终端识别）</h4><p>默认值：true</p>
<p>开启SSL终端识别能力。</p>
<h4 id="sslProvider（SSL实现方式）-1"><a href="#sslProvider（SSL实现方式）-1" class="headerlink" title="sslProvider（SSL实现方式）"></a>sslProvider（SSL实现方式）</h4><p>默认值：JDK</p>
<p>确定采用哪种方式（JDK或OPENSSL）来实现SSL连接。</p>
<h4 id="sslTruststore（SSL信任证书库路径）-1"><a href="#sslTruststore（SSL信任证书库路径）-1" class="headerlink" title="sslTruststore（SSL信任证书库路径）"></a>sslTruststore（SSL信任证书库路径）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的路径。</p>
<h4 id="sslTruststorePassword（SSL信任证书库密码）-1"><a href="#sslTruststorePassword（SSL信任证书库密码）-1" class="headerlink" title="sslTruststorePassword（SSL信任证书库密码）"></a>sslTruststorePassword（SSL信任证书库密码）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的密码。</p>
<h4 id="sslKeystore（SSL钥匙库路径）-1"><a href="#sslKeystore（SSL钥匙库路径）-1" class="headerlink" title="sslKeystore（SSL钥匙库路径）"></a>sslKeystore（SSL钥匙库路径）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的路径。</p>
<h4 id="sslKeystorePassword（SSL钥匙库密码）-1"><a href="#sslKeystorePassword（SSL钥匙库密码）-1" class="headerlink" title="sslKeystorePassword（SSL钥匙库密码）"></a>sslKeystorePassword（SSL钥匙库密码）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的密码。</p>
<h3 id="3、配置文件"><a href="#3、配置文件" class="headerlink" title="3、配置文件"></a>3、配置文件</h3><p>配置单节点模式可以通过指定一个JSON格式的文件来实现。以下是JSON格式的配置文件样本。文件中的字段名称必须与SingleServerConfig和Config对象里的字段名称相符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;singleServerConfig&quot;:&#123;</span><br><span class="line">      &quot;idleConnectionTimeout&quot;:10000,</span><br><span class="line">      &quot;pingTimeout&quot;:1000,</span><br><span class="line">      &quot;connectTimeout&quot;:10000,</span><br><span class="line">      &quot;timeout&quot;:3000,</span><br><span class="line">      &quot;retryAttempts&quot;:3,</span><br><span class="line">      &quot;retryInterval&quot;:1500,</span><br><span class="line">      &quot;reconnectionTimeout&quot;:3000,</span><br><span class="line">      &quot;failedAttempts&quot;:3,</span><br><span class="line">      &quot;password&quot;:null,</span><br><span class="line">      &quot;subscriptionsPerConnection&quot;:5,</span><br><span class="line">      &quot;clientName&quot;:null,</span><br><span class="line">      &quot;address&quot;: &quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;,</span><br><span class="line">      &quot;subscriptionConnectionMinimumIdleSize&quot;:1,</span><br><span class="line">      &quot;subscriptionConnectionPoolSize&quot;:50,</span><br><span class="line">      &quot;connectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;connectionPoolSize&quot;:64,</span><br><span class="line">      &quot;database&quot;:0,</span><br><span class="line">      &quot;dnsMonitoring&quot;:false,</span><br><span class="line">      &quot;dnsMonitoringInterval&quot;:5000</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;threads&quot;:0,</span><br><span class="line">   &quot;nettyThreads&quot;:0,</span><br><span class="line">   &quot;codec&quot;:&#123;</span><br><span class="line">      &quot;class&quot;:&quot;org.redisson.codec.JsonJacksonCodec&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;transportMode&quot;:&quot;NIO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">singleServerConfig:</span><br><span class="line">  idleConnectionTimeout: 10000</span><br><span class="line">  pingTimeout: 1000</span><br><span class="line">  connectTimeout: 10000</span><br><span class="line">  timeout: 3000</span><br><span class="line">  retryAttempts: 3</span><br><span class="line">  retryInterval: 1500</span><br><span class="line">  reconnectionTimeout: 3000</span><br><span class="line">  failedAttempts: 3</span><br><span class="line">  password: null</span><br><span class="line">  subscriptionsPerConnection: 5</span><br><span class="line">  clientName: null</span><br><span class="line">  address: &quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;</span><br><span class="line">  subscriptionConnectionMinimumIdleSize: 1</span><br><span class="line">  subscriptionConnectionPoolSize: 50</span><br><span class="line">  connectionMinimumIdleSize: 32</span><br><span class="line">  connectionPoolSize: 64</span><br><span class="line">  database: 0</span><br><span class="line">  dnsMonitoring: false</span><br><span class="line">  dnsMonitoringInterval: 5000</span><br><span class="line">threads: 0</span><br><span class="line">nettyThreads: 0</span><br><span class="line">codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;</span><br><span class="line">&quot;transportMode&quot;:&quot;NIO&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client</span><br><span class="line">    id&#x3D;&quot;redisson&quot;</span><br><span class="line">    name&#x3D;&quot;redisson1,redisson2&quot;</span><br><span class="line">    threads&#x3D;&quot;0&quot;</span><br><span class="line">    netty-threads&#x3D;&quot;0&quot;</span><br><span class="line">    codec-ref&#x3D;&quot;myCodec&quot; </span><br><span class="line">    transport-mode&#x3D;&quot;NIO&quot;</span><br><span class="line">    redisson-reference-enabled&#x3D;&quot;true&quot;</span><br><span class="line">    codec-provider-ref&#x3D;&quot;myCodecProvider&quot;</span><br><span class="line">    resolver-provider-ref&#x3D;&quot;myResolverProvider&quot;</span><br><span class="line">    executor-ref&#x3D;&quot;myExecutor&quot;</span><br><span class="line">    event-loop-group-ref&#x3D;&quot;myEventLoopGroup&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    这里的name属性和qualifier子元素不能同时使用。</span><br><span class="line"></span><br><span class="line">    id和name的属性都可以被用来作为qualifier的备选值。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--&lt;qualifier value&#x3D;&quot;redisson3&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    &lt;redisson:single-server</span><br><span class="line">        idle-connection-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        ping-timeout&#x3D;&quot;1000&quot;</span><br><span class="line">        connect-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        retry-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        retry-interval&#x3D;&quot;1500&quot;</span><br><span class="line">        reconnection-timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        failed-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        password&#x3D;&quot;do_not_use_if_it_is_not_set&quot;</span><br><span class="line">        subscriptions-per-connection&#x3D;&quot;5&quot;</span><br><span class="line">        client-name&#x3D;&quot;none&quot;            </span><br><span class="line">        address&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;</span><br><span class="line">        subscription-connection-minimum-idle-size&#x3D;&quot;1&quot;</span><br><span class="line">        subscription-connection-pool-size&#x3D;&quot;50&quot;</span><br><span class="line">        connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        database&#x3D;&quot;0&quot;</span><br><span class="line">        dns-monitoring&#x3D;&quot;false&quot;</span><br><span class="line">        dns-monitoring-interval&#x3D;&quot;5000&quot;</span><br><span class="line">    &#x2F;&gt;            </span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最基本配置 --&gt;</span><br><span class="line">&lt;!-- 默认地址是 127.0.0.1:6379 --&gt;</span><br><span class="line">&lt;redisson:client&gt;</span><br><span class="line">    &lt;redisson:single-server&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><h3 id="1、程序化配置-1"><a href="#1、程序化配置-1" class="headerlink" title="1、程序化配置"></a>1、程序化配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSentinelServers()</span><br><span class="line">    .setMasterName(<span class="string">"mymaster"</span>)</span><br><span class="line">    <span class="comment">//可以用"rediss://"来启用SSL连接</span></span><br><span class="line">    .addSentinelAddress(<span class="string">"127.0.0.1:26389"</span>, <span class="string">"127.0.0.1:26379"</span>)</span><br><span class="line">    .addSentinelAddress(<span class="string">"127.0.0.1:26319"</span>);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br></pre></td></tr></table></figure>
<h3 id="2、设置"><a href="#2、设置" class="headerlink" title="2、设置"></a>2、设置</h3><p>SentinelServersConfig 类的设置参数如下：</p>
<h4 id="dnsMonitoringInterval（DNS监控间隔，单位：毫秒）"><a href="#dnsMonitoringInterval（DNS监控间隔，单位：毫秒）" class="headerlink" title="dnsMonitoringInterval（DNS监控间隔，单位：毫秒）"></a>dnsMonitoringInterval（DNS监控间隔，单位：毫秒）</h4><p>默认值：5000</p>
<p>用来指定检查节点DNS变化的时间间隔。使用的时候应该确保JVM里的DNS数据的缓存时间保持在足够低的范围才有意义。用-1来禁用该功能。</p>
<h4 id="masterName（主服务器的名称）"><a href="#masterName（主服务器的名称）" class="headerlink" title="masterName（主服务器的名称）"></a>masterName（主服务器的名称）</h4><p>主服务器的名称是哨兵进程中用来监测主从服务切换情况的。</p>
<h4 id="addSentinelAddress（添加哨兵节点地址）"><a href="#addSentinelAddress（添加哨兵节点地址）" class="headerlink" title="addSentinelAddress（添加哨兵节点地址）"></a>addSentinelAddress（添加哨兵节点地址）</h4><p>可以通过host:port的格式来指定哨兵节点的地址。多个节点可以一次性批量添加。</p>
<h4 id="readMode（读取操作的负载均衡模式）-1"><a href="#readMode（读取操作的负载均衡模式）-1" class="headerlink" title="readMode（读取操作的负载均衡模式）"></a>readMode（读取操作的负载均衡模式）</h4><p>默认值： SLAVE（只在从服务节点里读取）</p>
<p>注：在从服务节点里读取的数据说明已经至少有两个节点保存了该数据，确保了数据的高可用性。</p>
<p>设置读取操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里读取。 MASTER - 只在主服务节点里读取。 MASTER_SLAVE - 在主从服务节点里都可以读取。</p>
<h4 id="subscriptionMode（订阅操作的负载均衡模式）-1"><a href="#subscriptionMode（订阅操作的负载均衡模式）-1" class="headerlink" title="subscriptionMode（订阅操作的负载均衡模式）"></a>subscriptionMode（订阅操作的负载均衡模式）</h4><p>默认值：SLAVE（只在从服务节点里订阅）</p>
<p>设置订阅操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里订阅。 MASTER - 只在主服务节点里订阅。</p>
<h4 id="loadBalancer（负载均衡算法类的选择）-1"><a href="#loadBalancer（负载均衡算法类的选择）-1" class="headerlink" title="loadBalancer（负载均衡算法类的选择）"></a>loadBalancer（负载均衡算法类的选择）</h4><p>默认值： org.redisson.connection.balancer.RoundRobinLoadBalancer</p>
<p>在使用多个Redis服务节点的环境里，可以选用以下几种负载均衡方式选择一个节点： org.redisson.connection.balancer.WeightedRoundRobinBalancer - 权重轮询调度算法 org.redisson.connection.balancer.RoundRobinLoadBalancer - 轮询调度算法 org.redisson.connection.balancer.RandomLoadBalancer - 随机调度算法</p>
<h4 id="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）-1"><a href="#subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）-1" class="headerlink" title="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）"></a>subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）</h4><p>默认值：1</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。</p>
<h4 id="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）-1"><a href="#subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）-1" class="headerlink" title="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）"></a>subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）</h4><p>默认值：50</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）-1"><a href="#slaveConnectionMinimumIdleSize（从节点最小空闲连接数）-1" class="headerlink" title="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）"></a>slaveConnectionMinimumIdleSize（从节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时读取反映速度。</p>
<h4 id="slaveConnectionPoolSize（从节点连接池大小）-1"><a href="#slaveConnectionPoolSize（从节点连接池大小）-1" class="headerlink" title="slaveConnectionPoolSize（从节点连接池大小）"></a>slaveConnectionPoolSize（从节点连接池大小）</h4><p>默认值：64</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="masterConnectionMinimumIdleSize（主节点最小空闲连接数）-1"><a href="#masterConnectionMinimumIdleSize（主节点最小空闲连接数）-1" class="headerlink" title="masterConnectionMinimumIdleSize（主节点最小空闲连接数）"></a>masterConnectionMinimumIdleSize（主节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多从节点的环境里，每个 主节点的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。</p>
<h4 id="masterConnectionPoolSize（主节点连接池大小）-1"><a href="#masterConnectionPoolSize（主节点连接池大小）-1" class="headerlink" title="masterConnectionPoolSize（主节点连接池大小）"></a>masterConnectionPoolSize（主节点连接池大小）</h4><p>默认值：64</p>
<p>主节点的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="idleConnectionTimeout（连接空闲超时，单位：毫秒）-2"><a href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）-2" class="headerlink" title="idleConnectionTimeout（连接空闲超时，单位：毫秒）"></a>idleConnectionTimeout（连接空闲超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>如果当前连接池里的连接数量超过了最小空闲连接数，而同时有连接空闲时间超过了该数值，那么这些连接将会自动被关闭，并从连接池里去掉。时间单位是毫秒。</p>
<h4 id="connectTimeout（连接超时，单位：毫秒）-2"><a href="#connectTimeout（连接超时，单位：毫秒）-2" class="headerlink" title="connectTimeout（连接超时，单位：毫秒）"></a>connectTimeout（连接超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>同任何节点建立连接时的等待超时。时间单位是毫秒。</p>
<h4 id="timeout（命令等待超时，单位：毫秒）-2"><a href="#timeout（命令等待超时，单位：毫秒）-2" class="headerlink" title="timeout（命令等待超时，单位：毫秒）"></a>timeout（命令等待超时，单位：毫秒）</h4><p>默认值：3000</p>
<p>等待节点回复命令的时间。该时间从命令发送成功时开始计时。</p>
<h4 id="retryAttempts（命令失败重试次数）-2"><a href="#retryAttempts（命令失败重试次数）-2" class="headerlink" title="retryAttempts（命令失败重试次数）"></a>retryAttempts（命令失败重试次数）</h4><p>默认值：3</p>
<p>如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。</p>
<h4 id="retryInterval（命令重试发送时间间隔，单位：毫秒）-2"><a href="#retryInterval（命令重试发送时间间隔，单位：毫秒）-2" class="headerlink" title="retryInterval（命令重试发送时间间隔，单位：毫秒）"></a>retryInterval（命令重试发送时间间隔，单位：毫秒）</h4><p>默认值：1500</p>
<p>在一条命令发送失败以后，等待重试发送的时间间隔。时间单位是毫秒。</p>
<h4 id="reconnectionTimeout（重新连接时间间隔，单位：毫秒）-2"><a href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）-2" class="headerlink" title="reconnectionTimeout（重新连接时间间隔，单位：毫秒）"></a>reconnectionTimeout（重新连接时间间隔，单位：毫秒）</h4><p>默认值：3000</p>
<p>当与某个节点的连接断开时，等待与其重新建立连接的时间间隔。时间单位是毫秒。</p>
<h4 id="failedAttempts（执行失败最大次数）-2"><a href="#failedAttempts（执行失败最大次数）-2" class="headerlink" title="failedAttempts（执行失败最大次数）"></a>failedAttempts（执行失败最大次数）</h4><p>默认值：3</p>
<p>在某个节点执行相同或不同命令时，连续 失败 failedAttempts（执行失败最大次数） 时，该节点将被从可用节点列表里清除，直到 reconnectionTimeout（重新连接时间间隔） 超时以后再次尝试。</p>
<h4 id="database（数据库编号）-1"><a href="#database（数据库编号）-1" class="headerlink" title="database（数据库编号）"></a>database（数据库编号）</h4><p>默认值：0</p>
<p>尝试连接的数据库编号。</p>
<h4 id="password（密码）-2"><a href="#password（密码）-2" class="headerlink" title="password（密码）"></a>password（密码）</h4><p>默认值：null</p>
<p>用于节点身份验证的密码。</p>
<h4 id="subscriptionsPerConnection（单个连接最大订阅数量）-2"><a href="#subscriptionsPerConnection（单个连接最大订阅数量）-2" class="headerlink" title="subscriptionsPerConnection（单个连接最大订阅数量）"></a>subscriptionsPerConnection（单个连接最大订阅数量）</h4><p>默认值：5</p>
<p>每个连接的最大订阅数量。</p>
<h4 id="clientName（客户端名称）-2"><a href="#clientName（客户端名称）-2" class="headerlink" title="clientName（客户端名称）"></a>clientName（客户端名称）</h4><p>默认值：null</p>
<p>在Redis节点里显示的客户端名称。</p>
<h4 id="sslEnableEndpointIdentification（启用SSL终端识别）-2"><a href="#sslEnableEndpointIdentification（启用SSL终端识别）-2" class="headerlink" title="sslEnableEndpointIdentification（启用SSL终端识别）"></a>sslEnableEndpointIdentification（启用SSL终端识别）</h4><p>默认值：true</p>
<p>开启SSL终端识别能力。</p>
<h4 id="sslProvider（SSL实现方式）-2"><a href="#sslProvider（SSL实现方式）-2" class="headerlink" title="sslProvider（SSL实现方式）"></a>sslProvider（SSL实现方式）</h4><p>默认值：JDK</p>
<p>确定采用哪种方式（JDK或OPENSSL）来实现SSL连接。</p>
<h4 id="sslTruststore（SSL信任证书库路径）-2"><a href="#sslTruststore（SSL信任证书库路径）-2" class="headerlink" title="sslTruststore（SSL信任证书库路径）"></a>sslTruststore（SSL信任证书库路径）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的路径。</p>
<h4 id="sslTruststorePassword（SSL信任证书库密码）-2"><a href="#sslTruststorePassword（SSL信任证书库密码）-2" class="headerlink" title="sslTruststorePassword（SSL信任证书库密码）"></a>sslTruststorePassword（SSL信任证书库密码）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的密码。</p>
<h4 id="sslKeystore（SSL钥匙库路径）-2"><a href="#sslKeystore（SSL钥匙库路径）-2" class="headerlink" title="sslKeystore（SSL钥匙库路径）"></a>sslKeystore（SSL钥匙库路径）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的路径。</p>
<h4 id="sslKeystorePassword（SSL钥匙库密码）-2"><a href="#sslKeystorePassword（SSL钥匙库密码）-2" class="headerlink" title="sslKeystorePassword（SSL钥匙库密码）"></a>sslKeystorePassword（SSL钥匙库密码）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的密码。</p>
<h3 id="3、配置文件-1"><a href="#3、配置文件-1" class="headerlink" title="3、配置文件"></a>3、配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;sentinelServersConfig&quot;:&#123;</span><br><span class="line">      &quot;idleConnectionTimeout&quot;:10000,</span><br><span class="line">      &quot;pingTimeout&quot;:1000,</span><br><span class="line">      &quot;connectTimeout&quot;:10000,</span><br><span class="line">      &quot;timeout&quot;:3000,</span><br><span class="line">      &quot;retryAttempts&quot;:3,</span><br><span class="line">      &quot;retryInterval&quot;:1500,</span><br><span class="line">      &quot;reconnectionTimeout&quot;:3000,</span><br><span class="line">      &quot;failedAttempts&quot;:3,</span><br><span class="line">      &quot;password&quot;:null,</span><br><span class="line">      &quot;subscriptionsPerConnection&quot;:5,</span><br><span class="line">      &quot;clientName&quot;:null,</span><br><span class="line">      &quot;loadBalancer&quot;:&#123;</span><br><span class="line">         &quot;class&quot;:&quot;org.redisson.connection.balancer.RoundRobinLoadBalancer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;slaveSubscriptionConnectionMinimumIdleSize&quot;:1,</span><br><span class="line">      &quot;slaveSubscriptionConnectionPoolSize&quot;:50,</span><br><span class="line">      &quot;slaveConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;slaveConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;masterConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;masterConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;readMode&quot;:&quot;SLAVE&quot;,</span><br><span class="line">      &quot;sentinelAddresses&quot;:[</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:26379&quot;,</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:26389&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;masterName&quot;:&quot;mymaster&quot;,</span><br><span class="line">      &quot;database&quot;:0</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;threads&quot;:0,</span><br><span class="line">   &quot;nettyThreads&quot;:0,</span><br><span class="line">   &quot;codec&quot;:&#123;</span><br><span class="line">      &quot;class&quot;:&quot;org.redisson.codec.JsonJacksonCodec&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;transportMode&quot;:&quot;NIO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sentinelServersConfig:</span><br><span class="line">  idleConnectionTimeout: 10000</span><br><span class="line">  pingTimeout: 1000</span><br><span class="line">  connectTimeout: 10000</span><br><span class="line">  timeout: 3000</span><br><span class="line">  retryAttempts: 3</span><br><span class="line">  retryInterval: 1500</span><br><span class="line">  reconnectionTimeout: 3000</span><br><span class="line">  failedAttempts: 3</span><br><span class="line">  password: null</span><br><span class="line">  subscriptionsPerConnection: 5</span><br><span class="line">  clientName: null</span><br><span class="line">  loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; &#123;&#125;</span><br><span class="line">  slaveSubscriptionConnectionMinimumIdleSize: 1</span><br><span class="line">  slaveSubscriptionConnectionPoolSize: 50</span><br><span class="line">  slaveConnectionMinimumIdleSize: 32</span><br><span class="line">  slaveConnectionPoolSize: 64</span><br><span class="line">  masterConnectionMinimumIdleSize: 32</span><br><span class="line">  masterConnectionPoolSize: 64</span><br><span class="line">  readMode: &quot;SLAVE&quot;</span><br><span class="line">  sentinelAddresses:</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:26379&quot;</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:26389&quot;</span><br><span class="line">  masterName: &quot;mymaster&quot;</span><br><span class="line">  database: 0</span><br><span class="line">threads: 0</span><br><span class="line">nettyThreads: 0</span><br><span class="line">codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;</span><br><span class="line">&quot;transportMode&quot;:&quot;NIO&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client</span><br><span class="line">    id&#x3D;&quot;redisson&quot;</span><br><span class="line">    name&#x3D;&quot;redisson1,redisson2&quot;</span><br><span class="line">    threads&#x3D;&quot;0&quot;</span><br><span class="line">    netty-threads&#x3D;&quot;0&quot;</span><br><span class="line">    codec-ref&#x3D;&quot;myCodec&quot; </span><br><span class="line">    transport-mode&#x3D;&quot;NIO&quot;</span><br><span class="line">    redisson-reference-enabled&#x3D;&quot;true&quot;</span><br><span class="line">    codec-provider-ref&#x3D;&quot;myCodecProvider&quot;</span><br><span class="line">    resolver-provider-ref&#x3D;&quot;myResolverProvider&quot;</span><br><span class="line">    executor-ref&#x3D;&quot;myExecutor&quot;</span><br><span class="line">    event-loop-group-ref&#x3D;&quot;myEventLoopGroup&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    这里的name属性和qualifier子元素不能同时使用。</span><br><span class="line"></span><br><span class="line">    id和name的属性都可以被用来作为qualifier的备选值。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--&lt;qualifier value&#x3D;&quot;redisson3&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    &lt;redisson:sentinel-servers</span><br><span class="line">        idle-connection-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        ping-timeout&#x3D;&quot;1000&quot;</span><br><span class="line">        connect-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        retry-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        retry-interval&#x3D;&quot;1500&quot;</span><br><span class="line">        reconnection-timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        failed-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        password&#x3D;&quot;do_not_use_if_it_is_not_set&quot;</span><br><span class="line">        subscriptions-per-connection&#x3D;&quot;5&quot;</span><br><span class="line">        client-name&#x3D;&quot;none&quot;</span><br><span class="line">        load-balancer-ref&#x3D;&quot;myLoadBalancer&quot;</span><br><span class="line">        subscription-connection-minimum-idle-size&#x3D;&quot;1&quot;</span><br><span class="line">        subscription-connection-pool-size&#x3D;&quot;50&quot;</span><br><span class="line">        slave-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        slave-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        master-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        master-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        read-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        subscription-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        master-name&#x3D;&quot;myMaster&quot;</span><br><span class="line">        database&#x3D;&quot;0&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;redisson:sentinel-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:26379&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:sentinel-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:26380&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;redisson:sentinel-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最基本配置 --&gt;</span><br><span class="line">&lt;redisson:client&gt;</span><br><span class="line">    &lt;redisson:sentinel-servers master-name&#x3D;&quot;myMaster&quot;&gt;</span><br><span class="line">        &lt;redisson:sentinel-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:26379&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:sentinel-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:26380&quot; &#x2F;&gt;</span><br><span class="line">        ....</span><br><span class="line">    &lt;&#x2F;redisson:sentinel-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><h3 id="1、程序化配置-2"><a href="#1、程序化配置-2" class="headerlink" title="1、程序化配置"></a>1、程序化配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Config config &#x3D; new Config();</span><br><span class="line">config.useMasterSlaveServers()</span><br><span class="line">    &#x2F;&#x2F;可以用&quot;rediss:&#x2F;&#x2F;&quot;来启用SSL连接</span><br><span class="line">    .setMasterAddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;)</span><br><span class="line">    .addSlaveAddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:6389&quot;, &quot;redis:&#x2F;&#x2F;127.0.0.1:6332&quot;, &quot;redis:&#x2F;&#x2F;127.0.0.1:6419&quot;)</span><br><span class="line">    .addSlaveAddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:6399&quot;);</span><br><span class="line"></span><br><span class="line">RedissonClient redisson &#x3D; Redisson.create(config);</span><br></pre></td></tr></table></figure>
<h3 id="2、主从模式设置"><a href="#2、主从模式设置" class="headerlink" title="2、主从模式设置"></a>2、主从模式设置</h3><p>MasterSlaveServersConfig 类的设置参数如下：</p>
<h4 id="dnsMonitoringInterval（DNS监控间隔，单位：毫秒）-1"><a href="#dnsMonitoringInterval（DNS监控间隔，单位：毫秒）-1" class="headerlink" title="dnsMonitoringInterval（DNS监控间隔，单位：毫秒）"></a>dnsMonitoringInterval（DNS监控间隔，单位：毫秒）</h4><p>默认值：5000</p>
<p>用来指定检查节点DNS变化的时间间隔。使用的时候应该确保JVM里的DNS数据的缓存时间保持在足够低的范围才有意义。用-1来禁用该功能。</p>
<h4 id="masterAddress（主节点地址）"><a href="#masterAddress（主节点地址）" class="headerlink" title="masterAddress（主节点地址）"></a>masterAddress（主节点地址）</h4><p>可以通过host:port的格式来指定主节点地址。</p>
<h4 id="addSlaveAddress（添加从主节点地址）"><a href="#addSlaveAddress（添加从主节点地址）" class="headerlink" title="addSlaveAddress（添加从主节点地址）"></a>addSlaveAddress（添加从主节点地址）</h4><p>可以通过host:port的格式来指定从节点的地址。多个节点可以一次性批量添加。</p>
<h4 id="readMode（读取操作的负载均衡模式）-2"><a href="#readMode（读取操作的负载均衡模式）-2" class="headerlink" title="readMode（读取操作的负载均衡模式）"></a>readMode（读取操作的负载均衡模式）</h4><p>默认值： SLAVE（只在从服务节点里读取）</p>
<p>注：在从服务节点里读取的数据说明已经至少有两个节点保存了该数据，确保了数据的高可用性。</p>
<p>设置读取操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里读取。 MASTER - 只在主服务节点里读取。 MASTER_SLAVE - 在主从服务节点里都可以读取。</p>
<h4 id="subscriptionMode（订阅操作的负载均衡模式）-2"><a href="#subscriptionMode（订阅操作的负载均衡模式）-2" class="headerlink" title="subscriptionMode（订阅操作的负载均衡模式）"></a>subscriptionMode（订阅操作的负载均衡模式）</h4><p>默认值：SLAVE（只在从服务节点里订阅）</p>
<p>设置订阅操作选择节点的模式。 可用值为： SLAVE - 只在从服务节点里订阅。 MASTER - 只在主服务节点里订阅。</p>
<h4 id="loadBalancer（负载均衡算法类的选择）-2"><a href="#loadBalancer（负载均衡算法类的选择）-2" class="headerlink" title="loadBalancer（负载均衡算法类的选择）"></a>loadBalancer（负载均衡算法类的选择）</h4><p>默认值： org.redisson.connection.balancer.RoundRobinLoadBalancer</p>
<p>在使用多个Redis服务节点的环境里，可以选用以下几种负载均衡方式选择一个节点： org.redisson.connection.balancer.WeightedRoundRobinBalancer - 权重轮询调度算法 org.redisson.connection.balancer.RoundRobinLoadBalancer - 轮询调度算法 org.redisson.connection.balancer.RandomLoadBalancer - 随机调度算法</p>
<h4 id="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）-2"><a href="#subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）-2" class="headerlink" title="subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）"></a>subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）</h4><p>默认值：1</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的最小保持连接数（长连接）。Redisson内部经常通过发布和订阅来实现许多功能。长期保持一定数量的发布订阅连接是必须的。</p>
<h4 id="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）-2"><a href="#subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）-2" class="headerlink" title="subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）"></a>subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）</h4><p>默认值：50</p>
<p>多从节点的环境里，每个 从服务节点里用于发布和订阅连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）-2"><a href="#slaveConnectionMinimumIdleSize（从节点最小空闲连接数）-2" class="headerlink" title="slaveConnectionMinimumIdleSize（从节点最小空闲连接数）"></a>slaveConnectionMinimumIdleSize（从节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时读取反映速度。</p>
<h4 id="slaveConnectionPoolSize（从节点连接池大小）-2"><a href="#slaveConnectionPoolSize（从节点连接池大小）-2" class="headerlink" title="slaveConnectionPoolSize（从节点连接池大小）"></a>slaveConnectionPoolSize（从节点连接池大小）</h4><p>默认值：64</p>
<p>多从节点的环境里，每个 从服务节点里用于普通操作（非 发布和订阅）连接的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="masterConnectionMinimumIdleSize（主节点最小空闲连接数）-2"><a href="#masterConnectionMinimumIdleSize（主节点最小空闲连接数）-2" class="headerlink" title="masterConnectionMinimumIdleSize（主节点最小空闲连接数）"></a>masterConnectionMinimumIdleSize（主节点最小空闲连接数）</h4><p>默认值：32</p>
<p>多从节点的环境里，每个 主节点的最小保持连接数（长连接）。长期保持一定数量的连接有利于提高瞬时写入反应速度。</p>
<h4 id="masterConnectionPoolSize（主节点连接池大小）-2"><a href="#masterConnectionPoolSize（主节点连接池大小）-2" class="headerlink" title="masterConnectionPoolSize（主节点连接池大小）"></a>masterConnectionPoolSize（主节点连接池大小）</h4><p>默认值：64</p>
<p>主节点的连接池最大容量。连接池的连接数量自动弹性伸缩。</p>
<h4 id="idleConnectionTimeout（连接空闲超时，单位：毫秒）-3"><a href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）-3" class="headerlink" title="idleConnectionTimeout（连接空闲超时，单位：毫秒）"></a>idleConnectionTimeout（连接空闲超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>如果当前连接池里的连接数量超过了最小空闲连接数，而同时有连接空闲时间超过了该数值，那么这些连接将会自动被关闭，并从连接池里去掉。时间单位是毫秒。</p>
<h4 id="connectTimeout（连接超时，单位：毫秒）-3"><a href="#connectTimeout（连接超时，单位：毫秒）-3" class="headerlink" title="connectTimeout（连接超时，单位：毫秒）"></a>connectTimeout（连接超时，单位：毫秒）</h4><p>默认值：10000</p>
<p>同任何节点建立连接时的等待超时。时间单位是毫秒。</p>
<h4 id="timeout（命令等待超时，单位：毫秒）-3"><a href="#timeout（命令等待超时，单位：毫秒）-3" class="headerlink" title="timeout（命令等待超时，单位：毫秒）"></a>timeout（命令等待超时，单位：毫秒）</h4><p>默认值：3000</p>
<p>等待节点回复命令的时间。该时间从命令发送成功时开始计时。</p>
<h4 id="retryAttempts（命令失败重试次数）-3"><a href="#retryAttempts（命令失败重试次数）-3" class="headerlink" title="retryAttempts（命令失败重试次数）"></a>retryAttempts（命令失败重试次数）</h4><p>默认值：3</p>
<p>如果尝试达到 retryAttempts（命令失败重试次数） 仍然不能将命令发送至某个指定的节点时，将抛出错误。如果尝试在此限制之内发送成功，则开始启用 timeout（命令等待超时） 计时。</p>
<h4 id="retryInterval（命令重试发送时间间隔，单位：毫秒）-3"><a href="#retryInterval（命令重试发送时间间隔，单位：毫秒）-3" class="headerlink" title="retryInterval（命令重试发送时间间隔，单位：毫秒）"></a>retryInterval（命令重试发送时间间隔，单位：毫秒）</h4><p>默认值：1500</p>
<p>在一条命令发送失败以后，等待重试发送的时间间隔。时间单位是毫秒。</p>
<h4 id="reconnectionTimeout（重新连接时间间隔，单位：毫秒）-3"><a href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）-3" class="headerlink" title="reconnectionTimeout（重新连接时间间隔，单位：毫秒）"></a>reconnectionTimeout（重新连接时间间隔，单位：毫秒）</h4><p>默认值：3000</p>
<p>当与某个节点的连接断开时，等待与其重新建立连接的时间间隔。时间单位是毫秒。</p>
<h4 id="failedAttempts（执行失败最大次数）-3"><a href="#failedAttempts（执行失败最大次数）-3" class="headerlink" title="failedAttempts（执行失败最大次数）"></a>failedAttempts（执行失败最大次数）</h4><p>默认值：3</p>
<p>在某个节点执行相同或不同命令时，连续 失败 failedAttempts（执行失败最大次数） 时，该节点将被从可用节点列表里清除，直到 reconnectionTimeout（重新连接时间间隔） 超时以后再次尝试。</p>
<h4 id="database（数据库编号）-2"><a href="#database（数据库编号）-2" class="headerlink" title="database（数据库编号）"></a>database（数据库编号）</h4><p>默认值：0</p>
<p>尝试连接的数据库编号。</p>
<h4 id="password（密码）-3"><a href="#password（密码）-3" class="headerlink" title="password（密码）"></a>password（密码）</h4><p>默认值：null</p>
<p>用于节点身份验证的密码。</p>
<h4 id="subscriptionsPerConnection（单个连接最大订阅数量）-3"><a href="#subscriptionsPerConnection（单个连接最大订阅数量）-3" class="headerlink" title="subscriptionsPerConnection（单个连接最大订阅数量）"></a>subscriptionsPerConnection（单个连接最大订阅数量）</h4><p>默认值：5</p>
<p>每个连接的最大订阅数量。</p>
<h4 id="clientName（客户端名称）-3"><a href="#clientName（客户端名称）-3" class="headerlink" title="clientName（客户端名称）"></a>clientName（客户端名称）</h4><p>默认值：null</p>
<p>在Redis节点里显示的客户端名称。</p>
<h4 id="sslEnableEndpointIdentification（启用SSL终端识别）-3"><a href="#sslEnableEndpointIdentification（启用SSL终端识别）-3" class="headerlink" title="sslEnableEndpointIdentification（启用SSL终端识别）"></a>sslEnableEndpointIdentification（启用SSL终端识别）</h4><p>默认值：true</p>
<p>开启SSL终端识别能力。</p>
<h4 id="sslProvider（SSL实现方式）-3"><a href="#sslProvider（SSL实现方式）-3" class="headerlink" title="sslProvider（SSL实现方式）"></a>sslProvider（SSL实现方式）</h4><p>默认值：JDK</p>
<p>确定采用哪种方式（JDK或OPENSSL）来实现SSL连接。</p>
<h4 id="sslTruststore（SSL信任证书库路径）-3"><a href="#sslTruststore（SSL信任证书库路径）-3" class="headerlink" title="sslTruststore（SSL信任证书库路径）"></a>sslTruststore（SSL信任证书库路径）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的路径。</p>
<h4 id="sslTruststorePassword（SSL信任证书库密码）-3"><a href="#sslTruststorePassword（SSL信任证书库密码）-3" class="headerlink" title="sslTruststorePassword（SSL信任证书库密码）"></a>sslTruststorePassword（SSL信任证书库密码）</h4><p>默认值：null</p>
<p>指定SSL信任证书库的密码。</p>
<h4 id="sslKeystore（SSL钥匙库路径）-3"><a href="#sslKeystore（SSL钥匙库路径）-3" class="headerlink" title="sslKeystore（SSL钥匙库路径）"></a>sslKeystore（SSL钥匙库路径）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的路径。</p>
<h4 id="sslKeystorePassword（SSL钥匙库密码）-3"><a href="#sslKeystorePassword（SSL钥匙库密码）-3" class="headerlink" title="sslKeystorePassword（SSL钥匙库密码）"></a>sslKeystorePassword（SSL钥匙库密码）</h4><p>默认值：null</p>
<p>指定SSL钥匙库的密码。</p>
<h3 id="3、文件配置主从模式"><a href="#3、文件配置主从模式" class="headerlink" title="3、文件配置主从模式"></a>3、文件配置主从模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;masterSlaveServersConfig&quot;:&#123;</span><br><span class="line">      &quot;idleConnectionTimeout&quot;:10000,</span><br><span class="line">      &quot;pingTimeout&quot;:1000,</span><br><span class="line">      &quot;connectTimeout&quot;:10000,</span><br><span class="line">      &quot;timeout&quot;:3000,</span><br><span class="line">      &quot;retryAttempts&quot;:3,</span><br><span class="line">      &quot;retryInterval&quot;:1500,</span><br><span class="line">      &quot;reconnectionTimeout&quot;:3000,</span><br><span class="line">      &quot;failedAttempts&quot;:3,</span><br><span class="line">      &quot;password&quot;:null,</span><br><span class="line">      &quot;subscriptionsPerConnection&quot;:5,</span><br><span class="line">      &quot;clientName&quot;:null,</span><br><span class="line">      &quot;loadBalancer&quot;:&#123;</span><br><span class="line">         &quot;class&quot;:&quot;org.redisson.connection.balancer.RoundRobinLoadBalancer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;slaveSubscriptionConnectionMinimumIdleSize&quot;:1,</span><br><span class="line">      &quot;slaveSubscriptionConnectionPoolSize&quot;:50,</span><br><span class="line">      &quot;slaveConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;slaveConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;masterConnectionMinimumIdleSize&quot;:32,</span><br><span class="line">      &quot;masterConnectionPoolSize&quot;:64,</span><br><span class="line">      &quot;readMode&quot;:&quot;SLAVE&quot;,</span><br><span class="line">      &quot;slaveAddresses&quot;:[</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot;,</span><br><span class="line">         &quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;masterAddress&quot;: &quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;,</span><br><span class="line">      &quot;database&quot;:0</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;threads&quot;:0,</span><br><span class="line">   &quot;nettyThreads&quot;:0,</span><br><span class="line">   &quot;codec&quot;:&#123;</span><br><span class="line">      &quot;class&quot;:&quot;org.redisson.codec.JsonJacksonCodec&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;transportMode&quot;:&quot;NIO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">masterSlaveServersConfig:</span><br><span class="line">  idleConnectionTimeout: 10000</span><br><span class="line">  pingTimeout: 1000</span><br><span class="line">  connectTimeout: 10000</span><br><span class="line">  timeout: 3000</span><br><span class="line">  retryAttempts: 3</span><br><span class="line">  retryInterval: 1500</span><br><span class="line">  reconnectionTimeout: 3000</span><br><span class="line">  failedAttempts: 3</span><br><span class="line">  password: null</span><br><span class="line">  subscriptionsPerConnection: 5</span><br><span class="line">  clientName: null</span><br><span class="line">  loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; &#123;&#125;</span><br><span class="line">  slaveSubscriptionConnectionMinimumIdleSize: 1</span><br><span class="line">  slaveSubscriptionConnectionPoolSize: 50</span><br><span class="line">  slaveConnectionMinimumIdleSize: 32</span><br><span class="line">  slaveConnectionPoolSize: 64</span><br><span class="line">  masterConnectionMinimumIdleSize: 32</span><br><span class="line">  masterConnectionPoolSize: 64</span><br><span class="line">  readMode: &quot;SLAVE&quot;</span><br><span class="line">  slaveAddresses:</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot;</span><br><span class="line">  - &quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot;</span><br><span class="line">  masterAddress: &quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;</span><br><span class="line">  database: 0</span><br><span class="line">threads: 0</span><br><span class="line">nettyThreads: 0</span><br><span class="line">codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;</span><br><span class="line">&quot;transportMode&quot;:&quot;NIO&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;redisson:client</span><br><span class="line">    id&#x3D;&quot;redisson&quot;</span><br><span class="line">    name&#x3D;&quot;redisson1,redisson2&quot;</span><br><span class="line">    threads&#x3D;&quot;0&quot;</span><br><span class="line">    netty-threads&#x3D;&quot;0&quot;</span><br><span class="line">    codec-ref&#x3D;&quot;myCodec&quot; </span><br><span class="line">    transport-mode&#x3D;&quot;NIO&quot;</span><br><span class="line">    redisson-reference-enabled&#x3D;&quot;true&quot;</span><br><span class="line">    codec-provider-ref&#x3D;&quot;myCodecProvider&quot;</span><br><span class="line">    resolver-provider-ref&#x3D;&quot;myResolverProvider&quot;</span><br><span class="line">    executor-ref&#x3D;&quot;myExecutor&quot;</span><br><span class="line">    event-loop-group-ref&#x3D;&quot;myEventLoopGroup&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    这里的name属性和qualifier子元素不能同时使用。</span><br><span class="line"></span><br><span class="line">    id和name的属性都可以被用来作为qualifier的备选值。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--&lt;qualifier value&#x3D;&quot;redisson3&quot;&#x2F;&gt;--&gt;</span><br><span class="line">    &lt;redisson:master-slave-servers</span><br><span class="line">        idle-connection-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        ping-timeout&#x3D;&quot;1000&quot;</span><br><span class="line">        connect-timeout&#x3D;&quot;10000&quot;</span><br><span class="line">        timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        retry-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        retry-interval&#x3D;&quot;1500&quot;</span><br><span class="line">        reconnection-timeout&#x3D;&quot;3000&quot;</span><br><span class="line">        failed-attempts&#x3D;&quot;3&quot;</span><br><span class="line">        password&#x3D;&quot;do_not_use_if_it_is_not_set&quot;</span><br><span class="line">        subscriptions-per-connection&#x3D;&quot;5&quot;</span><br><span class="line">        client-name&#x3D;&quot;none&quot;</span><br><span class="line">        load-balancer-ref&#x3D;&quot;myLoadBalancer&quot;</span><br><span class="line">        subscription-connection-minimum-idle-size&#x3D;&quot;1&quot;</span><br><span class="line">        subscription-connection-pool-size&#x3D;&quot;50&quot;</span><br><span class="line">        slave-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        slave-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        master-connection-minimum-idle-size&#x3D;&quot;10&quot;</span><br><span class="line">        master-connection-pool-size&#x3D;&quot;64&quot;</span><br><span class="line">        read-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        subscription-mode&#x3D;&quot;SLAVE&quot;</span><br><span class="line">        master-address&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;</span><br><span class="line">        database&#x3D;&quot;0&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;redisson:slave-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:slave-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;redisson:master-slave-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最基本配置 --&gt;</span><br><span class="line">&lt;redisson:client&gt;</span><br><span class="line">    &lt;redisson:master-slave-servers master-address&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;&gt;</span><br><span class="line">        &lt;redisson:slave-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6380&quot; &#x2F;&gt;</span><br><span class="line">        &lt;redisson:slave-address value&#x3D;&quot;redis:&#x2F;&#x2F;127.0.0.1:6381&quot; &#x2F;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;&#x2F;redisson:master-slave-servers&gt;</span><br><span class="line">&lt;&#x2F;redisson:client&gt;</span><br></pre></td></tr></table></figure>
<h1 id="三、程序接口调用方式"><a href="#三、程序接口调用方式" class="headerlink" title="三、程序接口调用方式"></a>三、程序接口调用方式</h1><p>RedissonClient、RedissonReactiveClient和RedissonRxClient实例本身和Redisson提供的所有分布式对象都是线程安全的。</p>
<p>Redisson为每个操作都提供了** 自动重试策略 **，当某个命令执行失败时，Redisson会自动进行重试。自动重试策略可以通过修改retryAttempts（默认值：3）参数和retryInterval（默认值：1000毫秒）参数来进行优化调整。当等待时间达到retryInterval指定的时间间隔以后，将自动重试下一次。全部重试失败以后将抛出错误。</p>
<p>Redisson框架提供的几乎所有对象都包含了同步和异步相互匹配的方法。这些对象都可以通过RedissonClient接口获取。同时还为大部分Redisson对象提供了满足异步流处理标准的程序接口RedissonReactiveClient。除此外还提供了RxJava2规范的RedissonRxClient程序接口。</p>
<p>以下是关于使用RAtomicLong对象的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RedissonClient client &#x3D; Redisson.create(config);</span><br><span class="line">RAtomicLong longObject &#x3D; client.getAtomicLong(&#39;myLong&#39;);</span><br><span class="line">&#x2F;&#x2F; 同步执行方式</span><br><span class="line">longObject.compareAndSet(3, 401);</span><br><span class="line">&#x2F;&#x2F; 异步执行方式</span><br><span class="line">RFuture&lt;Boolean&gt; result &#x3D; longObject.compareAndSetAsync(3, 401);</span><br><span class="line"></span><br><span class="line">RedissonReactiveClient client &#x3D; Redisson.createReactive(config);</span><br><span class="line">RAtomicLongReactive longObject &#x3D; client.getAtomicLong(&#39;myLong&#39;);</span><br><span class="line">&#x2F;&#x2F; 异步流执行方式</span><br><span class="line">Mono&lt;Boolean&gt; result &#x3D; longObject.compareAndSet(3, 401);</span><br><span class="line">RedissonRxClient client &#x3D; Redisson.createRx(config);</span><br><span class="line">RAtomicLongRx longObject&#x3D; client.getAtomicLong(&quot;myLong&quot;);</span><br><span class="line">&#x2F;&#x2F; RxJava2方式</span><br><span class="line">Flowable&lt;Boolean result &#x3D; longObject.compareAndSet(3, 401);</span><br></pre></td></tr></table></figure>
<h2 id="异步执行方式"><a href="#异步执行方式" class="headerlink" title="异步执行方式"></a>异步执行方式</h2><p>几乎所有的Redisson对象都实现了一个异步接口，异步接口提供的方法名称与其同步接口的方法名称相互匹配。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; RAtomicLong接口继承了RAtomicLongAsync接口</span><br><span class="line">RAtomicLongAsync longObject &#x3D; client.getAtomicLong(&quot;myLong&quot;);</span><br><span class="line">RFuture&lt;Boolean&gt; future &#x3D; longObject.compareAndSetAsync(1, 401);</span><br><span class="line">异步执行的方法都会返回一个实现了RFuture接口的对象。该对象同时提供了java.util.concurrent.CompletionStage和java.util.concurrent.Future两个异步接口。</span><br><span class="line"></span><br><span class="line">future.whenComplete((res, exception) -&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">future.thenAccept(res -&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理返回</span><br><span class="line">&#125;).exceptionally(exception -&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="异步流执行方式"><a href="#异步流执行方式" class="headerlink" title="异步流执行方式"></a>异步流执行方式</h2><p>Redisson为大多数分布式数据结构提供了满足Reactor项目的异步流处理标准的程序接口。该接口通过两种方式实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">基于Project Reactor标准的实现方式。使用范例如下：</span><br><span class="line">RedissonReactiveClient client &#x3D; Redisson.createReactive(config);</span><br><span class="line">RAtomicLongReactive atomicLong &#x3D; client.getAtomicLong(&quot;myLong&quot;);</span><br><span class="line">Mono&lt;Boolean&gt; cs &#x3D; longObject.compareAndSet(10, 91);</span><br><span class="line">Mono&lt;Long&gt; get &#x3D; longObject.get();</span><br><span class="line"></span><br><span class="line">Publisher&lt;Long&gt; getPublisher &#x3D; longObject.get();</span><br><span class="line">基于RxJava2标准的实现方式。使用范例如下：</span><br><span class="line">RedissonRxClient client &#x3D; Redisson.createRx(config);</span><br><span class="line">RAtomicLongRx atomicLong &#x3D; client.getAtomicLong(&quot;myLong&quot;);</span><br><span class="line">Single&lt;Boolean&gt; cs &#x3D; longObject.compareAndSet(10, 91);</span><br><span class="line">Single&lt;Long&gt; get &#x3D; longObject.get();</span><br></pre></td></tr></table></figure>

<h1 id="单个集合数据分片"><a href="#单个集合数据分片" class="headerlink" title="单个集合数据分片"></a>单个集合数据分片</h1><p>在集群模式下，Redisson为单个Redis集合类型提供了自动分片的功能。</p>
<p>Redisson提供的所有数据结构都支持在集群环境下使用，但每个数据结构只被保存在一个固定的槽内。Redisson PRO提供的自动分片功能能够将单个数据结构拆分，然后均匀的分布在整个集群里，而不是被挤在单一一个槽里。自动分片功能的优势主要有以下几点：</p>
<ul>
<li>单个数据结构可以充分利用整个集群内存资源，而不是被某一个节点的内存限制。</li>
<li>将单个数据结构分片以后分布在集群中不同的节点里，不仅可以大幅提高读写性能，还能够保证读写性能随着集群的扩张而自动提升。</li>
</ul>
<p>Redisson通过自身的分片算法，将一个大集合拆分为若干个片段（默认231个，分片数量范围是3 - 16834），然后将拆分后的片段均匀的分布到集群里各个节点里，保证每个节点分配到的片段数量大体相同。比如在默认情况下231个片段分到含有4个主节点的集群里，每个主节点将会分配到大约57个片段，同样的道理如果有5个主节点，每个节点会分配到大约46个片段。</p>
<p>目前支持的数据结构类型和服务包括集（Set）、映射（Map）、BitSet、布隆过滤器（Bloom Filter）、Spring Cache和Hibernate Cache。该功能仅限于Redisson PRO版本。</p>
<h1 id="四、分布式对象"><a href="#四、分布式对象" class="headerlink" title="四、分布式对象"></a>四、分布式对象</h1><p>每个Redisson对象实例都会有一个与之对应的Redis数据实例，可以通过调用getName方法来取得Redis数据实例的名称（key）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RMap map &#x3D; redisson.getMap(&quot;mymap&quot;);</span><br><span class="line">map.getName(); &#x2F;&#x2F; &#x3D; mymap</span><br><span class="line">所有与Redis key相关的操作都归纳在RKeys这个接口里：</span><br><span class="line"></span><br><span class="line">RKeys keys &#x3D; redisson.getKeys();</span><br><span class="line"></span><br><span class="line">Iterable&lt;String&gt; allKeys &#x3D; keys.getKeys();</span><br><span class="line">Iterable&lt;String&gt; foundedKeys &#x3D; keys.getKeysByPattern(&#39;key*&#39;);</span><br><span class="line">long numOfDeletedKeys &#x3D; keys.delete(&quot;obj1&quot;, &quot;obj2&quot;, &quot;obj3&quot;);</span><br><span class="line">long deletedKeysAmount &#x3D; keys.deleteByPattern(&quot;test?&quot;);</span><br><span class="line">String randomKey &#x3D; keys.randomKey();</span><br><span class="line">long keysAmount &#x3D; keys.count();</span><br></pre></td></tr></table></figure>
<h2 id="通用对象桶（Object-Bucket）"><a href="#通用对象桶（Object-Bucket）" class="headerlink" title="通用对象桶（Object Bucket）"></a>通用对象桶（Object Bucket）</h2><p>Redisson的分布式RBucketJava对象是一种通用对象桶可以用来存放任类型的对象。 除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RBucket&lt;AnyObject&gt; bucket &#x3D; redisson.getBucket(&quot;anyObject&quot;);</span><br><span class="line">bucket.set(new AnyObject(1));</span><br><span class="line">AnyObject obj &#x3D; bucket.get();</span><br><span class="line"></span><br><span class="line">bucket.trySet(new AnyObject(3));</span><br><span class="line">bucket.compareAndSet(new AnyObject(4), new AnyObject(5));</span><br><span class="line">bucket.getAndSet(new AnyObject(6));</span><br><span class="line">还可以通过RBuckets接口实现批量操作多个RBucket对象：</span><br><span class="line"></span><br><span class="line">RBuckets buckets &#x3D; redisson.getBuckets();</span><br><span class="line">List&lt;RBucket&lt;V&gt;&gt; foundBuckets &#x3D; buckets.find(&quot;myBucket*&quot;);</span><br><span class="line">Map&lt;String, V&gt; loadedBuckets &#x3D; buckets.get(&quot;myBucket1&quot;, &quot;myBucket2&quot;, &quot;myBucket3&quot;);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;myBucket1&quot;, new MyObject());</span><br><span class="line">map.put(&quot;myBucket2&quot;, new MyObject());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 利用Redis的事务特性，同时保存所有的通用对象桶，如果任意一个通用对象桶已经存在则放弃保存其他所有数据。</span><br><span class="line">buckets.trySet(map);</span><br><span class="line">&#x2F;&#x2F; 同时保存全部通用对象桶。</span><br><span class="line">buckets.set(map);</span><br></pre></td></tr></table></figure>
<h2 id="二进制流（Binary-Stream）"><a href="#二进制流（Binary-Stream）" class="headerlink" title="二进制流（Binary Stream）"></a>二进制流（Binary Stream）</h2><p>Redisson的分布式RBinaryStream Java对象同时提供了InputStream接口和OutputStream接口的实现。流的最大容量受Redis主节点的内存大小限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RBinaryStream stream &#x3D; redisson.getBinaryStream(&quot;anyStream&quot;);</span><br><span class="line">byte[] content &#x3D; ...</span><br><span class="line">stream.set(content);</span><br><span class="line"></span><br><span class="line">InputStream is &#x3D; stream.getInputStream();</span><br><span class="line">byte[] readBuffer &#x3D; new byte[512];</span><br><span class="line">is.read(readBuffer);</span><br><span class="line"></span><br><span class="line">OutputStream os &#x3D; stream.getOuputStream();</span><br><span class="line">byte[] contentToWrite &#x3D; ...</span><br><span class="line">os.write(contentToWrite);</span><br></pre></td></tr></table></figure>

<h2 id="地理空间对象桶（Geospatial-Bucket）"><a href="#地理空间对象桶（Geospatial-Bucket）" class="headerlink" title="地理空间对象桶（Geospatial Bucket）"></a>地理空间对象桶（Geospatial Bucket）</h2><p>Redisson的分布式RGeo Java对象是一种专门用来储存与地理位置有关的对象桶。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RGeo&lt;String&gt; geo &#x3D; redisson.getGeo(&quot;test&quot;);</span><br><span class="line">geo.add(new GeoEntry(13.361389, 38.115556, &quot;Palermo&quot;),</span><br><span class="line">        new GeoEntry(15.087269, 37.502669, &quot;Catania&quot;));</span><br><span class="line">geo.addAsync(37.618423, 55.751244, &quot;Moscow&quot;);</span><br><span class="line"></span><br><span class="line">Double distance &#x3D; geo.dist(&quot;Palermo&quot;, &quot;Catania&quot;, GeoUnit.METERS);</span><br><span class="line">geo.hashAsync(&quot;Palermo&quot;, &quot;Catania&quot;);</span><br><span class="line">Map&lt;String, GeoPosition&gt; positions &#x3D; geo.pos(&quot;test2&quot;, &quot;Palermo&quot;, &quot;test3&quot;, &quot;Catania&quot;, &quot;test1&quot;);</span><br><span class="line">List&lt;String&gt; cities &#x3D; geo.radius(15, 37, 200, GeoUnit.KILOMETERS);</span><br><span class="line">Map&lt;String, GeoPosition&gt; citiesWithPositions &#x3D; geo.radiusWithPosition(15, 37, 200, GeoUnit.KILOMETERS);</span><br></pre></td></tr></table></figure>
<h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><p>Redisson的分布式RBitSetJava对象采用了与java.util.BiteSet类似结构的设计风格。可以理解为它是一个分布式的可伸缩式位向量。需要注意的是RBitSet的大小受Redis限制，最大长度为4 294 967 295。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RBitSet set &#x3D; redisson.getBitSet(&quot;simpleBitset&quot;);</span><br><span class="line">set.set(0, true);</span><br><span class="line">set.set(1812, false);</span><br><span class="line">set.clear(0);</span><br><span class="line">set.addAsync(&quot;e&quot;);</span><br><span class="line">set.xor(&quot;anotherBitset&quot;);</span><br></pre></td></tr></table></figure>
<p>BitSet数据分片（Sharding）（分布式RoaringBitMap）</p>
<p>基于Redis的Redisson集群分布式BitSet通过RClusteredBitSet接口，为集群状态下的Redis环境提供了BitSet数据分片的功能。通过优化后更加有效的分布式RoaringBitMap算法，突破了原有的BitSet大小限制，达到了集群物理内存容量大小。在这里可以获取更多的内部信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RClusteredBitSet set &#x3D; redisson.getClusteredBitSet(&quot;simpleBitset&quot;);</span><br><span class="line">set.set(0, true);</span><br><span class="line">set.set(1812, false);</span><br><span class="line">set.clear(0);</span><br><span class="line">set.addAsync(&quot;e&quot;);</span><br><span class="line">set.xor(&quot;anotherBitset&quot;);</span><br><span class="line">该功能仅限于Redisson PRO版本。</span><br></pre></td></tr></table></figure>
<h2 id="原子整长形（AtomicLong）"><a href="#原子整长形（AtomicLong）" class="headerlink" title="原子整长形（AtomicLong）"></a>原子整长形（AtomicLong）</h2><p>Redisson的分布式整长形RAtomicLong对象和Java中的java.util.concurrent.atomic.AtomicLong对象类似。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAtomicLong atomicLong &#x3D; redisson.getAtomicLong(&quot;myAtomicLong&quot;);</span><br><span class="line">atomicLong.set(3);</span><br><span class="line">atomicLong.incrementAndGet();</span><br><span class="line">atomicLong.get();</span><br></pre></td></tr></table></figure>
<h2 id="原子双精度浮点（AtomicDouble）"><a href="#原子双精度浮点（AtomicDouble）" class="headerlink" title="原子双精度浮点（AtomicDouble）"></a>原子双精度浮点（AtomicDouble）</h2><p>Redisson还提供了分布式原子双精度浮点RAtomicDouble，弥补了Java自身的不足。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAtomicDouble atomicDouble &#x3D; redisson.getAtomicDouble(&quot;myAtomicDouble&quot;);</span><br><span class="line">atomicDouble.set(2.81);</span><br><span class="line">atomicDouble.addAndGet(4.11);</span><br><span class="line">atomicDouble.get();</span><br></pre></td></tr></table></figure>
<h2 id="话题（订阅分发）"><a href="#话题（订阅分发）" class="headerlink" title="话题（订阅分发）"></a>话题（订阅分发）</h2><p>Redisson的分布式话题<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RTopic.html对象实现了发布、订阅的机制。除了同步接口外，还提供了异步（[Async](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RTopicAsync.html)）、反射式（[Reactive](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RTopicReactive.html)）和[RxJava2](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RTopicRx.html" target="_blank" rel="noopener">RTopic</a>标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RTopic topic &#x3D; redisson.getTopic(&quot;anyTopic&quot;);</span><br><span class="line">topic.addListener(SomeObject.class, new MessageListener&lt;SomeObject&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(String channel, SomeObject message) &#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>// 在其他线程或JVM节点<br>RTopic topic = redisson.getTopic(“anyTopic”);<br>long clientsReceivedMessage = topic.publish(new SomeObject());<br>在Redis节点故障转移（主从切换）或断线重连以后，所有的话题监听器将自动完成话题的重新订阅。</p>
<p>模糊话题</p>
<p>Redisson的模糊话题RPatternTopic对象可以通过正式表达式来订阅多个话题。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 订阅所有满足&#96;topic1.*&#96;表达式的话题</span><br><span class="line">RPatternTopic topic1 &#x3D; redisson.getPatternTopic(&quot;topic1.*&quot;);</span><br><span class="line">int listenerId &#x3D; topic1.addListener(Message.class, new PatternMessageListener&lt;Message&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(String pattern, String channel, Message msg) &#123;</span><br><span class="line">         Assert.fail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在Redis节点故障转移（主从切换）或断线重连以后，所有的模糊话题监听器将自动完成话题的重新订阅。</p>
<h2 id="布隆过滤器（Bloom-Filter）"><a href="#布隆过滤器（Bloom-Filter）" class="headerlink" title="布隆过滤器（Bloom Filter）"></a>布隆过滤器（Bloom Filter）</h2><p>Redisson利用Redis实现了Java分布式布隆过滤器（Bloom Filter）。所含最大比特数量为2^32。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RBloomFilter&lt;SomeObject&gt; bloomFilter &#x3D; redisson.getBloomFilter(&quot;sample&quot;);</span><br><span class="line">&#x2F;&#x2F; 初始化布隆过滤器，预计统计元素数量为55000000，期望误差率为0.03</span><br><span class="line">bloomFilter.tryInit(55000000L, 0.03);</span><br><span class="line">bloomFilter.add(new SomeObject(&quot;field1Value&quot;, &quot;field2Value&quot;));</span><br><span class="line">bloomFilter.add(new SomeObject(&quot;field5Value&quot;, &quot;field8Value&quot;));</span><br><span class="line">bloomFilter.contains(new SomeObject(&quot;field1Value&quot;, &quot;field8Value&quot;));</span><br></pre></td></tr></table></figure>
<p>布隆过滤器数据分片（Sharding）</p>
<p>基于Redis的Redisson集群分布式布隆过滤器通过RClusteredBloomFilter接口，为集群状态下的Redis环境提供了布隆过滤器数据分片的功能。 通过优化后更加有效的算法，通过压缩未使用的比特位来释放集群内存空间。每个对象的状态都将被分布在整个集群中。所含最大比特数量为2^64。在这里可以获取更多的内部信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RClusteredBloomFilter&lt;SomeObject&gt; bloomFilter &#x3D; redisson.getClusteredBloomFilter(&quot;sample&quot;);</span><br><span class="line">&#x2F;&#x2F; 采用以下参数创建布隆过滤器</span><br><span class="line">&#x2F;&#x2F; expectedInsertions &#x3D; 255000000</span><br><span class="line">&#x2F;&#x2F; falseProbability &#x3D; 0.03</span><br><span class="line">bloomFilter.tryInit(255000000L, 0.03);</span><br><span class="line">bloomFilter.add(new SomeObject(&quot;field1Value&quot;, &quot;field2Value&quot;));</span><br><span class="line">bloomFilter.add(new SomeObject(&quot;field5Value&quot;, &quot;field8Value&quot;));</span><br><span class="line">bloomFilter.contains(new SomeObject(&quot;field1Value&quot;, &quot;field8Value&quot;));</span><br><span class="line">该功能仅限于Redisson PRO版本。</span><br></pre></td></tr></table></figure>
<h2 id="基数估计算法（HyperLogLog）"><a href="#基数估计算法（HyperLogLog）" class="headerlink" title="基数估计算法（HyperLogLog）"></a>基数估计算法（HyperLogLog）</h2><p>Redisson利用Redis实现了Java分布式基数估计算法（HyperLogLog）对象。该对象可以在有限的空间内通过概率算法统计大量的数据。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RHyperLogLog&lt;Integer&gt; log &#x3D; redisson.getHyperLogLog(&quot;log&quot;);</span><br><span class="line">log.add(1);</span><br><span class="line">log.add(2);</span><br><span class="line">log.add(3);</span><br><span class="line"></span><br><span class="line">log.count();</span><br></pre></td></tr></table></figure>
<h2 id="整长型累加器（LongAdder）"><a href="#整长型累加器（LongAdder）" class="headerlink" title="整长型累加器（LongAdder）"></a>整长型累加器（LongAdder）</h2><p>基于Redis的Redisson分布式整长型累加器（LongAdder）采用了与java.util.concurrent.atomic.LongAdder类似的接口。通过利用客户端内置的LongAdder对象，为分布式环境下递增和递减操作提供了很高得性能。据统计其性能最高比分布式AtomicLong对象快 12000 倍。完美适用于分布式统计计量场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RLongAdder atomicLong &#x3D; redisson.getLongAdder(&quot;myLongAdder&quot;);</span><br><span class="line">atomicLong.add(12);</span><br><span class="line">atomicLong.increment();</span><br><span class="line">atomicLong.decrement();</span><br><span class="line">atomicLong.sum();</span><br><span class="line">当不再使用整长型累加器对象的时候应该自行手动销毁，如果Redisson对象被关闭（shutdown）了，则不用手动销毁。</span><br><span class="line"></span><br><span class="line">RLongAdder atomicLong &#x3D; ...</span><br><span class="line">atomicLong.destroy();</span><br></pre></td></tr></table></figure>
<h2 id="双精度浮点累加器（DoubleAdder）"><a href="#双精度浮点累加器（DoubleAdder）" class="headerlink" title="双精度浮点累加器（DoubleAdder）"></a>双精度浮点累加器（DoubleAdder）</h2><p>基于Redis的Redisson分布式双精度浮点累加器（DoubleAdder）采用了与java.util.concurrent.atomic.DoubleAdder类似的接口。通过利用客户端内置的DoubleAdder对象，为分布式环境下递增和递减操作提供了很高得性能。据统计其性能最高比分布式AtomicDouble对象快 12000 倍。完美适用于分布式统计计量场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RLongDouble atomicDouble &#x3D; redisson.getLongDouble(&quot;myLongDouble&quot;);</span><br><span class="line">atomicDouble.add(12);</span><br><span class="line">atomicDouble.increment();</span><br><span class="line">atomicDouble.decrement();</span><br><span class="line">atomicDouble.sum();</span><br></pre></td></tr></table></figure>
<p>当不再使用双精度浮点累加器对象的时候应该自行手动销毁，如果Redisson对象被关闭（shutdown）了，则不用手动销毁。</p>
<h2 id="限流器（RateLimiter）"><a href="#限流器（RateLimiter）" class="headerlink" title="限流器（RateLimiter）"></a>限流器（RateLimiter）</h2><p>基于Redis的分布式限流器（RateLimiter）可以用来在分布式环境下现在请求方的调用频率。既适用于不同Redisson实例下的多线程限流，也适用于相同Redisson实例下的多线程限流。该算法不保证公平性。除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RRateLimiter rateLimiter &#x3D; redisson.getRateLimiter(&quot;myRateLimiter&quot;);</span><br><span class="line">&#x2F;&#x2F; 初始化</span><br><span class="line">&#x2F;&#x2F; 最大流速 &#x3D; 每1秒钟产生10个令牌</span><br><span class="line">rateLimiter.trySetRate(RateType.OVERALL, 10, 1, RateIntervalUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">CountDownLatch latch &#x3D; new CountDownLatch(2);</span><br><span class="line">limiter.acquire(3);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">Thread t &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">    limiter.acquire(2);</span><br><span class="line">    &#x2F;&#x2F; ...        </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="五、分布式集合"><a href="#五、分布式集合" class="headerlink" title="五、分布式集合"></a>五、分布式集合</h1><h2 id="1、映射（Map）"><a href="#1、映射（Map）" class="headerlink" title="1、映射（Map）"></a>1、映射（Map）</h2><p>基于Redis的Redisson的分布式映射结构的RMap Java对象实现了java.util.concurrent.ConcurrentMap接口和java.util.Map接口。与HashMap不同的是，RMap保持了元素的插入顺序。该对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<p>除了同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。如果你想用Redis Map来保存你的POJO的话，可以考虑使用分布式实时对象（Live Object）服务。</p>
<p>在特定的场景下，映射缓存（Map）上的高度频繁的读取操作，使网络通信都被视为瓶颈时，可以使用Redisson提供的带有本地缓存功能的映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RMap&lt;String, SomeObject&gt; map &#x3D; redisson.getMap(&quot;anyMap&quot;);</span><br><span class="line">SomeObject prevObject &#x3D; map.put(&quot;123&quot;, new SomeObject());</span><br><span class="line">SomeObject currentObject &#x3D; map.putIfAbsent(&quot;323&quot;, new SomeObject());</span><br><span class="line">SomeObject obj &#x3D; map.remove(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line">map.fastPut(&quot;321&quot;, new SomeObject());</span><br><span class="line">map.fastRemove(&quot;321&quot;);</span><br><span class="line"></span><br><span class="line">RFuture&lt;SomeObject&gt; putAsyncFuture &#x3D; map.putAsync(&quot;321&quot;);</span><br><span class="line">RFuture&lt;Void&gt; fastPutAsyncFuture &#x3D; map.fastPutAsync(&quot;321&quot;);</span><br><span class="line"></span><br><span class="line">map.fastPutAsync(&quot;321&quot;, new SomeObject());</span><br><span class="line">map.fastRemoveAsync(&quot;321&quot;);</span><br></pre></td></tr></table></figure>
<p>映射的字段锁的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RMap&lt;MyKey, MyValue&gt; map &#x3D; redisson.getMap(&quot;anyMap&quot;);</span><br><span class="line">MyKey k &#x3D; new MyKey();</span><br><span class="line">RLock keyLock &#x3D; map.getLock(k);</span><br><span class="line">keyLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">   MyValue v &#x3D; map.get(k);</span><br><span class="line">   &#x2F;&#x2F; 其他业务逻辑</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   keyLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RReadWriteLock rwLock &#x3D; map.getReadWriteLock(k);</span><br><span class="line">rwLock.readLock().lock();</span><br><span class="line">try &#123;</span><br><span class="line">   MyValue v &#x3D; map.get(k);</span><br><span class="line">   &#x2F;&#x2F; 其他业务逻辑</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   keyLock.readLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="映射（Map）的元素淘汰（Eviction），本地缓存（LocalCache）和数据分片（Sharding）"><a href="#映射（Map）的元素淘汰（Eviction），本地缓存（LocalCache）和数据分片（Sharding）" class="headerlink" title="映射（Map）的元素淘汰（Eviction），本地缓存（LocalCache）和数据分片（Sharding）"></a>映射（Map）的元素淘汰（Eviction），本地缓存（LocalCache）和数据分片（Sharding）</h3><p>Redisson提供了一系列的映射类型的数据结构，这些结构按特性主要分为三大类：</p>
<p>*<em>元素淘汰（Eviction） *</em>类 – 带有元素淘汰（Eviction）机制的映射类允许针对一个映射中每个元素单独设定 有效时间 和 最长闲置时间 。</p>
<p><strong>本地缓存（LocalCache）</strong> 类 – 本地缓存（Local Cache）也叫就近缓存（Near Cache）。这类映射的使用主要用于在特定的场景下，映射缓存（MapCache）上的高度频繁的读取操作，使网络通信都被视为瓶颈的情况。Redisson与Redis通信的同时，还将部分数据保存在本地内存里。这样的设计的好处是它能将读取速度提高最多 45倍 。 所有同名的本地缓存共用一个订阅发布话题，所有更新和过期消息都将通过该话题共享。</p>
<p><strong>数据分片（Sharding）</strong> 类 – 数据分片（Sharding）类仅适用于Redis集群环境下，因此带有数据分片（Sharding）功能的映射也叫集群分布式映射。它利用分库的原理，将单一一个映射结构切分为若干个小的映射，并均匀的分布在集群中的各个槽里。这样的设计能使一个单一映射结构突破Redis自身的容量限制，让其容量随集群的扩大而增长。在扩容的同时，还能够使读写性能和元素淘汰处理能力随之成线性增长。</p>
<p>以下列表是Redisson提供的所有映射的名称及其特性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">接口名称</span><br><span class="line">中文名称	RedissonClient</span><br><span class="line">对应的构造方法	本地缓存功能</span><br><span class="line">Local Cache	数据分片功能</span><br><span class="line">Sharding	元素淘汰功能</span><br><span class="line">Eviction</span><br><span class="line">RMap</span><br><span class="line">映射	getMap()</span><br><span class="line"> 	No	No	No</span><br><span class="line">RMapCache</span><br><span class="line">映射缓存	getMapCache()</span><br><span class="line"> 	No	No	Yes</span><br><span class="line">RLocalCachedMap</span><br><span class="line">本地缓存映射	getLocalCachedMap()</span><br><span class="line"> 	Yes	No	No</span><br><span class="line">RLocalCachedMap</span><br><span class="line">Cache</span><br><span class="line">本地缓存映射缓存</span><br><span class="line">仅限于Redisson PRO版本	getLocalCachedMapCache()	Yes	No	Yes</span><br><span class="line">RClusteredMap</span><br><span class="line">集群分布式映射存</span><br><span class="line">仅限于Redisson PRO版本	getClusteredMap()	No	Yes	No</span><br><span class="line">RClusteredMapCache</span><br><span class="line">集群分布式映射缓存存</span><br><span class="line">仅限于Redisson PRO版本	getClusteredMapCache()	No	Yes	Yes</span><br><span class="line">RClusteredLocal</span><br><span class="line">CachedMap</span><br><span class="line">集群分布式本地缓存映射存</span><br><span class="line">仅限于Redisson PRO版本	getClusteredLocal</span><br><span class="line">CachedMap()	Yes	Yes	No</span><br><span class="line">RClusteredLocal</span><br><span class="line">CachedMapCache</span><br><span class="line">集群分布式本地缓存映射缓存存</span><br><span class="line">仅限于Redisson PRO版本	getClusteredLocal</span><br><span class="line">CachedMapCache()	Yes	Yes	Yes</span><br><span class="line">除此以外，Redisson还提供了Spring Cache和JCache的实现。</span><br></pre></td></tr></table></figure>
<h4 id="元素淘汰功能（Eviction）"><a href="#元素淘汰功能（Eviction）" class="headerlink" title="元素淘汰功能（Eviction）"></a>元素淘汰功能（Eviction）</h4><p>Redisson的分布式的RMapCache Java对象在基于RMap的前提下实现了针对单个元素的淘汰机制。同时仍然保留了元素的插入顺序。由于RMapCache是基于RMap实现的，使它同时继承了java.util.concurrent.ConcurrentMap接口和java.util.Map接口。Redisson提供的Spring Cache整合以及JCache正是基于这样的功能来实现的。</p>
<p>目前的Redis自身并不支持散列（Hash）当中的元素淘汰，因此所有过期元素都是通过org.redisson.EvictionScheduler实例来实现定期清理的。为了保证资源的有效利用，每次运行最多清理300个过期元素。任务的启动时间将根据上次实际清理数量自动调整，间隔时间趋于1秒到1小时之间。比如该次清理时删除了300条元素，那么下次执行清理的时间将在1秒以后（最小间隔时间）。一旦该次清理数量少于上次清理数量，时间间隔将增加1.5倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RMapCache&lt;String, SomeObject&gt; map &#x3D; redisson.getMapCache(&quot;anyMap&quot;);</span><br><span class="line">&#x2F;&#x2F; 有效时间 ttl &#x3D; 10分钟</span><br><span class="line">map.put(&quot;key1&quot;, new SomeObject(), 10, TimeUnit.MINUTES);</span><br><span class="line">&#x2F;&#x2F; 有效时间 ttl &#x3D; 10分钟, 最长闲置时间 maxIdleTime &#x3D; 10秒钟</span><br><span class="line">map.put(&quot;key1&quot;, new SomeObject(), 10, TimeUnit.MINUTES, 10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 有效时间 &#x3D; 3 秒钟</span><br><span class="line">map.putIfAbsent(&quot;key2&quot;, new SomeObject(), 3, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F; 有效时间 ttl &#x3D; 40秒钟, 最长闲置时间 maxIdleTime &#x3D; 10秒钟</span><br><span class="line">map.putIfAbsent(&quot;key2&quot;, new SomeObject(), 40, TimeUnit.SECONDS, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h4 id="本地缓存功能（Local-Cache）"><a href="#本地缓存功能（Local-Cache）" class="headerlink" title="本地缓存功能（Local Cache）"></a>本地缓存功能（Local Cache）</h4><p>在特定的场景下，映射（Map）上的高度频繁的读取操作，使网络通信都被视为瓶颈时，使用Redisson提供的带有本地缓存功能的分布式本地缓存映射RLocalCachedMapJava对象会是一个很好的选择。它同时实现了java.util.concurrent.ConcurrentMap和java.util.Map两个接口。本地缓存功能充分的利用了JVM的自身内存空间，对部分常用的元素实行就地缓存，这样的设计让读取操作的性能较分布式映射相比提高最多 45倍 。以下配置参数可以用来创建这个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">LocalCachedMapOptions options = LocalCachedMapOptions.defaults()</span><br><span class="line">      <span class="comment">// 用于淘汰清除本地缓存内的元素</span></span><br><span class="line">      <span class="comment">// 共有以下几种选择:</span></span><br><span class="line">      <span class="comment">// LFU - 统计元素的使用频率，淘汰用得最少（最不常用）的。</span></span><br><span class="line">      <span class="comment">// LRU - 按元素使用时间排序比较，淘汰最早（最久远）的。</span></span><br><span class="line">      <span class="comment">// SOFT - 元素用Java的WeakReference来保存，缓存元素通过GC过程清除。</span></span><br><span class="line">      <span class="comment">// WEAK - 元素用Java的SoftReference来保存, 缓存元素通过GC过程清除。</span></span><br><span class="line">      <span class="comment">// NONE - 永不淘汰清除缓存元素。</span></span><br><span class="line">     .evictionPolicy(EvictionPolicy.NONE)</span><br><span class="line">     <span class="comment">// 如果缓存容量值为0表示不限制本地缓存容量大小</span></span><br><span class="line">     .cacheSize(<span class="number">1000</span>)</span><br><span class="line">      <span class="comment">// 以下选项适用于断线原因造成了未收到本地缓存更新消息的情况。</span></span><br><span class="line">      <span class="comment">// 断线重连的策略有以下几种：</span></span><br><span class="line">      <span class="comment">// CLEAR - 如果断线一段时间以后则在重新建立连接以后清空本地缓存</span></span><br><span class="line">      <span class="comment">// LOAD - 在服务端保存一份10分钟的作废日志</span></span><br><span class="line">      <span class="comment">//        如果10分钟内重新建立连接，则按照作废日志内的记录清空本地缓存的元素</span></span><br><span class="line">      <span class="comment">//        如果断线时间超过了这个时间，则将清空本地缓存中所有的内容</span></span><br><span class="line">      <span class="comment">// NONE - 默认值。断线重连时不做处理。</span></span><br><span class="line">     .reconnectionStrategy(ReconnectionStrategy.NONE)</span><br><span class="line">      <span class="comment">// 以下选项适用于不同本地缓存之间相互保持同步的情况</span></span><br><span class="line">      <span class="comment">// 缓存同步策略有以下几种：</span></span><br><span class="line">      <span class="comment">// INVALIDATE - 默认值。当本地缓存映射的某条元素发生变动时，同时驱逐所有相同本地缓存映射内的该元素</span></span><br><span class="line">      <span class="comment">// UPDATE - 当本地缓存映射的某条元素发生变动时，同时更新所有相同本地缓存映射内的该元素</span></span><br><span class="line">      <span class="comment">// NONE - 不做任何同步处理</span></span><br><span class="line">     .syncStrategy(SyncStrategy.INVALIDATE)</span><br><span class="line">      <span class="comment">// 每个Map本地缓存里元素的有效时间，默认毫秒为单位</span></span><br><span class="line">     .timeToLive(<span class="number">10000</span>)</span><br><span class="line">      <span class="comment">// 或者</span></span><br><span class="line">     .timeToLive(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">      <span class="comment">// 每个Map本地缓存里元素的最长闲置时间，默认毫秒为单位</span></span><br><span class="line">     .maxIdle(<span class="number">10000</span>)</span><br><span class="line">      <span class="comment">// 或者</span></span><br><span class="line">     .maxIdle(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">RLocalCachedMap&lt;String, Integer&gt; map = redisson.getLocalCachedMap(<span class="string">"test"</span>, options);</span><br><span class="line"></span><br><span class="line">String prevObject = map.put(<span class="string">"123"</span>, <span class="number">1</span>);</span><br><span class="line">String currentObject = map.putIfAbsent(<span class="string">"323"</span>, <span class="number">2</span>);</span><br><span class="line">String obj = map.remove(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在不需要旧值的情况下可以使用fast为前缀的类似方法</span></span><br><span class="line">map.fastPut(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">map.fastPutIfAbsent(<span class="string">"d"</span>, <span class="number">32</span>);</span><br><span class="line">map.fastRemove(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">RFuture&lt;String&gt; putAsyncFuture = map.putAsync(<span class="string">"321"</span>);</span><br><span class="line">RFuture&lt;Void&gt; fastPutAsyncFuture = map.fastPutAsync(<span class="string">"321"</span>);</span><br><span class="line"></span><br><span class="line">map.fastPutAsync(<span class="string">"321"</span>, <span class="keyword">new</span> SomeObject());</span><br><span class="line">map.fastRemoveAsync(<span class="string">"321"</span>);</span><br></pre></td></tr></table></figure>
<p>当不再使用Map本地缓存对象的时候应该手动销毁，如果Redisson对象被关闭（shutdown）了，则不用手动销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RLocalCachedMap&lt;String, Integer&gt; map &#x3D; ...</span><br><span class="line">map.destroy();</span><br><span class="line">如何通过加载数据的方式来降低过期淘汰事件发布信息对网络的影响</span><br><span class="line">代码范例:</span><br><span class="line"></span><br><span class="line">public void loadData(String cacheName, Map&lt;String, String&gt; data) &#123;</span><br><span class="line">    RLocalCachedMap&lt;String, String&gt; clearMap &#x3D; redisson.getLocalCachedMap(cacheName, </span><br><span class="line">            LocalCachedMapOptions.defaults().cacheSize(1).syncStrategy(SyncStrategy.INVALIDATE));</span><br><span class="line">    RLocalCachedMap&lt;String, String&gt; loadMap &#x3D; redisson.getLocalCachedMap(cacheName, </span><br><span class="line">            LocalCachedMapOptions.defaults().cacheSize(1).syncStrategy(SyncStrategy.NONE));</span><br><span class="line">    </span><br><span class="line">    loadMap.putAll(data);</span><br><span class="line">    clearMap.clearLocalCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据分片功能（Sharding）"><a href="#数据分片功能（Sharding）" class="headerlink" title="数据分片功能（Sharding）"></a>数据分片功能（Sharding）</h4><p>Map数据分片是Redis集群模式下的一个功能。Redisson提供的分布式集群映射RClusteredMap Java对象也是基于RMap实现的。它同时实现了java.util.concurrent.ConcurrentMap和java.util.Map两个接口。在这里可以获取更多的内部信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RClusteredMap&lt;String, SomeObject&gt; map &#x3D; redisson.getClusteredMap(&quot;anyMap&quot;);</span><br><span class="line"></span><br><span class="line">SomeObject prevObject &#x3D; map.put(&quot;123&quot;, new SomeObject());</span><br><span class="line">SomeObject currentObject &#x3D; map.putIfAbsent(&quot;323&quot;, new SomeObject());</span><br><span class="line">SomeObject obj &#x3D; map.remove(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line">map.fastPut(&quot;321&quot;, new SomeObject());</span><br><span class="line">map.fastRemove(&quot;321&quot;);</span><br></pre></td></tr></table></figure>
<h5 id="映射持久化方式（缓存策略）"><a href="#映射持久化方式（缓存策略）" class="headerlink" title="映射持久化方式（缓存策略）"></a>映射持久化方式（缓存策略）</h5><p>Redisson供了将映射中的数据持久化到外部储存服务的功能。主要场景有一下几种：</p>
<ul>
<li>将Redisson的分布式映射类型作为业务和外部储存媒介之间的缓存。</li>
<li>或是用来增加Redisson映射类型中数据的持久性，或是用来增加已被驱逐的数据的寿命。</li>
<li>或是用来缓存数据库，Web服务或其他数据源的数据。</li>
</ul>
<h6 id="Read-through策略"><a href="#Read-through策略" class="headerlink" title="Read-through策略"></a>Read-through策略</h6><p>通俗的讲，如果一个被请求的数据不存在于Redisson的映射中的时候，Redisson将通过预先配置好的MapLoader对象加载数据。</p>
<h6 id="Write-through（数据同步写入）策略"><a href="#Write-through（数据同步写入）策略" class="headerlink" title="Write-through（数据同步写入）策略"></a>Write-through（数据同步写入）策略</h6><p>在遇到映射中某条数据被更改时，Redisson会首先通过预先配置好的MapWriter对象写入到外部储存系统，然后再更新Redis内的数据。</p>
<h6 id="Write-behind（数据异步写入）策略"><a href="#Write-behind（数据异步写入）策略" class="headerlink" title="Write-behind（数据异步写入）策略"></a>Write-behind（数据异步写入）策略</h6><p>对映射的数据的更改会首先写入到Redis，然后再使用异步的方式，通过MapWriter对象写入到外部储存系统。在并发环境下可以通过writeBehindThreads参数来控制写入线程的数量，已达到对外部储存系统写入并发量的控制。</p>
<p>以上策略适用于所有实现了RMap、RMapCache、RLocalCachedMap和RLocalCachedMapCache接口的对象。</p>
<p>配置范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MapOptions&lt;K, V&gt; options &#x3D; MapOptions.&lt;K, V&gt;defaults()</span><br><span class="line">                              .writer(myWriter)</span><br><span class="line">                              .loader(myLoader);</span><br><span class="line"></span><br><span class="line">RMap&lt;K, V&gt; map &#x3D; redisson.getMap(&quot;test&quot;, options);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RMapCache&lt;K, V&gt; map &#x3D; redisson.getMapCache(&quot;test&quot;, options);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RLocalCachedMap&lt;K, V&gt; map &#x3D; redisson.getLocalCachedMap(&quot;test&quot;, options);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RLocalCachedMapCache&lt;K, V&gt; map &#x3D; redisson.getLocalCachedMapCache(&quot;test&quot;, options);</span><br></pre></td></tr></table></figure>
<h3 id="映射监听器（Map-Listener）"><a href="#映射监听器（Map-Listener）" class="headerlink" title="映射监听器（Map Listener）"></a>映射监听器（Map Listener）</h3><p>Redisson为所有实现了RMapCache或RLocalCachedMapCache接口的对象提供了监听以下事件的监听器：</p>
<ul>
<li>事件 | 监听器 元素 添加 事件 | org.redisson.api.map.event.EntryCreatedListener</li>
<li>元素 过期 事件 | org.redisson.api.map.event.EntryExpiredListener</li>
<li>元素 删除 事件 | org.redisson.api.map.event.EntryRemovedListener</li>
<li>元素 更新 事件 | org.redisson.api.map.event.EntryUpdatedListener</li>
</ul>
<p>使用范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">RMapCache&lt;String, Integer&gt; map &#x3D; redisson.getMapCache(&quot;myMap&quot;);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RLocalCachedMapCache&lt;String, Integer&gt; map &#x3D; redisson.getLocalCachedMapCache(&quot;myMap&quot;, options);</span><br><span class="line"></span><br><span class="line">int updateListener &#x3D; map.addListener(new EntryUpdatedListener&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onUpdated(EntryEvent&lt;Integer, Integer&gt; event) &#123;</span><br><span class="line">          event.getKey(); &#x2F;&#x2F; 字段名</span><br><span class="line">          event.getValue() &#x2F;&#x2F; 新值</span><br><span class="line">          event.getOldValue() &#x2F;&#x2F; 旧值</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">int createListener &#x3D; map.addListener(new EntryCreatedListener&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onCreated(EntryEvent&lt;Integer, Integer&gt; event) &#123;</span><br><span class="line">          event.getKey(); &#x2F;&#x2F; 字段名</span><br><span class="line">          event.getValue() &#x2F;&#x2F; 值</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">int expireListener &#x3D; map.addListener(new EntryExpiredListener&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onExpired(EntryEvent&lt;Integer, Integer&gt; event) &#123;</span><br><span class="line">          event.getKey(); &#x2F;&#x2F; 字段名</span><br><span class="line">          event.getValue() &#x2F;&#x2F; 值</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">int removeListener &#x3D; map.addListener(new EntryRemovedListener&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onRemoved(EntryEvent&lt;Integer, Integer&gt; event) &#123;</span><br><span class="line">          event.getKey(); &#x2F;&#x2F; 字段名</span><br><span class="line">          event.getValue() &#x2F;&#x2F; 值</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">map.removeListener(updateListener);</span><br><span class="line">map.removeListener(createListener);</span><br><span class="line">map.removeListener(expireListener);</span><br><span class="line">map.removeListener(removeListener);</span><br></pre></td></tr></table></figure>
<h3 id="LRU有界映射"><a href="#LRU有界映射" class="headerlink" title="LRU有界映射"></a>LRU有界映射</h3><p>Redisson提供了基于Redis的以LRU为驱逐策略的分布式LRU有界映射对象。顾名思义，分布式LRU有界映射允许通过对其中元素按使用时间排序处理的方式，主动移除超过规定容量限制的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RMapCache&lt;String, String&gt; map &#x3D; redisson.getMapCache(&quot;map&quot;);</span><br><span class="line">&#x2F;&#x2F; 尝试将该映射的最大容量限制设定为10</span><br><span class="line">map.trySetMaxSize(10);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将该映射的最大容量限制设定或更改为10</span><br><span class="line">map.setMaxSize(10);</span><br><span class="line"></span><br><span class="line">map.put(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">map.put(&quot;3&quot;, &quot;3&quot;, 1, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h2 id="2、多值映射（Multimap）"><a href="#2、多值映射（Multimap）" class="headerlink" title="2、多值映射（Multimap）"></a>2、多值映射（Multimap）</h2><p>基于Redis的Redisson的分布式RMultimap Java对象允许Map中的一个字段值包含多个元素。 字段总数受Redis限制，每个Multimap最多允许有4 294 967 295个不同字段。</p>
<h3 id="基于集（Set）的多值映射（Multimap）"><a href="#基于集（Set）的多值映射（Multimap）" class="headerlink" title="基于集（Set）的多值映射（Multimap）"></a>基于集（Set）的多值映射（Multimap）</h3><p>基于Set的Multimap不允许一个字段值包含有重复的元素。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>RSetMultimap&lt;SimpleKey, SimpleValue&gt; map = redisson.getSetMultimap(“myMultimap”);<br>map.put(new SimpleKey(“0”), new SimpleValue(“1”));<br>map.put(new SimpleKey(“0”), new SimpleValue(“2”));<br>map.put(new SimpleKey(“3”), new SimpleValue(“4”));</p>
<p>Set<SimpleValue> allValues = map.get(new SimpleKey(“0”));</p>
<p>List<SimpleValue> newValues = Arrays.asList(new SimpleValue(“7”), new SimpleValue(“6”), new SimpleValue(“5”));<br>Set<SimpleValue> oldValues = map.replaceValues(new SimpleKey(“0”), newValues);</p>
<p>Set<SimpleValue> removedValues = map.removeAll(new SimpleKey(“0”));</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="基于列表（List）的多值映射（Multimap）"><a href="#基于列表（List）的多值映射（Multimap）" class="headerlink" title="基于列表（List）的多值映射（Multimap）"></a>基于列表（List）的多值映射（Multimap）</h3><p>基于List的Multimap在保持插入顺序的同时允许一个字段下包含重复的元素。</p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><p>RListMultimap&lt;SimpleKey, SimpleValue&gt; map = redisson.getListMultimap(“test1”);<br>map.put(new SimpleKey(“0”), new SimpleValue(“1”));<br>map.put(new SimpleKey(“0”), new SimpleValue(“2”));<br>map.put(new SimpleKey(“0”), new SimpleValue(“1”));<br>map.put(new SimpleKey(“3”), new SimpleValue(“4”));</p>
<p>List<SimpleValue> allValues = map.get(new SimpleKey(“0”));</p>
<p>Collection<SimpleValue> newValues = Arrays.asList(new SimpleValue(“7”), new SimpleValue(“6”), new SimpleValue(“5”));<br>List<SimpleValue> oldValues = map.replaceValues(new SimpleKey(“0”), newValues);</p>
<p>List<SimpleValue> removedValues = map.removeAll(new SimpleKey(“0”));</p>
<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="多值映射（Multimap）淘汰机制（Eviction）"><a href="#多值映射（Multimap）淘汰机制（Eviction）" class="headerlink" title="多值映射（Multimap）淘汰机制（Eviction）"></a>多值映射（Multimap）淘汰机制（Eviction）</h3><p>Multimap对象的淘汰机制是通过不同的接口来实现的。它们是RSetMultimapCache接口和RListMultimapCache接口，分别对应的是Set和List的Multimaps。</p>
<p>所有过期元素都是通过org.redisson.EvictionScheduler实例来实现定期清理的。为了保证资源的有效利用，每次运行最多清理100个过期元素。任务的启动时间将根据上次实际清理数量自动调整，间隔时间趋于1秒到2小时之间。比如该次清理时删除了100条元素，那么下次执行清理的时间将在1秒以后（最小间隔时间）。一旦该次清理数量少于上次清理数量，时间间隔将增加1.5倍。</p>
<p>RSetMultimapCache的使用范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RSetMultimapCache&lt;String, String&gt; multimap &#x3D; redisson.getSetMultimapCache(&quot;myMultimap&quot;);</span><br><span class="line">multimap.put(&quot;1&quot;, &quot;a&quot;);</span><br><span class="line">multimap.put(&quot;1&quot;, &quot;b&quot;);</span><br><span class="line">multimap.put(&quot;1&quot;, &quot;c&quot;);</span><br><span class="line"></span><br><span class="line">multimap.put(&quot;2&quot;, &quot;e&quot;);</span><br><span class="line">multimap.put(&quot;2&quot;, &quot;f&quot;);</span><br><span class="line"></span><br><span class="line">multimap.expireKey(&quot;2&quot;, 10, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<h2 id="3、集（Set）"><a href="#3、集（Set）" class="headerlink" title="3、集（Set）"></a>3、集（Set）</h2><p>基于Redis的Redisson的分布式Set结构的RSet Java对象实现了java.util.Set接口。通过元素的相互状态比较保证了每个元素的唯一性。该对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RSet&lt;SomeObject&gt; set &#x3D; redisson.getSet(&quot;anySet&quot;);</span><br><span class="line">set.add(new SomeObject());</span><br><span class="line">set.remove(new SomeObject());</span><br><span class="line">Redisson PRO版本中的Set对象还可以在Redis集群环境下支持单集合数据分片。</span><br></pre></td></tr></table></figure>
<h3 id="集（Set）淘汰机制（Eviction）"><a href="#集（Set）淘汰机制（Eviction）" class="headerlink" title="集（Set）淘汰机制（Eviction）"></a>集（Set）淘汰机制（Eviction）</h3><p>基于Redis的Redisson的分布式RSetCache Java对象在基于RSet的前提下实现了针对单个元素的淘汰机制。由于RSetCache是基于RSet实现的，使它还集成了java.util.Set接口。</p>
<p>目前的Redis自身并不支持Set当中的元素淘汰，因此所有过期元素都是通过org.redisson.EvictionScheduler实例来实现定期清理的。为了保证资源的有效利用，每次运行最多清理100个过期元素。任务的启动时间将根据上次实际清理数量自动调整，间隔时间趋于1秒到2小时之间。比如该次清理时删除了100条元素，那么下次执行清理的时间将在1秒以后（最小间隔时间）。一旦该次清理数量少于上次清理数量，时间间隔将增加1.5倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSetCache&lt;SomeObject&gt; set &#x3D; redisson.getSetCache(&quot;anySet&quot;);</span><br><span class="line">&#x2F;&#x2F; ttl &#x3D; 10 seconds</span><br><span class="line">set.add(new SomeObject(), 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h3 id="集（Set）数据分片（Sharding）"><a href="#集（Set）数据分片（Sharding）" class="headerlink" title="集（Set）数据分片（Sharding）"></a>集（Set）数据分片（Sharding）</h3><p>Set数据分片是Redis集群模式下的一个功能。Redisson提供的分布式RClusteredSet Java对象也是基于RSet实现的。在这里可以获取更多的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RClusteredSet&lt;SomeObject&gt; set &#x3D; redisson.getClusteredSet(&quot;anySet&quot;);</span><br><span class="line">set.add(new SomeObject());</span><br><span class="line">set.remove(new SomeObject());</span><br></pre></td></tr></table></figure>
<p>除了RClusteredSet以外，Redisson还提供了另一种集群模式下的分布式集（Set），它不仅提供了透明的数据分片功能，还为每个元素提供了淘汰机制。RClusteredSetCache 类分别同时提供了RClusteredSet 和RSetCache 这两个接口的实现。当然这些都是基于java.util.Set的接口实现上的。</p>
<p>该功能仅限于Redisson PRO版本。</p>
<h2 id="4、有序集（SortedSet）"><a href="#4、有序集（SortedSet）" class="headerlink" title="4、有序集（SortedSet）"></a>4、有序集（SortedSet）</h2><p>基于Redis的Redisson的分布式RSortedSet Java对象实现了java.util.SortedSet接口。在保证元素唯一性的前提下，通过比较器（Comparator）接口实现了对元素的排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RSortedSet&lt;Integer&gt; set &#x3D; redisson.getSortedSet(&quot;anySet&quot;);</span><br><span class="line">set.trySetComparator(new MyComparator()); &#x2F;&#x2F; 配置元素比较器</span><br><span class="line">set.add(3);</span><br><span class="line">set.add(1);</span><br><span class="line">set.add(2);</span><br><span class="line"></span><br><span class="line">set.removeAsync(0);</span><br><span class="line">set.addAsync(5);</span><br></pre></td></tr></table></figure>
<h2 id="5、计分排序集（ScoredSortedSet）"><a href="#5、计分排序集（ScoredSortedSet）" class="headerlink" title="5、计分排序集（ScoredSortedSet）"></a>5、计分排序集（ScoredSortedSet）</h2><p>基于Redis的Redisson的分布式RScoredSortedSet Java对象是一个可以按插入时指定的元素评分排序的集合。它同时还保证了元素的唯一性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RScoredSortedSet&lt;SomeObject&gt; set &#x3D; redisson.getScoredSortedSet(&quot;simple&quot;);</span><br><span class="line"></span><br><span class="line">set.add(0.13, new SomeObject(a, b));</span><br><span class="line">set.addAsync(0.251, new SomeObject(c, d));</span><br><span class="line">set.add(0.302, new SomeObject(g, d));</span><br><span class="line"></span><br><span class="line">set.pollFirst();</span><br><span class="line">set.pollLast();</span><br><span class="line"></span><br><span class="line">int index &#x3D; set.rank(new SomeObject(g, d)); &#x2F;&#x2F; 获取元素在集合中的位置</span><br><span class="line">Double score &#x3D; set.getScore(new SomeObject(g, d)); &#x2F;&#x2F; 获取元素的评分</span><br></pre></td></tr></table></figure>
<h2 id="6、字典排序集（LexSortedSet）"><a href="#6、字典排序集（LexSortedSet）" class="headerlink" title="6、字典排序集（LexSortedSet）"></a>6、字典排序集（LexSortedSet）</h2><p>基于Redis的Redisson的分布式RLexSortedSet Java对象在实现了java.util.Set<String>接口的同时，将其中的所有字符串元素按照字典顺序排列。它公式还保证了字符串元素的唯一性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RLexSortedSet set &#x3D; redisson.getLexSortedSet(&quot;simple&quot;);</span><br><span class="line">set.add(&quot;d&quot;);</span><br><span class="line">set.addAsync(&quot;e&quot;);</span><br><span class="line">set.add(&quot;f&quot;);</span><br><span class="line"></span><br><span class="line">set.lexRangeTail(&quot;d&quot;, false);</span><br><span class="line">set.lexCountHead(&quot;e&quot;);</span><br><span class="line">set.lexRange(&quot;d&quot;, true, &quot;z&quot;, false);</span><br></pre></td></tr></table></figure>
<h2 id="7、列表（List）"><a href="#7、列表（List）" class="headerlink" title="7、列表（List）"></a>7、列表（List）</h2><p>基于Redis的Redisson分布式列表（List）结构的RList Java对象在实现了java.util.List接口的同时，确保了元素插入时的顺序。该对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RList&lt;SomeObject&gt; list &#x3D; redisson.getList(&quot;anyList&quot;);</span><br><span class="line">list.add(new SomeObject());</span><br><span class="line">list.get(0);</span><br><span class="line">list.remove(new SomeObject());</span><br></pre></td></tr></table></figure>
<h2 id="8、队列（Queue）"><a href="#8、队列（Queue）" class="headerlink" title="8、队列（Queue）"></a>8、队列（Queue）</h2><p>基于Redis的Redisson分布式无界队列（Queue）结构的RQueue Java对象实现了java.util.Queue接口。尽管RQueue对象无初始大小（边界）限制，但对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RQueue&lt;SomeObject&gt; queue &#x3D; redisson.getQueue(&quot;anyQueue&quot;);</span><br><span class="line">queue.add(new SomeObject());</span><br><span class="line">SomeObject obj &#x3D; queue.peek();</span><br><span class="line">SomeObject someObj &#x3D; queue.poll();</span><br></pre></td></tr></table></figure>
<h2 id="9、双端队列（Deque）"><a href="#9、双端队列（Deque）" class="headerlink" title="9、双端队列（Deque）"></a>9、双端队列（Deque）</h2><p>基于Redis的Redisson分布式无界双端队列（Deque）结构的RDeque Java对象实现了java.util.Deque接口。尽管RDeque对象无初始大小（边界）限制，但对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RDeque&lt;SomeObject&gt; queue &#x3D; redisson.getDeque(&quot;anyDeque&quot;);</span><br><span class="line">queue.addFirst(new SomeObject());</span><br><span class="line">queue.addLast(new SomeObject());</span><br><span class="line">SomeObject obj &#x3D; queue.removeFirst();</span><br><span class="line">SomeObject someObj &#x3D; queue.removeLast();</span><br></pre></td></tr></table></figure>
<h2 id="10、阻塞队列（Blocking-Queue）"><a href="#10、阻塞队列（Blocking-Queue）" class="headerlink" title="10、阻塞队列（Blocking Queue）"></a>10、阻塞队列（Blocking Queue）</h2><p>基于Redis的Redisson分布式无界阻塞队列（Blocking Queue）结构的RBlockingQueue Java对象实现了java.util.concurrent.BlockingQueue接口。尽管RBlockingQueue对象无初始大小（边界）限制，但对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RBlockingQueue&lt;SomeObject&gt; queue &#x3D; redisson.getBlockingQueue(&quot;anyQueue&quot;);</span><br><span class="line">queue.offer(new SomeObject());</span><br><span class="line"></span><br><span class="line">SomeObject obj &#x3D; queue.peek();</span><br><span class="line">SomeObject someObj &#x3D; queue.poll();</span><br><span class="line">SomeObject ob &#x3D; queue.poll(10, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>poll, pollFromAny, pollLastAndOfferFirstTo和take方法内部采用话题订阅发布实现，在Redis节点故障转移（主从切换）或断线重连以后，内置的相关话题监听器将自动完成话题的重新订阅。</p>
<h2 id="11、有界阻塞队列（Bounded-Blocking-Queue）"><a href="#11、有界阻塞队列（Bounded-Blocking-Queue）" class="headerlink" title="11、有界阻塞队列（Bounded Blocking Queue）"></a>11、有界阻塞队列（Bounded Blocking Queue）</h2><p>基于Redis的Redisson分布式有界阻塞队列（Bounded Blocking Queue）结构的RBoundedBlockingQueue Java对象实现了java.util.concurrent.BlockingQueue接口。该对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。队列的初始容量（边界）必须在使用前设定好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RBoundedBlockingQueue&lt;SomeObject&gt; queue &#x3D; redisson.getBoundedBlockingQueue(&quot;anyQueue&quot;);</span><br><span class="line">&#x2F;&#x2F; 如果初始容量（边界）设定成功则返回&#96;真（true）&#96;，</span><br><span class="line">&#x2F;&#x2F; 如果初始容量（边界）已近存在则返回&#96;假（false）&#96;。</span><br><span class="line">queue.trySetCapacity(2);</span><br><span class="line"></span><br><span class="line">queue.offer(new SomeObject(1));</span><br><span class="line">queue.offer(new SomeObject(2));</span><br><span class="line">&#x2F;&#x2F; 此时容量已满，下面代码将会被阻塞，直到有空闲为止。</span><br><span class="line">queue.put(new SomeObject());</span><br><span class="line"></span><br><span class="line">SomeObject obj &#x3D; queue.peek();</span><br><span class="line">SomeObject someObj &#x3D; queue.poll();</span><br><span class="line">SomeObject ob &#x3D; queue.poll(10, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>poll, pollFromAny, pollLastAndOfferFirstTo和take方法内部采用话题订阅发布实现，在Redis节点故障转移（主从切换）或断线重连以后，内置的相关话题监听器将自动完成话题的重新订阅。</p>
<h2 id="12-阻塞双端队列（Blocking-Deque）"><a href="#12-阻塞双端队列（Blocking-Deque）" class="headerlink" title="12. 阻塞双端队列（Blocking Deque）"></a>12. 阻塞双端队列（Blocking Deque）</h2><p>基于Redis的Redisson分布式无界阻塞双端队列（Blocking Deque）结构的RBlockingDeque Java对象实现了java.util.concurrent.BlockingDeque接口。尽管RBlockingDeque对象无初始大小（边界）限制，但对象的最大容量受Redis限制，最大元素数量是4 294 967 295个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RBlockingDeque&lt;Integer&gt; deque &#x3D; redisson.getBlockingDeque(&quot;anyDeque&quot;);</span><br><span class="line">deque.putFirst(1);</span><br><span class="line">deque.putLast(2);</span><br><span class="line">Integer firstValue &#x3D; queue.takeFirst();</span><br><span class="line">Integer lastValue &#x3D; queue.takeLast();</span><br><span class="line">Integer firstValue &#x3D; queue.pollFirst(10, TimeUnit.MINUTES);</span><br><span class="line">Integer lastValue &#x3D; queue.pollLast(3, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>poll, pollFromAny, pollLastAndOfferFirstTo和take方法内部采用话题订阅发布实现，在Redis节点故障转移（主从切换）或断线重连以后，内置的相关话题监听器将自动完成话题的重新订阅。</p>
<h2 id="13-阻塞公平队列（Blocking-Fair-Queue）"><a href="#13-阻塞公平队列（Blocking-Fair-Queue）" class="headerlink" title="13. 阻塞公平队列（Blocking Fair Queue）"></a>13. 阻塞公平队列（Blocking Fair Queue）</h2><p>基于Redis的Redisson分布式无界阻塞公平队列（Blocking Fair Queue）结构的RBlockingFairQueue Java对象在实现Redisson分布式无界阻塞队列（Blocking Queue）结构RBlockingQueue接口的基础上，解决了多个队列消息的处理者在复杂的网络环境下，网络延时的影响使“较远”的客户端最终收到消息数量低于“较近”的客户端的问题。从而解决了这种现象引发的个别处理节点过载的情况。</p>
<p>以分布式无界阻塞队列为基础，采用公平获取消息的机制，不仅保证了poll、pollFromAny、pollLastAndOfferFirstTo和take方法获取消息的先入顺序，还能让队列里的消息被均匀的发布到处在复杂分布式环境中的各个处理节点里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RBlockingFairQueue queue &#x3D; redisson.getBlockingFairQueue(&quot;myQueue&quot;);</span><br><span class="line">queue.offer(new SomeObject());</span><br><span class="line"></span><br><span class="line">SomeObject obj &#x3D; queue.peek();</span><br><span class="line">SomeObject someObj &#x3D; queue.poll();</span><br><span class="line">SomeObject ob &#x3D; queue.poll(10, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>该功能仅限于Redisson PRO版本。</p>
<h2 id="14-阻塞公平双端队列（Blocking-Fair-Deque）"><a href="#14-阻塞公平双端队列（Blocking-Fair-Deque）" class="headerlink" title="14. 阻塞公平双端队列（Blocking Fair Deque）"></a>14. 阻塞公平双端队列（Blocking Fair Deque）</h2><p>基于Redis的Redisson分布式无界阻塞公平双端队列（Blocking Fair Deque）结构的RBlockingFairDeque Java对象在实现Redisson分布式无界阻塞双端队列（Blocking Deque）结构RBlockingDeque接口的基础上，解决了多个队列消息的处理者在复杂的网络环境下，网络延时的影响使“较远”的客户端最终收到消息数量低于“较近”的客户端的问题。从而解决了这种现象引发的个别处理节点过载的情况。</p>
<p>以分布式无界阻塞双端队列为基础，采用公平获取消息的机制，不仅保证了poll、take、pollFirst、takeFirst、pollLast和takeLast方法获取消息的先入顺序，还能让队列里的消息被均匀的发布到处在复杂分布式环境中的各个处理节点里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RBlockingFairDeque deque &#x3D; redisson.getBlockingFairDeque(&quot;myDeque&quot;);</span><br><span class="line">deque.offer(new SomeObject());</span><br><span class="line"></span><br><span class="line">SomeObject firstElement &#x3D; queue.peekFirst();</span><br><span class="line">SomeObject firstElement &#x3D; queue.pollFirst();</span><br><span class="line">SomeObject firstElement &#x3D; queue.pollFirst(10, TimeUnit.MINUTES);</span><br><span class="line">SomeObject firstElement &#x3D; queue.takeFirst();</span><br><span class="line"></span><br><span class="line">SomeObject lastElement &#x3D; queue.peekLast();</span><br><span class="line">SomeObject lastElement &#x3D; queue.pollLast();</span><br><span class="line">SomeObject lastElement &#x3D; queue.pollLast(10, TimeUnit.MINUTES);</span><br><span class="line">SomeObject lastElement &#x3D; queue.takeLast();</span><br></pre></td></tr></table></figure>
<p>该功能仅限于Redisson PRO版本。</p>
<h2 id="15-延迟队列（Delayed-Queue）"><a href="#15-延迟队列（Delayed-Queue）" class="headerlink" title="15. 延迟队列（Delayed Queue）"></a>15. 延迟队列（Delayed Queue）</h2><p>基于Redis的Redisson分布式延迟队列（Delayed Queue）结构的RDelayedQueue Java对象在实现了RQueue接口的基础上提供了向队列按要求延迟添加项目的功能。该功能可以用来实现消息传送延迟按几何增长或几何衰减的发送策略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RQueue&lt;String&gt; distinationQueue &#x3D; ...</span><br><span class="line">RDelayedQueue&lt;String&gt; delayedQueue &#x3D; getDelayedQueue(distinationQueue);</span><br><span class="line">&#x2F;&#x2F; 10秒钟以后将消息发送到指定队列</span><br><span class="line">delayedQueue.offer(&quot;msg1&quot;, 10, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F; 一分钟以后将消息发送到指定队列</span><br><span class="line">delayedQueue.offer(&quot;msg2&quot;, 1, TimeUnit.MINUTES);</span><br><span class="line">在该对象不再需要的情况下，应该主动销毁。仅在相关的Redisson对象也需要关闭的时候可以不用主动销毁。</span><br><span class="line"></span><br><span class="line">RDelayedQueue&lt;String&gt; delayedQueue &#x3D; ...</span><br><span class="line">delayedQueue.destroy();</span><br></pre></td></tr></table></figure>
<h2 id="16-优先队列（Priority-Queue）"><a href="#16-优先队列（Priority-Queue）" class="headerlink" title="16. 优先队列（Priority Queue）"></a>16. 优先队列（Priority Queue）</h2><p>基于Redis的Redisson分布式优先队列（Priority Queue）Java对象实现了java.util.Queue的接口。可以通过比较器（Comparator）接口来对元素排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RPriorityQueue&lt;Integer&gt; queue &#x3D; redisson.getPriorityQueue(&quot;anyQueue&quot;);</span><br><span class="line">queue.trySetComparator(new MyComparator()); &#x2F;&#x2F; 指定对象比较器</span><br><span class="line">queue.add(3);</span><br><span class="line">queue.add(1);</span><br><span class="line">queue.add(2);</span><br><span class="line"></span><br><span class="line">queue.removeAsync(0);</span><br><span class="line">queue.addAsync(5);</span><br><span class="line"></span><br><span class="line">queue.poll();</span><br></pre></td></tr></table></figure>
<h2 id="17-优先双端队列（Priority-Deque）"><a href="#17-优先双端队列（Priority-Deque）" class="headerlink" title="17. 优先双端队列（Priority Deque）"></a>17. 优先双端队列（Priority Deque）</h2><p>基于Redis的Redisson分布式优先双端队列（Priority Deque）Java对象实现了java.util.Deque的接口。可以通过比较器（Comparator）接口来对元素排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RPriorityDeque&lt;Integer&gt; queue &#x3D; redisson.getPriorityDeque(&quot;anyQueue&quot;);</span><br><span class="line">queue.trySetComparator(new MyComparator()); &#x2F;&#x2F; 指定对象比较器</span><br><span class="line">queue.addLast(3);</span><br><span class="line">queue.addFirst(1);</span><br><span class="line">queue.add(2);</span><br><span class="line"></span><br><span class="line">queue.removeAsync(0);</span><br><span class="line">queue.addAsync(5);</span><br><span class="line"></span><br><span class="line">queue.pollFirst();</span><br><span class="line">queue.pollLast();</span><br></pre></td></tr></table></figure>
<h2 id="18-优先阻塞队列（Priority-Blocking-Queue）"><a href="#18-优先阻塞队列（Priority-Blocking-Queue）" class="headerlink" title="18. 优先阻塞队列（Priority Blocking Queue）"></a>18. 优先阻塞队列（Priority Blocking Queue）</h2><p>基于Redis的分布式无界优先阻塞队列（Priority Blocking Queue）Java对象的结构与java.util.concurrent.PriorityBlockingQueue类似。可以通过比较器（Comparator）接口来对元素排序。PriorityBlockingQueue的最大容量是4 294 967 295个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RPriorityBlockingQueue&lt;Integer&gt; queue &#x3D; redisson.getPriorityBlockingQueue(&quot;anyQueue&quot;);</span><br><span class="line">queue.trySetComparator(new MyComparator()); &#x2F;&#x2F; 指定对象比较器</span><br><span class="line">queue.add(3);</span><br><span class="line">queue.add(1);</span><br><span class="line">queue.add(2);</span><br><span class="line"></span><br><span class="line">queue.removeAsync(0);</span><br><span class="line">queue.addAsync(5);</span><br><span class="line"></span><br><span class="line">queue.take();</span><br></pre></td></tr></table></figure>
<p>当Redis服务端断线重连以后，或Redis服务端发生主从切换，并重新建立连接后，断线时正在使用poll，pollLastAndOfferFirstTo或take方法的对象Redisson将自动再次为其订阅相关的话题。</p>
<h2 id="19-优先阻塞双端队列（Priority-Blocking-Deque）"><a href="#19-优先阻塞双端队列（Priority-Blocking-Deque）" class="headerlink" title="19. 优先阻塞双端队列（Priority Blocking Deque）"></a>19. 优先阻塞双端队列（Priority Blocking Deque）</h2><p>基于Redis的分布式无界优先阻塞双端队列（Priority Blocking Deque）Java对象实现了java.util.Deque的接口。addLast、 addFirst、push方法不能再这个对里使用。PriorityBlockingDeque的最大容量是4 294 967 295个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RPriorityBlockingDeque&lt;Integer&gt; queue &#x3D; redisson.getPriorityBlockingDeque(&quot;anyQueue&quot;);</span><br><span class="line">queue.trySetComparator(new MyComparator()); &#x2F;&#x2F; 指定对象比较器</span><br><span class="line">queue.add(2);</span><br><span class="line"></span><br><span class="line">queue.removeAsync(0);</span><br><span class="line">queue.addAsync(5);</span><br><span class="line"></span><br><span class="line">queue.pollFirst();</span><br><span class="line">queue.pollLast();</span><br><span class="line">queue.takeFirst();</span><br><span class="line">queue.takeLast();</span><br></pre></td></tr></table></figure>
<p>当Redis服务端断线重连以后，或Redis服务端发生主从切换，并重新建立连接后，断线时正在使用poll，pollLastAndOfferFirstTo或take方法的对象Redisson将自动再次为其订阅相关的话题。</p>
<h1 id="六、分布式锁和同步器"><a href="#六、分布式锁和同步器" class="headerlink" title="六、分布式锁和同步器"></a>六、分布式锁和同步器</h1><h2 id="1-可重入锁（Reentrant-Lock）"><a href="#1-可重入锁（Reentrant-Lock）" class="headerlink" title="1. 可重入锁（Reentrant Lock）"></a>1. 可重入锁（Reentrant Lock）</h2><p>基于Redis的Redisson分布式可重入锁RLock Java对象实现了java.util.concurrent.locks.Lock接口。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);</span><br><span class="line">&#x2F;&#x2F; 最常见的使用方法</span><br><span class="line">lock.lock();</span><br></pre></td></tr></table></figure>
<p>大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。</p>
<p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 加锁以后10秒钟自动解锁</span><br><span class="line">&#x2F;&#x2F; 无需调用unlock方法手动解锁</span><br><span class="line">lock.lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span><br><span class="line">boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">if (res) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Redisson同时还为分布式锁提供了异步执行的相关方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLock lock &#x3D; redisson.getLock(&quot;anyLock&quot;);</span><br><span class="line">lock.lockAsync();</span><br><span class="line">lock.lockAsync(10, TimeUnit.SECONDS);</span><br><span class="line">Future&lt;Boolean&gt; res &#x3D; lock.tryLockAsync(100, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>RLock对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出IllegalMonitorStateException错误。但是如果遇到需要其他进程也能解锁的情况，请使用分布式信号量Semaphore 对象.</p>
<h2 id="2-公平锁（Fair-Lock）"><a href="#2-公平锁（Fair-Lock）" class="headerlink" title="2. 公平锁（Fair Lock）"></a>2. 公平锁（Fair Lock）</h2><p>基于Redis的Redisson分布式可重入公平锁也是实现了java.util.concurrent.locks.Lock接口的一种RLock对象。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RLock fairLock &#x3D; redisson.getFairLock(&quot;anyLock&quot;);</span><br><span class="line">&#x2F;&#x2F; 最常见的使用方法</span><br><span class="line">fairLock.lock();</span><br></pre></td></tr></table></figure>
<p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 10秒钟以后自动解锁</span><br><span class="line">&#x2F;&#x2F; 无需调用unlock方法手动解锁</span><br><span class="line">fairLock.lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span><br><span class="line">boolean res &#x3D; fairLock.tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">fairLock.unlock();</span><br><span class="line">Redisson同时还为分布式可重入公平锁提供了异步执行的相关方法：</span><br><span class="line"></span><br><span class="line">RLock fairLock &#x3D; redisson.getFairLock(&quot;anyLock&quot;);</span><br><span class="line">fairLock.lockAsync();</span><br><span class="line">fairLock.lockAsync(10, TimeUnit.SECONDS);</span><br><span class="line">Future&lt;Boolean&gt; res &#x3D; fairLock.tryLockAsync(100, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h2 id="3-联锁（MultiLock）"><a href="#3-联锁（MultiLock）" class="headerlink" title="3. 联锁（MultiLock）"></a>3. 联锁（MultiLock）</h2><p>基于Redis的Redisson分布式联锁RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RLock lock1 &#x3D; redissonInstance1.getLock(&quot;lock1&quot;);</span><br><span class="line">RLock lock2 &#x3D; redissonInstance2.getLock(&quot;lock2&quot;);</span><br><span class="line">RLock lock3 &#x3D; redissonInstance3.getLock(&quot;lock3&quot;);</span><br><span class="line"></span><br><span class="line">RedissonMultiLock lock &#x3D; new RedissonMultiLock(lock1, lock2, lock3);</span><br><span class="line">&#x2F;&#x2F; 同时加锁：lock1 lock2 lock3</span><br><span class="line">&#x2F;&#x2F; 所有的锁都上锁成功才算成功。</span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RedissonMultiLock lock &#x3D; new RedissonMultiLock(lock1, lock2, lock3);</span><br><span class="line">&#x2F;&#x2F; 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开</span><br><span class="line">lock.lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为加锁等待100秒时间，并在加锁成功10秒钟后自动解开</span><br><span class="line">boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h2 id="4-红锁（RedLock）"><a href="#4-红锁（RedLock）" class="headerlink" title="4. 红锁（RedLock）"></a>4. 红锁（RedLock）</h2><p>基于Redis的Redisson红锁RedissonRedLock对象实现了Redlock介绍的加锁算法。该对象也可以用来将多个RLock对象关联为一个红锁，每个RLock对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RLock lock1 &#x3D; redissonInstance1.getLock(&quot;lock1&quot;);</span><br><span class="line">RLock lock2 &#x3D; redissonInstance2.getLock(&quot;lock2&quot;);</span><br><span class="line">RLock lock3 &#x3D; redissonInstance3.getLock(&quot;lock3&quot;);</span><br><span class="line"></span><br><span class="line">RedissonRedLock lock &#x3D; new RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">&#x2F;&#x2F; 同时加锁：lock1 lock2 lock3</span><br><span class="line">&#x2F;&#x2F; 红锁在大部分节点上加锁成功就算成功。</span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RedissonRedLock lock &#x3D; new RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">&#x2F;&#x2F; 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开</span><br><span class="line">lock.lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为加锁等待100秒时间，并在加锁成功10秒钟后自动解开</span><br><span class="line">boolean res &#x3D; lock.tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h2 id="5-读写锁（ReadWriteLock）"><a href="#5-读写锁（ReadWriteLock）" class="headerlink" title="5. 读写锁（ReadWriteLock）"></a>5. 读写锁（ReadWriteLock）</h2><p>基于Redis的Redisson分布式可重入读写锁RReadWriteLock Java对象实现了java.util.concurrent.locks.ReadWriteLock接口。其中读锁和写锁都继承了RLock接口。</p>
<p>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RReadWriteLock rwlock &#x3D; redisson.getReadWriteLock(&quot;anyRWLock&quot;);</span><br><span class="line">&#x2F;&#x2F; 最常见的使用方法</span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">rwlock.writeLock().lock();</span><br></pre></td></tr></table></figure>
<p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 10秒钟以后自动解锁</span><br><span class="line">&#x2F;&#x2F; 无需调用unlock方法手动解锁</span><br><span class="line">rwlock.readLock().lock(10, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">rwlock.writeLock().lock(10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span><br><span class="line">boolean res &#x3D; rwlock.readLock().tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">boolean res &#x3D; rwlock.writeLock().tryLock(100, 10, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h2 id="6-信号量（Semaphore）"><a href="#6-信号量（Semaphore）" class="headerlink" title="6. 信号量（Semaphore）"></a>6. 信号量（Semaphore）</h2><p>基于Redis的Redisson的分布式信号量（Semaphore）Java对象RSemaphore采用了与java.util.concurrent.Semaphore相似的接口和用法。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RSemaphore semaphore &#x3D; redisson.getSemaphore(&quot;semaphore&quot;);</span><br><span class="line">semaphore.acquire();</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">semaphore.acquireAsync();</span><br><span class="line">semaphore.acquire(23);</span><br><span class="line">semaphore.tryAcquire();</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">semaphore.tryAcquireAsync();</span><br><span class="line">semaphore.tryAcquire(23, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">semaphore.tryAcquireAsync(23, TimeUnit.SECONDS);</span><br><span class="line">semaphore.release(10);</span><br><span class="line">semaphore.release();</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">semaphore.releaseAsync();</span><br></pre></td></tr></table></figure>
<h2 id="7-可过期性信号量（PermitExpirableSemaphore）"><a href="#7-可过期性信号量（PermitExpirableSemaphore）" class="headerlink" title="7. 可过期性信号量（PermitExpirableSemaphore）"></a>7. 可过期性信号量（PermitExpirableSemaphore）</h2><p>基于Redis的Redisson可过期性信号量（PermitExpirableSemaphore）是在RSemaphore对象的基础上，为每个信号增加了一个过期时间。每个信号可以通过独立的ID来辨识，释放时只能通过提交这个ID才能释放。它提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RPermitExpirableSemaphore semaphore &#x3D; redisson.getPermitExpirableSemaphore(&quot;mySemaphore&quot;);</span><br><span class="line">String permitId &#x3D; semaphore.acquire();</span><br><span class="line">&#x2F;&#x2F; 获取一个信号，有效期只有2秒钟。</span><br><span class="line">String permitId &#x3D; semaphore.acquire(2, TimeUnit.SECONDS);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">semaphore.release(permitId);</span><br></pre></td></tr></table></figure>
<h2 id="8-闭锁（CountDownLatch）"><a href="#8-闭锁（CountDownLatch）" class="headerlink" title="8. 闭锁（CountDownLatch）"></a>8. 闭锁（CountDownLatch）</h2><p>基于Redisson的Redisson分布式闭锁（CountDownLatch）Java对象RCountDownLatch采用了与java.util.concurrent.CountDownLatch相似的接口和用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RCountDownLatch latch &#x3D; redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);</span><br><span class="line">latch.trySetCount(1);</span><br><span class="line">latch.await();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在其他线程或其他JVM里</span><br><span class="line">RCountDownLatch latch &#x3D; redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);</span><br><span class="line">latch.countDown();</span><br></pre></td></tr></table></figure>
<h1 id="七、分布式服务"><a href="#七、分布式服务" class="headerlink" title="七、分布式服务"></a>七、分布式服务</h1><h2 id="1-分布式远程服务（Remote-Service）"><a href="#1-分布式远程服务（Remote-Service）" class="headerlink" title="1. 分布式远程服务（Remote Service）"></a>1. 分布式远程服务（Remote Service）</h2><p>基于Redis的Java分布式远程服务，可以用来通过共享接口执行存在于另一个Redisson实例里的对象方法。换句话说就是通过Redis实现了Java的远程过程调用（RPC）。分布式远程服务基于可以用POJO对象，方法的参数和返回类不受限制，可以是任何类型。</p>
<p>分布式远程服务（Remote Service）提供了两种类型的RRemoteService实例：</p>
<p><strong>服务端（远端）实例</strong> - 用来执行远程方法（工作者实例即worker instance）. 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RRemoteService remoteService &#x3D; redisson.getRemoteService();</span><br><span class="line">SomeServiceImpl someServiceImpl &#x3D; new SomeServiceImpl();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在调用远程方法以前，应该首先注册远程服务</span><br><span class="line">&#x2F;&#x2F; 只注册了一个服务端工作者实例，只能同时执行一个并发调用</span><br><span class="line">remoteService.register(SomeServiceInterface.class, someServiceImpl);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册了12个服务端工作者实例，可以同时执行12个并发调用</span><br><span class="line">remoteService.register(SomeServiceInterface.class, someServiceImpl, 12);</span><br></pre></td></tr></table></figure>
<p><strong>客户端（本地）实例</strong> - 用来请求远程方法. 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RRemoteService remoteService &#x3D; redisson.getRemoteService();</span><br><span class="line">SomeServiceInterface service &#x3D; remoteService.get(SomeServiceInterface.class);</span><br><span class="line"></span><br><span class="line">String result &#x3D; service.doSomeStuff(1L, &quot;secondParam&quot;, new AnyParam());</span><br></pre></td></tr></table></figure>
<p>客户端和服务端必须使用一样的共享接口，生成两者的Redisson实例必须采用相同的连接配置。客户端和服务端实例可以运行在同一个JVM里，也可以是不同的。客户端和服务端的数量不收限制。（注意：尽管Redisson不做任何限制，但是Redis的限制仍然有效。）</p>
<p>在服务端工作者可用实例数量 大于1 的时候，将并行执行并发调用的远程方法。</p>
<p>并行执行工作者数量计算方法如下： T = R * N</p>
<p>T - 并行执行工作者总数 R - Redisson服务端数量 N - 注册服务端时指定的执行工作者数量</p>
<p>超过该数量的并发请求将在列队中等候执行。</p>
<p>在服务端工作者实例可用数量为 1 时，远程过程调用将会按 顺序执行。这种情况下，每次只有一个请求将会被执行，其他请求将在列队中等候执行。</p>
<h3 id="分布式远程服务工作流程"><a href="#分布式远程服务工作流程" class="headerlink" title="分布式远程服务工作流程"></a>分布式远程服务工作流程</h3><p>分布式远程服务为每个注册接口建立了两个列队。一个列队用于请求，由服务端监听，另一个列队用于应答回执和结果回复，由客户端监听。应答回执用于判定该请求是否已经被接受。如果在指定的超时时间内没有被执行工作者执行将会抛出RemoteServiceAckTimeoutException错误。</p>
<p>下图描述了每次发起远程过程调用请求的工作流程。</p>
<p><img src="https://img.huyunshun.com/img/20200423150409.png" alt="20200423150409"></p>
<h3 id="发送即不管（Fire-and-Forget）模式和应答回执（Ack-Response）模式"><a href="#发送即不管（Fire-and-Forget）模式和应答回执（Ack-Response）模式" class="headerlink" title="发送即不管（Fire-and-Forget）模式和应答回执（Ack-Response）模式"></a>发送即不管（Fire-and-Forget）模式和应答回执（Ack-Response）模式</h3><p>分布式远程服务通过org.redisson.core.RemoteInvocationOptions类，为每个远程过程调用提供了一些可配置选项。这些选项可以用来指定和修改请求超时和选择跳过应答回执或结果的发送模式。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 应答回执超时1秒钟，远程执行超时30秒钟</span><br><span class="line">RemoteInvocationOptions options &#x3D; RemoteInvocationOptions.defaults();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 无需应答回执，远程执行超时30秒钟</span><br><span class="line">RemoteInvocationOptions options &#x3D; RemoteInvocationOptions.defaults().noAck();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应答回执超时1秒钟，不等待执行结果</span><br><span class="line">RemoteInvocationOptions options &#x3D; RemoteInvocationOptions.defaults().noResult();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应答回执超时1分钟，不等待执行结果</span><br><span class="line">RemoteInvocationOptions options &#x3D; RemoteInvocationOptions.defaults().expectAckWithin(1, TimeUnit.MINUTES).noResult();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发送即不管（Fire-and-Forget）模式，无需应答回执，不等待结果</span><br><span class="line">RemoteInvocationOptions options &#x3D; RemoteInvocationOptions.defaults().noAck().noResult();</span><br><span class="line"></span><br><span class="line">RRemoteService remoteService &#x3D; redisson.getRemoteService();</span><br><span class="line">YourService service &#x3D; remoteService.get(YourService.class, options);</span><br></pre></td></tr></table></figure>

<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>远程过程调用也可以采用异步的方式执行。异步调用需要单独提交一个带有@RRemoteAsync注解（annotation）的异步接口类。异步接口方法签名必须与远程接口的方法签名相符。异步接口的返回类必须是org.redisson.api.RFuture对象或其子对象。在调用RRemoteService.get方法时将对异步接口的方法进行验证。异步接口无须包含所有的远程接口里的方法，只需要包含要求异步执行的方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RemoteInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Long <span class="title">someMethod1</span><span class="params">(Long param1, String param2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someMethod2</span><span class="params">(MyObject param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyObject <span class="title">someMethod3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配远程接口的异步接口</span></span><br><span class="line"><span class="meta">@RRemoteAsync</span>(RemoteInterface<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RemoteInterfaceAsync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">RFuture&lt;Long&gt; <span class="title">someMethod1</span><span class="params">(Long param1, String param2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">RFuture&lt;Void&gt; <span class="title">someMethod2</span><span class="params">(MyObject param)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RRemoteService remoteService = redisson.getRemoteService();</span><br><span class="line">RemoteInterfaceAsync asyncService = remoteService.get(RemoteInterfaceAsync<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>** 取消异步调用 **<br>通过调用Future.cancel()方法可以非常方便的取消一个异步调用。分布式远程服务允许在三个阶段中任何一个阶段取消异步调用：</p>
<ul>
<li>远程调用请求在列队中排队阶段</li>
<li>远程调用请求已经被分布式远程服务接受，还未发送应答回执，执行尚未开始。</li>
<li>远程调用请求已经在执行阶段</li>
<li>想要正确的处理第三个阶段，在服务端代码里应该检查Thread.currentThread().isInterrupted()的返回状态。范例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 远程接口</span><br><span class="line">public interface MyRemoteInterface &#123;</span><br><span class="line"></span><br><span class="line">    Long myBusyMethod(Long param1, String param2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 匹配远程接口的异步接口</span><br><span class="line">@RRemoteAsync(MyRemoteInterface.class)</span><br><span class="line">public interface MyRemoteInterfaceAsync &#123;</span><br><span class="line"></span><br><span class="line">    RFuture&lt;Long&gt; myBusyMethod(Long param1, String param2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 远程接口的实现</span><br><span class="line">public class MyRemoteServiceImpl implements MyRemoteInterface &#123;</span><br><span class="line"></span><br><span class="line">   public Long myBusyMethod(Long param1, String param2) &#123;</span><br><span class="line">       for (long i &#x3D; 0; i &lt; Long.MAX_VALUE; i++) &#123;</span><br><span class="line">           iterations.incrementAndGet();</span><br><span class="line">           if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(&quot;interrupted! &quot; + i);</span><br><span class="line">                return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RRemoteService remoteService &#x3D; redisson.getRemoteService();</span><br><span class="line">ExecutorService executor &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line">&#x2F;&#x2F; 注册远程服务的服务端的同时，通过单独指定的ExecutorService来配置执行线程池</span><br><span class="line">MyRemoteInterface serviceImpl &#x3D; new MyRemoteServiceImpl();</span><br><span class="line">remoteService.register(MyRemoteInterface.class, serviceImpl, 5, executor);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步调用方法</span><br><span class="line">MyRemoteInterfaceAsync asyncService &#x3D; remoteService.get(MyRemoteInterfaceAsync.class);</span><br><span class="line">RFuture&lt;Long&gt; future &#x3D; asyncService.myBusyMethod(1L, &quot;someparam&quot;);</span><br><span class="line">&#x2F;&#x2F; 取消异步调用</span><br><span class="line">future.cancel(true);</span><br></pre></td></tr></table></figure>
<h2 id="2、分布式实时对象（Live-Object）服务"><a href="#2、分布式实时对象（Live-Object）服务" class="headerlink" title="2、分布式实时对象（Live Object）服务"></a>2、分布式实时对象（Live Object）服务</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3>分布式实时对象（Live Object） 可以被理解为一个功能强化后的Java对象。该对象不仅可以被一个JVM里的各个线程相引用，还可以被多个位于不同JVM里的线程同时引用。</li>
</ul>
<p>Redisson分布式实时对象（Redisson Live Object，简称RLO）运用即时生成的代理类（Proxy），将一个指定的普通Java类里的所有字段，以及针对这些字段的操作全部映射到一个Redis Hash的数据结构，实现这种理念。每个字段的get和set方法最终被转译为针对同一个Redis Hash的hget和hset命令，从而使所有连接到同一个Redis节点的所有可以客户端同时对一个指定的对象进行操作。众所周知，一个对象的状态是由其内部的字段所赋的值来体现的，通过将这些值保存在一个像Redis这样的远程共享的空间的过程，把这个对象强化成了一个分布式对象。这个分布式对象就叫做Redisson分布式实时对象（Redisson Live Object，简称RLO）。</p>
<p>通过使用RLO，运行在不同服务器里的多个程序之间，共享一个对象实例变得和在单机程序里共享一个对象实例一样了。同时还避免了针对任何一个字段操作都需要将整个对象序列化和反序列化的繁琐，进而降低了程序开发的复杂性和其数据模型的复杂性：从任何一个客户端修改一个字段的值，处在其他服务器上的客户端即刻便能查看到。而且实现代码与单机程序代码无异。（连接到从节点的客户端仍然受Redis的最终一致性的特性限制）</p>
<p>鉴于Redis是一个单线程的程序，针对实时对象的所有的字段操作可以理解为全部是原子性操作，也就是说在读取一个字段的过程不会担心被其他线程所修改。</p>
<p>通过使用RLO，可以把Redis当作一个允许被多个JVM同时操作且不受GC影响的共享堆（Heap Space）。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>Redisson为分布式实时对象提供了一系列不同功能的注解，其中@REntity和@RId两个注解是分布式实时对象的必要条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@REntity</span><br><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    @RId</span><br><span class="line">    private String id;</span><br><span class="line">    @RIndex</span><br><span class="line">    private String value;</span><br><span class="line">    private MyObject parent;</span><br><span class="line"></span><br><span class="line">    public MyObject(String id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyObject() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; getters and setters</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开始使用分布式实时对象以前，需要先通过Redisson服务将指定的对象连接（attach），合并（merge）或持久化（persist）到Redis里。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RLiveObjectService service = redisson.getLiveObjectService();</span><br><span class="line">MyLiveObject myObject = <span class="keyword">new</span> MyLiveObject();</span><br><span class="line">myObject.setId(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// 将myObject对象当前的状态持久化到Redis里并与之保持同步。</span></span><br><span class="line">myObject = service.persist(myObject);</span><br><span class="line"></span><br><span class="line">MyLiveObject myObject = <span class="keyword">new</span> MyLiveObject(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// 抛弃myObject对象当前的状态，并与Redis里的数据建立连接并保持同步。</span></span><br><span class="line">myObject = service.attach(myObject);</span><br><span class="line"></span><br><span class="line">MyLiveObject myObject = <span class="keyword">new</span> MyLiveObject();</span><br><span class="line">myObject.setId(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// 将myObject对象当前的状态与Redis里的数据合并之后与之保持同步。</span></span><br><span class="line">myObject = service.merge(myObject);</span><br><span class="line">myObject.setValue(<span class="string">"somevalue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ID获取分布式实时对象</span></span><br><span class="line">MyLiveObject myObject = service.get(MyLiveObject.class, "1");</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过索引查找分布式实时对象</span></span><br><span class="line">Collection&lt;MyLiveObject&gt; myObjects = service.find(MyLiveObject.class, Conditions.in("value", "somevalue", "somevalue2"));</span><br><span class="line"></span><br><span class="line">Collection&lt;MyLiveObject&gt; myObjects = service.find(MyLiveObject.class, Conditions.and(Conditions.in("value", "somevalue", "somevalue2"), Conditions.eq("secondfield", "test")));</span><br></pre></td></tr></table></figure>
<p>“parent”字段中包含了指向到另一个分布式实时对象的引用，它可以与包含类是同一类型也可以不同。Redisson内部采用了与Java的引用类似的方式保存这个关系，而非将全部对象序列化，可视为与普通的引用同等效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;RLO对象:</span><br><span class="line">MyObject myObject &#x3D; service.get(MyObject.class, &quot;1&quot;);</span><br><span class="line">MyObject myParentObject &#x3D; service.get(MyObject.class, &quot;2&quot;);</span><br><span class="line">myObject.setValue(myParentObject);</span><br></pre></td></tr></table></figure>
<p>RLO的字段类型基本上无限制，可以是任何类型。比如Java util包里的集合类，Map类等，也可以是自定义的对象。只要指定的编码解码器能够对其进行编码和解码操作便可。</p>
<p>尽管RLO的字段类型基本上无限制，个别类型还是受限。注解了RId的字段类型不能是数组类（Array），比如int[]，long[]，double[]，byte[]等等。</p>
<p>为了保证RLO的用法和普通Java对象的用法尽可能一直，Redisson分布式实时对象服务自动将以下普通Java对象转换成与之匹配的Redisson分布式对象RObject。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">普通Java类	转换后的Redisson类</span><br><span class="line">SortedSet.class	RedissonSortedSet.class</span><br><span class="line">Set.class	RedissonSet.class</span><br><span class="line">ConcurrentMap.class	RedissonMap.class</span><br><span class="line">Map.class	RedissonMap.class</span><br><span class="line">BlockingDeque.class	RedissonBlockingDeque.class</span><br><span class="line">Deque.class	RedissonDeque.class</span><br><span class="line">BlockingQueue.class	RedissonBlockingQueue.class</span><br><span class="line">Queue.class	RedissonQueue.class</span><br><span class="line">List.class	RedissonList.class</span><br></pre></td></tr></table></figure>
<p>类型转换将按照从上至下的顺序匹配类型，例如LinkedList类同时实现了Deque，List和Queue，由于Deque排在靠上的位置，因此它将会被转换成一个RedissonDeque类型。</p>
<p>Redisson的分布式对象也采用类似的方式，将自身的状态储存于Redis当中，（几乎^）所有的状态改变都直接映射到Redis里，不在本地JVM中保留任何赋值。（^本地缓存对象除外，比如RLocalCachedMap）</p>
<h3 id="高级使用方法"><a href="#高级使用方法" class="headerlink" title="高级使用方法"></a>高级使用方法</h3><p>正如上述介绍，RLO类其实都是按需实时生成的代理（Proxy）类。生成的代理类和原类都一同缓存Redisson实例里。这个过程会消耗一些时间，在对耗时比较敏感的情况下，建议通过RedissonLiveObjectService提前注册所有的RLO类。这个服务也可以用来注销不再需要的RLO类，也可以用来查询一个类是否已经注册了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLiveObjectService service &#x3D; redisson.getLiveObjectService();</span><br><span class="line">service.registerClass(MyClass.class);</span><br><span class="line">service.unregisterClass(MyClass.class);</span><br><span class="line">Boolean registered &#x3D; service.isClassRegistered(MyClass.class);</span><br></pre></td></tr></table></figure>
<h3 id="注解（Annotation）使用方法"><a href="#注解（Annotation）使用方法" class="headerlink" title="注解（Annotation）使用方法"></a>注解（Annotation）使用方法</h3><p>@REntity </p>
<p>仅适用于类。通过指定@REntity的各个参数，可以详细的对每个RLO类实现特殊定制，以达到改变RLO对象的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namingScheme - 命名方案。命名方案规定了每个实例在Redis中对应key的名称。它不仅被用来与已存在的RLO建立关联，还被用来储存新建的RLO实例。默认采用Redisson自带的DefaultNamingScheme对象。</span><br><span class="line">codec - 编码解码器。在运行当中，Redisson用编码解码器来对RLO中的每个字段进行编码解码。Redisson内部采用了实例池管理不同类型的编码解码器实例。Redisson提供了多种不同的编码解码器，默认使用JsonJacksonCodec。</span><br><span class="line">fieldTransformation - 字段转换模式。如上所述，为了尽可能的保证RLO的用法和普通Java对象一致，Redisson会自动将常用的普通Java对象转换成与其匹配的Redisson分布式对象。这是由于字段转换模式的默认值是ANNOTATION_BASED，修改为IMPLEMENTATION_BASED就可以不转换。</span><br></pre></td></tr></table></figure>
<p>@RId</p>
<p>仅适用于字段。@RId注解只能用在具备区分实例的字段上，这类字段可以理解为一个类的id字段或主键字段。这个字段的值将被命名方案namingScheme用来与事先存在的RLO建立引用。加了该注解的字段是唯一在本地JVM里同时保存赋值的字段。一个类只能有一个字段包含@RId注解。</p>
<p>可以通过指定一个生成器generator策略来实现自动生成这个字段的值。默认不提供生成器。</p>
<p>@RIndex</p>
<p>仅适用于字段。用来指定可用于搜索的字段。可以通过RLiveObjectService.find方法来根据条件精细查找分布式实时对象。查询条件可以是含（IN），或（OR），和（AND）或相等（EQ）以及它们的任意组合。</p>
<p>使用范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyObject &#123;</span><br><span class="line">    @RIndex</span><br><span class="line">    String field1;</span><br><span class="line">    @RIndex</span><br><span class="line">    String field2;</span><br><span class="line">    @RIndex</span><br><span class="line">    String field3;</span><br><span class="line">&#125;</span><br><span class="line">Collection&lt;MyObject&gt; objects &#x3D; RLiveObjectService.find(MyObject.class, Conditions.or(Conditions.and(Conditions.eq(&quot;field1&quot;, &quot;value&quot;), Conditions.eq(&quot;field2&quot;, &quot;value&quot;)), Conditions.in(&quot;field3&quot;, &quot;value1&quot;, &quot;value2&quot;));</span><br></pre></td></tr></table></figure>
<p>@RObjectField</p>
<p>仅适用于字段。允许通过该注解中的namingScheme或codec来改变该字段的命名或编码方式，用来区别于@REntity中指定的预设方式。</p>
<p>@RCascade</p>
<p>仅适用于字段。用来指定包含于分布式实时对象字段内其它对象的级联操作方式。</p>
<p>可选的级联操作方式为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCascadeType.ALL - 执行所有级联操作</span><br><span class="line">RCascadeType.PERSIST - 仅在执行RLiveObjectService.persist()方法时进行级联操作 RCascadeType.DETACH - 仅在执行RLiveObjectService.detach()方法时进行级联操作 RCascadeType.MERGE - 仅在执行RLiveObjectService.merge()方法时进行级联操作 RCascadeType.DELETE - 仅在执行RLiveObjectService.delete()方法时进行级联操作</span><br></pre></td></tr></table></figure>
<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>如上所述，带有RId注解字段的类型不能使数组类，这是因为目前默认的命名方案类DefaultNamingScheme还不能正确地将数组类序列化和反序列化。在改善了DefaultNamingScheme类的不足以后会考虑取消这个限制。另外由于带有RId注解的字段是用来指定Redis中映射的key的名称，因此组建一个只含有唯一一个字段的RLO类是毫无意义的。选用RBucket会更适合这样的场景。</p>
<h2 id="3、分布式执行服务（Executor-Service）"><a href="#3、分布式执行服务（Executor-Service）" class="headerlink" title="3、分布式执行服务（Executor Service）"></a>3、分布式执行服务（Executor Service）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Redisson的分布式执行服务实现了java.util.concurrent.ExecutorService接口，支持在不同的独立节点里执行基于java.util.concurrent.Callable接口或java.lang.Runnable接口或Lambda的任务。这样的任务也可以通过使用Redisson实例，实现对储存在Redis里的数据进行操作。Redisson分布式执行服务是最快速和有效执行分布式运算的方法。</p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>Redisson独立节点不要求任务的类在类路径里。他们会自动被Redisson独立节点的ClassLoader加载。因此每次执行一个新任务时，不需要重启Redisson独立节点。</p>
<p>采用Callable任务的范例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RInject</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RMap&lt;String, Integer&gt; map = redissonClient.getMap(<span class="string">"myMap"</span>);</span><br><span class="line">        Long result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">            result += value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用Runnable任务的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @RInject</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    private long param;</span><br><span class="line"></span><br><span class="line">    public RunnableTask() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RunnableTask(long param) &#123;</span><br><span class="line">        this.param &#x3D; param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        RAtomicLong atomic &#x3D; redissonClient.getAtomicLong(&quot;myAtomic&quot;);</span><br><span class="line">        atomic.addAndGet(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建ExecutorService时可以配置以下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorOptions options &#x3D; ExecutorOptions.defaults()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定重新尝试执行任务的时间间隔。</span><br><span class="line">&#x2F;&#x2F; ExecutorService的工作节点将等待10分钟后重新尝试执行任务</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 设定为0则不进行重试</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 默认值为5分钟</span><br><span class="line">options.taskRetryInterval(10, TimeUnit.MINUTES);</span><br><span class="line">RExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;, options);</span><br><span class="line">executorService.submit(new RunnableTask(123));</span><br><span class="line"></span><br><span class="line">RExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;, options);</span><br><span class="line">Future&lt;Long&gt; future &#x3D; executorService.submit(new CallableTask());</span><br><span class="line">Long result &#x3D; future.get();</span><br></pre></td></tr></table></figure>
<p>使用Lambda任务的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;, options);</span><br><span class="line">Future&lt;Long&gt; future &#x3D; executorService.submit((Callable &amp; Serializable)() -&gt; &#123;</span><br><span class="line">      System.out.println(&quot;task has been executed!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">Long result &#x3D; future.get();</span><br></pre></td></tr></table></figure>
<p>可以通过@RInject注解来为任务实时注入Redisson实例依赖。</p>
<h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><p>通过Future.cancel()方法可以很方便的取消所有已提交的任务。通过对Thread.currentThread().isInterrupted()方法的调用可以在已经处于运行状态的任务里实现任务中断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class CallableTask implements Callable&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @RInject</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Long call() throws Exception &#123;</span><br><span class="line">        RMap&lt;String, Integer&gt; map &#x3D; redissonClient.getMap(&quot;myMap&quot;);</span><br><span class="line">        Long result &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; map里包含了许多的元素</span><br><span class="line">        for (Integer value : map.values()) &#123;</span><br><span class="line">           if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 任务被取消了</span><br><span class="line">                return null;</span><br><span class="line">           &#125;</span><br><span class="line">           result +&#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;);</span><br><span class="line">Future&lt;Long&gt; future &#x3D; executorService.submit(new CallableTask());</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RFuture&lt;Long&gt; future &#x3D; executorService.submitAsync(new CallableTask());</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">future.cancel(true);</span><br></pre></td></tr></table></figure>
<h2 id="4、分布式调度任务服务（Scheduler-Service）"><a href="#4、分布式调度任务服务（Scheduler-Service）" class="headerlink" title="4、分布式调度任务服务（Scheduler Service）"></a>4、分布式调度任务服务（Scheduler Service）</h2><h3 id="分布式调度任务服务概述"><a href="#分布式调度任务服务概述" class="headerlink" title="分布式调度任务服务概述"></a>分布式调度任务服务概述</h3><p>Redisson的分布式调度任务服务实现了java.util.concurrent.ScheduledExecutorService接口，支持在不同的独立节点里执行基于java.util.concurrent.Callable接口或java.lang.Runnable接口的任务。Redisson独立节点按顺序运行Redis列队里的任务。调度任务是一种需要在未来某个指定时间运行一次或多次的特殊任务。</p>
<h3 id="设定任务计划"><a href="#设定任务计划" class="headerlink" title="设定任务计划"></a>设定任务计划</h3><p>Redisson独立节点不要求任务的类在类路径里。他们会自动被Redisson独立节点的ClassLoader加载。因此每次执行一个新任务时，不需要重启Redisson独立节点。</p>
<p>采用Callable任务的范例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RInject</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RMap&lt;String, Integer&gt; map = redissonClient.getMap(<span class="string">"myMap"</span>);</span><br><span class="line">        Long result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">            result += value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建ExecutorService时可以配置以下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorOptions options &#x3D; ExecutorOptions.defaults()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定重新尝试执行任务的时间间隔。</span><br><span class="line">&#x2F;&#x2F; ExecutorService的工作节点将等待10分钟后重新尝试执行任务</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 设定为0则不进行重试</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 默认值为5分钟</span><br><span class="line">options.taskRetryInterval(10, TimeUnit.MINUTES);</span><br><span class="line">RScheduledExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;);</span><br><span class="line">ScheduledFuture&lt;Long&gt; future &#x3D; executorService.schedule(new CallableTask(), 10, TimeUnit.MINUTES);</span><br><span class="line">Long result &#x3D; future.get();</span><br></pre></td></tr></table></figure>
<p>使用Lambda任务的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;, options);</span><br><span class="line">ScheduledFuture&lt;Long&gt; future &#x3D; executorService.schedule((Callable &amp; Serializable)() -&gt; &#123;</span><br><span class="line">      System.out.println(&quot;task has been executed!&quot;);</span><br><span class="line">&#125;, 10, TimeUnit.MINUTES);</span><br><span class="line">Long result &#x3D; future.get();</span><br></pre></td></tr></table></figure>
<p>采用Runnable任务的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @RInject</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    private long param;</span><br><span class="line"></span><br><span class="line">    public RunnableTask() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RunnableTask(long param) &#123;</span><br><span class="line">        this.param&#x3D; param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        RAtomicLong atomic &#x3D; redissonClient.getAtomicLong(&quot;myAtomic&quot;);</span><br><span class="line">        atomic.addAndGet(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RScheduledExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;);</span><br><span class="line">ScheduledFuture&lt;?&gt; future1 &#x3D; executorService.schedule(new RunnableTask(123), 10, TimeUnit.HOURS);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">ScheduledFuture&lt;?&gt; future2 &#x3D; executorService.scheduleAtFixedRate(new RunnableTask(123), 10, 25, TimeUnit.HOURS);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">ScheduledFuture&lt;?&gt; future3 &#x3D; executorService.scheduleWithFixedDelay(new RunnableTask(123), 5, 10, TimeUnit.HOURS);</span><br></pre></td></tr></table></figure>
<h3 id="通过CRON表达式设定任务计划"><a href="#通过CRON表达式设定任务计划" class="headerlink" title="通过CRON表达式设定任务计划"></a>通过CRON表达式设定任务计划</h3><p>在分布式调度任务中，可以通过CRON表达式来为任务设定一个更复杂的计划。表达式与Quartz的CRON格式完全兼容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RScheduledExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;);</span><br><span class="line">executorService.schedule(new RunnableTask(), CronSchedule.of(&quot;10 0&#x2F;5 * * * ?&quot;));</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">executorService.schedule(new RunnableTask(), CronSchedule.dailyAtHourAndMinute(10, 5));</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">executorService.schedule(new RunnableTask(), CronSchedule.weeklyOnDayAndHourAndMinute(12, 4, Calendar.MONDAY, Calendar.FRIDAY));</span><br></pre></td></tr></table></figure>
<h3 id="取消计划任务"><a href="#取消计划任务" class="headerlink" title="取消计划任务"></a>取消计划任务</h3><p>分布式调度任务服务提供了两张取消任务的方式：通过调用ScheduledFuture.cancel()方法或调用RScheduledExecutorService.cancelScheduledTask方法。通过对Thread.currentThread().isInterrupted()方法的调用可以在已经处于运行状态的任务里实现任务中断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableTask implements Callable&lt;Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @RInject</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Long call() throws Exception &#123;</span><br><span class="line">        RMap&lt;String, Integer&gt; map &#x3D; redissonClient.getMap(&quot;myMap&quot;);</span><br><span class="line">        Long result &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; map里包含了许多的元素</span><br><span class="line">        for (Integer value : map.values()) &#123;</span><br><span class="line">           if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 任务被取消了</span><br><span class="line">                return null;</span><br><span class="line">           &#125;</span><br><span class="line">           result +&#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RScheduledExecutorService executorService &#x3D; redisson.getExecutorService(&quot;myExecutor&quot;);</span><br><span class="line">RScheduledFuture&lt;Long&gt; future &#x3D; executorService.scheduleAsync(new RunnableTask(), CronSchedule.dailyAtHourAndMinute(10, 5));</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">future.cancel(true);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">String taskId &#x3D; future.getTaskId();</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">executorService.cancelScheduledTask(taskId);</span><br></pre></td></tr></table></figure>
<h2 id="5、分布式映射归纳服务（MapReduce）"><a href="#5、分布式映射归纳服务（MapReduce）" class="headerlink" title="5、分布式映射归纳服务（MapReduce）"></a>5、分布式映射归纳服务（MapReduce）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Redisson提供了通过映射归纳（MapReduce）编程模式来处理储存在Redis环境里的大量数据的服务。这个想法来至于其他的类似实现方式和谷歌发表的研究。所有 映射（Map） 和 归纳（Reduce） 阶段中的任务都是被分配到各个独立节点（Redisson Node）里并行执行的。以下所有接口均支持映射归纳（MapReduce）功能： RMap、 RMapCache、 RLocalCachedMap、 RSet、 RSetCache、 RList、 RSortedSet、 RScoredSortedSet、 RQueue、 RBlockingQueue、 RDeque、 RBlockingDeque、 RPriorityQueue 和 RPriorityDeque</p>
<p>映射归纳（MapReduce）的功能是通过RMapper、 RCollectionMapper、 RReducer 和 RCollator 这几个接口实现的。</p>
<ol>
<li>RMapper 映射器接口适用于映射（Map）类，它用来把映射（Map）中的每个元素转换为另一个作为归纳（Reduce）处理用的键值对。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RMapper&lt;KIn, VIn, KOut, VOut&gt; extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    void map(KIn key, VIn value, RCollector&lt;KOut, VOut&gt; collector);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>RCollectionMapper 映射器接口仅适用于集合（Collection）类型的对象，它用来把集合（Collection）中的元素转换成一组作为归纳（Reduce）处理用的键值对。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RCollectionMapper&lt;VIn, KOut, VOut&gt; extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    void map(VIn value, RCollector&lt;KOut, VOut&gt; collector);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>RReducer 归纳器接口用来将上面这些，由映射器生成的键值对列表进行归纳整理。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RReducer&lt;K, V&gt; extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    V reduce(K reducedKey, Iterator&lt;V&gt; values);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>RCollator 收集器接口用来把归纳整理以后的结果化简为单一一个对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RCollator&lt;K, V, R&gt; extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    R collate(Map&lt;K, V&gt; resultMap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上每个阶段的任务都可以用@RInject注解的方式来获取RedissonClient实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class WordMapper implements RMapper&lt;String, String, String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @RInject</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void map(String key, String value, RCollector&lt;String, Integer&gt; collector) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">        redissonClient.getAtomicLong(&quot;mapInvocations&quot;).incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="映射（Map）类型的使用范例"><a href="#映射（Map）类型的使用范例" class="headerlink" title="映射（Map）类型的使用范例"></a>映射（Map）类型的使用范例</h3>Redisson提供的RMap、 RMapCache和RLocalCachedMap这三种映射（Map）类型的对象均可以使用这种分布式映射归纳（MapReduce）服务。</li>
</ol>
<p>以下是在映射（Map）类型的基础上采用映射归纳（MapReduce）来实现字数统计的范例：</p>
<p>Mapper对象将每个映射的值用空格且分开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WordMapper implements RMapper&lt;String, String, String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void map(String key, String value, RCollector&lt;String, Integer&gt; collector) &#123;</span><br><span class="line">        String[] words &#x3D; value.split(&quot;[^a-zA-Z]&quot;);</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            collector.emit(word, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reducer对象计算统计所有单词的使用情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WordReducer implements RReducer&lt;String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer reduce(String reducedKey, Iterator&lt;Integer&gt; iter) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        while (iter.hasNext()) &#123;</span><br><span class="line">           Integer i &#x3D; (Integer) iter.next();</span><br><span class="line">           sum +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Collator对象统计所有单词的使用情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WordCollator implements RCollator&lt;String, Integer, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer collate(Map&lt;String, Integer&gt; resultMap) &#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        for (Integer count : resultMap.values()) &#123;</span><br><span class="line">            result +&#x3D; count;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把上面的各个对象串起来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RMap&lt;String, String&gt; map &#x3D; redisson.getMap(&quot;wordsMap&quot;);</span><br><span class="line">map.put(&quot;line1&quot;, &quot;Alice was beginning to get very tired&quot;);</span><br><span class="line">map.put(&quot;line2&quot;, &quot;of sitting by her sister on the bank and&quot;);</span><br><span class="line">map.put(&quot;line3&quot;, &quot;of having nothing to do once or twice she&quot;);</span><br><span class="line">map.put(&quot;line4&quot;, &quot;had peeped into the book her sister was reading&quot;);</span><br><span class="line">map.put(&quot;line5&quot;, &quot;but it had no pictures or conversations in it&quot;);</span><br><span class="line">map.put(&quot;line6&quot;, &quot;and what is the use of a book&quot;);</span><br><span class="line">map.put(&quot;line7&quot;, &quot;thought Alice without pictures or conversation&quot;);</span><br><span class="line"></span><br><span class="line">RMapReduce&lt;String, String, String, Integer&gt; mapReduce</span><br><span class="line">         &#x3D; map.&lt;String, Integer&gt;mapReduce()</span><br><span class="line">              .mapper(new WordMapper())</span><br><span class="line">              .reducer(new WordReducer());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计词频</span><br><span class="line">Map&lt;String, Integer&gt; mapToNumber &#x3D; mapReduce.execute();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计字数</span><br><span class="line">Integer totalWordsAmount &#x3D; mapReduce.execute(new WordCollator());</span><br></pre></td></tr></table></figure>
<h3 id="集合（Collection）类型的使用范例"><a href="#集合（Collection）类型的使用范例" class="headerlink" title="集合（Collection）类型的使用范例"></a>集合（Collection）类型的使用范例</h3><p>Redisson提供的RSet、 RSetCache、 RList、 RSortedSet、 RScoredSortedSet、 RQueue、 RBlockingQueue、 RDeque、 RBlockingDeque、 RPriorityQueue和RPriorityDeque这几种集合（Collection）类型的对象均可以使用这种分布式映射归纳（MapReduce）服务。</p>
<p>以下是在集合（Collection）类型的基础上采用映射归纳（MapReduce）来实现字数统计的范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class WordMapper implements RCollectionMapper&lt;String, String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void map(String value, RCollector&lt;String, Integer&gt; collector) &#123;</span><br><span class="line">        String[] words &#x3D; value.split(&quot;[^a-zA-Z]&quot;);</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            collector.emit(word, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class WordReducer implements RReducer&lt;String, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer reduce(String reducedKey, Iterator&lt;Integer&gt; iter) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        while (iter.hasNext()) &#123;</span><br><span class="line">           Integer i &#x3D; (Integer) iter.next();</span><br><span class="line">           sum +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class WordCollator implements RCollator&lt;String, Integer, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer collate(Map&lt;String, Integer&gt; resultMap) &#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        for (Integer count : resultMap.values()) &#123;</span><br><span class="line">            result +&#x3D; count;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">RList&lt;String&gt; list &#x3D; redisson.getList(&quot;myList&quot;);</span><br><span class="line">list.add(&quot;Alice was beginning to get very tired&quot;);</span><br><span class="line">list.add(&quot;of sitting by her sister on the bank and&quot;);</span><br><span class="line">list.add(&quot;of having nothing to do once or twice she&quot;);</span><br><span class="line">list.add(&quot;had peeped into the book her sister was reading&quot;);</span><br><span class="line">list.add(&quot;but it had no pictures or conversations in it&quot;);</span><br><span class="line">list.add(&quot;and what is the use of a book&quot;);</span><br><span class="line">list.add(&quot;thought Alice without pictures or conversation&quot;);</span><br><span class="line"></span><br><span class="line">RCollectionMapReduce&lt;String, String, Integer&gt; mapReduce</span><br><span class="line">         &#x3D; list.&lt;String, Integer&gt;mapReduce()</span><br><span class="line">               .mapper(new WordMapper())</span><br><span class="line">               .reducer(new WordReducer());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计词频</span><br><span class="line">Map&lt;String, Integer&gt; mapToNumber &#x3D; mapReduce.execute();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计字数</span><br><span class="line">Integer totalWordsAmount &#x3D; mapReduce.execute(new WordCollator());</span><br></pre></td></tr></table></figure>
<h1 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a>八、其他</h1><h2 id="1、对Redis节点的操作"><a href="#1、对Redis节点的操作" class="headerlink" title="1、对Redis节点的操作"></a>1、对Redis节点的操作</h2><p>Redisson的NodesGroup对象提供了许些对Redis节点的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NodesGroup nodesGroup &#x3D; redisson.getNodesGroup();</span><br><span class="line">nodesGroup.addConnectionListener(new ConnectionListener() &#123;</span><br><span class="line">    public void onConnect(InetSocketAddress addr) &#123;</span><br><span class="line">       &#x2F;&#x2F; Redis节点连接成功</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onDisconnect(InetSocketAddress addr) &#123;</span><br><span class="line">       &#x2F;&#x2F; Redis节点连接断开</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">也可以用来PING单个Redis节点或全部节点。</span><br><span class="line"></span><br><span class="line">NodesGroup nodesGroup &#x3D; redisson.getNodesGroup();</span><br><span class="line">Collection&lt;Node&gt; allNodes &#x3D; nodesGroup.getNodes();</span><br><span class="line">for (Node n : allNodes) &#123;</span><br><span class="line">    n.ping();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">nodesGroup.pingAll();</span><br></pre></td></tr></table></figure>
<h2 id="2-复杂多维对象结构和对象引用的支持"><a href="#2-复杂多维对象结构和对象引用的支持" class="headerlink" title="2. 复杂多维对象结构和对象引用的支持"></a>2. 复杂多维对象结构和对象引用的支持</h2><p>Redisson突破了Redis数据结构维度的限制，通过一个特殊引用对象的帮助，Redisson允许以任意的组合方式构建多维度的复杂对象结构，实现了对象之间的类似传统数据库里的关联关系。使用范例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RMap&lt;RSet&lt;RList&gt;, RList&lt;RMap&gt;&gt; map &#x3D; redisson.getMap(&quot;myMap&quot;);</span><br><span class="line">RSet&lt;RList&gt; set &#x3D; redisson.getSet(&quot;mySet&quot;);</span><br><span class="line">RList&lt;RMap&gt; list &#x3D; redisson.getList(&quot;myList&quot;);</span><br><span class="line"></span><br><span class="line">map.put(set, list);</span><br><span class="line">&#x2F;&#x2F; 在特殊引用对象的帮助下，我们甚至可以构建一个循环引用，这是通过普通序列化方式实现不了的。</span><br><span class="line">set.add(list);</span><br><span class="line">list.add(map);</span><br></pre></td></tr></table></figure>
<p>在map包含的元素发生改变以后，我们无需再次“保存/持久”这些对象。因为map对象所记录的并不是序列化以后的值，而是元素对象的引用。这让Redisson提供的对象在使用方法上，与普通Java对象的使用方法一致。从而让Redis成为内存的一部分，而不仅仅是一个储存空间。</p>
<p>以上范例中，一共创建了三个Redis数据结构：一个Redis HASH，一个Redis SET和一个Redis LIST。</p>
<h2 id="3-命令的批量执行"><a href="#3-命令的批量执行" class="headerlink" title="3. 命令的批量执行"></a>3. 命令的批量执行</h2><p>多个连续命令可以通过RBatch对象在一次网络会话请求里合并发送，这样省去了产生多个请求消耗的时间和资源。这在Redis中叫做管道。</p>
<p>用户可以通过以下方式调整通过管道方式发送命令的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">BatchOptions options &#x3D; BatchOptions.defaults()</span><br><span class="line">&#x2F;&#x2F; 指定执行模式</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; ExecutionMode.REDIS_READ_ATOMIC - 所有命令缓存在Redis节点中，以原子性事务的方式执行。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; ExecutionMode.REDIS_WRITE_ATOMIC - 所有命令缓存在Redis节点中，以原子性事务的方式执行。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; ExecutionMode.IN_MEMORY - 所有命令缓存在Redisson本机内存中统一发送，但逐一执行（非事务）。默认模式。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; ExecutionMode.IN_MEMORY_ATOMIC - 所有命令缓存在Redisson本机内存中统一发送，并以原子性事务的方式执行。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">.executionMode(ExecutionMode.IN_MEMORY)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 告知Redis不用返回结果（可以减少网络用量）</span><br><span class="line">.skipResult()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将写入操作同步到从节点</span><br><span class="line">&#x2F;&#x2F; 同步到2个从节点，等待时间为1秒钟</span><br><span class="line">.syncSlaves(2, 1, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理结果超时为2秒钟</span><br><span class="line">.responseTimeout(2, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命令重试等待间隔时间为2秒钟</span><br><span class="line">.retryInterval(2, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命令重试次数。仅适用于未发送成功的命令</span><br><span class="line">.retryAttempts(4);</span><br><span class="line">使用方式如下：</span><br><span class="line"></span><br><span class="line">RBatch batch &#x3D; redisson.createBatch();</span><br><span class="line">batch.getMap(&quot;test&quot;).fastPutAsync(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">batch.getMap(&quot;test&quot;).fastPutAsync(&quot;2&quot;, &quot;3&quot;);</span><br><span class="line">batch.getMap(&quot;test&quot;).putAsync(&quot;2&quot;, &quot;5&quot;);</span><br><span class="line">batch.getAtomicLongAsync(&quot;counter&quot;).incrementAndGetAsync();</span><br><span class="line">batch.getAtomicLongAsync(&quot;counter&quot;).incrementAndGetAsync();</span><br><span class="line"></span><br><span class="line">BatchResult res &#x3D; batch.execute();</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">Future&lt;BatchResult&gt; asyncRes &#x3D; batch.executeAsync();</span><br><span class="line">List&lt;?&gt; response &#x3D; res.getResponses();</span><br><span class="line">res.getSyncedSlaves();</span><br></pre></td></tr></table></figure>
<p>在集群模式下，所有的命令会按各个槽所在的节点，筛选分配到各个节点并同时发送。每个节点返回的结果将会汇总到最终的结果列表里。</p>
<h2 id="4-Redisson事务"><a href="#4-Redisson事务" class="headerlink" title="4. Redisson事务"></a>4. Redisson事务</h2><p>Redisson为RMap、RMapCache、RLocalCachedMap、RSet、RSetCache和RBucket这样的对象提供了具有ACID属性的事务功能。Redisson事务通过分布式锁保证了连续写入的原子性，同时在内部通过操作指令队列实现了Redis原本没有的提交与滚回功能。当提交与滚回遇到问题的时候，将通过org.redisson.transaction.TransactionException告知用户。</p>
<p>目前支持的环境如下： SINGLE, MASTER/SLAVE, SENTINEL, ELASTICACHE REPLICATED, AZURE CACHE, RLEC。</p>
<p>Redisson事务支持的事务隔离等级为: READ_COMMITTED，即仅读取提交后的结果。</p>
<p>另见 Spring事务管理器 和本章 XA事务（XA Transactions）。</p>
<p>以下选项可以用来配置事务属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">TransactionOptions options &#x3D; TransactionOptions.defaults()</span><br><span class="line">&#x2F;&#x2F; 设置参与本次事务的主节点与其从节点同步的超时时间。</span><br><span class="line">&#x2F;&#x2F; 默认值是5秒。</span><br><span class="line">.syncSlavesTimeout(5, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理结果超时。</span><br><span class="line">&#x2F;&#x2F; 默认值是3秒。</span><br><span class="line">.responseTimeout(3, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命令重试等待间隔时间。仅适用于未发送成功的命令。</span><br><span class="line">&#x2F;&#x2F; 默认值是1.5秒。</span><br><span class="line">.retryInterval(2, TimeUnit.SECONDS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 命令重试次数。仅适用于未发送成功的命令。</span><br><span class="line">&#x2F;&#x2F; 默认值是3次。</span><br><span class="line">.retryAttempts(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事务超时时间。如果规定时间内没有提交该事务则自动滚回。</span><br><span class="line">&#x2F;&#x2F; 默认值是5秒。</span><br><span class="line">.timeout(5, TimeUnit.SECONDS);</span><br><span class="line">代码范例：</span><br><span class="line"></span><br><span class="line">RTransaction transaction &#x3D; redisson.createTransaction(TransactionOptions.defaults());</span><br><span class="line"></span><br><span class="line">RMap&lt;String, String&gt; map &#x3D; transaction.getMap(&quot;myMap&quot;);</span><br><span class="line">map.put(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">String value &#x3D; map.get(&quot;3&quot;);</span><br><span class="line">RSet&lt;String&gt; set &#x3D; transaction.getSet(&quot;mySet&quot;)</span><br><span class="line">set.add(value);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">   transaction.commit();</span><br><span class="line">&#125; catch(TransactionException e) &#123;</span><br><span class="line">   transaction.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-XA事务（XA-Transactions）"><a href="#5-XA事务（XA-Transactions）" class="headerlink" title="5. XA事务（XA Transactions）"></a>5. XA事务（XA Transactions）</h2><p>Redisson提供了XAResource标准的实现。该实现可用于JTA事务中。</p>
<p>另见本章Redisson事务和Spring事务管理器。</p>
<p>该功能仅适用于Redisson PRO版本</p>
<p>代码范例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Transaction对象可以从所有兼容JTA接口的事务管理器中获取。</span><br><span class="line">Transaction globalTransaction &#x3D; transactionManager.getTransaction();</span><br><span class="line"></span><br><span class="line">RXAResource xaResource &#x3D; redisson.getXAResource();</span><br><span class="line">globalTransaction.enlistResource(xaResource);</span><br><span class="line"></span><br><span class="line">RTransaction transaction &#x3D; xaResource.getTransaction();</span><br><span class="line">RBucket&lt;String&gt; bucket &#x3D; transaction.getBucket(&quot;myBucket&quot;);</span><br><span class="line">bucket.set(&quot;simple&quot;);</span><br><span class="line">RMap&lt;String, String&gt; map &#x3D; transaction.getMap(&quot;myMap&quot;);</span><br><span class="line">map.put(&quot;myKey&quot;, &quot;myValue&quot;);</span><br><span class="line"></span><br><span class="line">transactionManager.commit();</span><br></pre></td></tr></table></figure>
<h2 id="6-脚本执行"><a href="#6-脚本执行" class="headerlink" title="6. 脚本执行"></a>6. 脚本执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">redisson.getBucket(&quot;foo&quot;).set(&quot;bar&quot;);</span><br><span class="line">String r &#x3D; redisson.getScript().eval(Mode.READ_ONLY,</span><br><span class="line">   &quot;return redis.call(&#39;get&#39;, &#39;foo&#39;)&quot;, RScript.ReturnType.VALUE);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过预存的脚本进行同样的操作</span><br><span class="line">RScript s &#x3D; redisson.getScript();</span><br><span class="line">&#x2F;&#x2F; 首先将脚本保存到所有的Redis主节点</span><br><span class="line">String res &#x3D; s.scriptLoad(&quot;return redis.call(&#39;get&#39;, &#39;foo&#39;)&quot;);</span><br><span class="line">&#x2F;&#x2F; 返回值 res &#x3D;&#x3D; 282297a0228f48cd3fc6a55de6316f31422f5d17</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 再通过SHA值调用脚本</span><br><span class="line">Future&lt;Object&gt; r1 &#x3D; redisson.getScript().evalShaAsync(Mode.READ_ONLY,</span><br><span class="line">   &quot;282297a0228f48cd3fc6a55de6316f31422f5d17&quot;,</span><br><span class="line">   RScript.ReturnType.VALUE, Collections.emptyList());</span><br><span class="line">10.7. 底层Redis客户端</span><br><span class="line">Redisson在底层采用了高性能异步非阻塞式Java客户端，它同时支持异步和同步两种通信模式。如果有哪些命令Redisson还没提供支持，也可以直接通过调用底层Redis客户端来实现。Redisson支持的命令在Redis命令和Redisson对象匹配列表里做了详细对比参照。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在使用多个客户端的情况下可以共享同一个EventLoopGroup</span><br><span class="line">EventLoopGroup group &#x3D; new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">RedisClientConfig config &#x3D; new RedisClientConfig();</span><br><span class="line">config.setAddress(&quot;redis:&#x2F;&#x2F;localhost:6379&quot;) &#x2F;&#x2F; 或者用rediss:&#x2F;&#x2F;使用加密连接</span><br><span class="line">      .setPassword(&quot;myPassword&quot;)</span><br><span class="line">      .setDatabase(0)</span><br><span class="line">      .setClientName(&quot;myClient&quot;)</span><br><span class="line">      .setGroup(group);</span><br><span class="line"></span><br><span class="line">RedisClient client &#x3D; RedisClient.create(config);</span><br><span class="line">RedisConnection conn &#x3D; client.connect();</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">RFuture&lt;RedisConnection&gt; connFuture &#x3D; client.connectAsync();</span><br><span class="line"></span><br><span class="line">conn.sync(StringCodec.INSTANCE, RedisCommands.SET, &quot;test&quot;, 0);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">conn.async(StringCodec.INSTANCE, RedisCommands.GET, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">conn.closeAsync()</span><br><span class="line"></span><br><span class="line">client.shutdown();</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">client.shutdownAsync();</span><br></pre></td></tr></table></figure>

      
    </div>
     <!-- 相关文章推荐 -->
    
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redisson/" rel="tag"># Redisson</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/23/EhCache%E4%BB%8B%E7%BB%8D%E5%92%8C%E8%BF%90%E7%94%A8/" rel="next" title="EhCache介绍和运用">
                <i class="fa fa-chevron-left"></i> EhCache介绍和运用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/20/AOP%E5%9B%9E%E9%A1%BE/" rel="prev" title="AOP回顾">
                AOP回顾 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://img.huyunshun.com/img/20200522182348.png"
                alt="初晨" />
            
              <p class="site-author-name" itemprop="name">初晨</p>
              <p class="site-description motion-element" itemprop="description">永远不要说你知道本质，更别说真相了。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">249</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">109</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
<!--近期文章版块-->
            
                <div class="links-of-blogroll motion-element links-of-blogroll-block">
                  <div class="links-of-blogroll-title">
                    <!-- modify icon to fire by szw -->
                    <i class="fa fa-history fa-" aria-hidden="true"></i>
                    近期文章
                  </div>
                  <ul class="links-of-blogroll-list">
                    
                    
                      <li>
                        <a href="/2020/05/22/WebSocket%E3%80%81Socket%E3%80%81TCP%E3%80%81HTTP%E5%8C%BA%E5%88%AB/" title="WebSocket、Socket、TCP、HTTP区别" target="_blank">WebSocket、Socket、TCP、HTTP区别</a>
                      </li>
                    
                      <li>
                        <a href="/2020/05/19/Springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E9%98%B2%E5%88%B7/" title="Springboot项目的接口防刷" target="_blank">Springboot项目的接口防刷</a>
                      </li>
                    
                      <li>
                        <a href="/2020/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="深入理解Volatile关键字及其实现原理" target="_blank">深入理解Volatile关键字及其实现原理</a>
                      </li>
                    
                      <li>
                        <a href="/2020/04/20/%E4%BD%BF%E7%94%A8vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E7%8E%AF%E5%A2%83/" title="使用vscode搭建个人笔记环境" target="_blank">使用vscode搭建个人笔记环境</a>
                      </li>
                    
                      <li>
                        <a href="/2020/01/20/HBase%E4%BB%8B%E7%BB%8D%E5%AE%89%E8%A3%85%E4%B8%8E%E6%93%8D%E4%BD%9C/" title="HBase介绍安装与操作" target="_blank">HBase介绍安装与操作</a>
                      </li>
                    
                  </ul>
                </div>
            
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、介绍"><span class="nav-number">1.</span> <span class="nav-text">一、介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、配置"><span class="nav-number">2.</span> <span class="nav-text">二、配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、程序配置方式"><span class="nav-number">2.0.1.</span> <span class="nav-text">1、程序配置方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、配置文件方式"><span class="nav-number">2.0.2.</span> <span class="nav-text">2、配置文件方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、常用设置"><span class="nav-number">2.0.3.</span> <span class="nav-text">3、常用设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#codec（编码）"><span class="nav-number">2.0.3.1.</span> <span class="nav-text">codec（编码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#threads（线程池数量）"><span class="nav-number">2.0.3.2.</span> <span class="nav-text">threads（线程池数量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nettyThreads-（Netty线程池数量）"><span class="nav-number">2.0.3.3.</span> <span class="nav-text">nettyThreads （Netty线程池数量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#executor（线程池）"><span class="nav-number">2.0.3.4.</span> <span class="nav-text">executor（线程池）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eventLoopGroup"><span class="nav-number">2.0.3.5.</span> <span class="nav-text">eventLoopGroup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transportMode（传输模式）"><span class="nav-number">2.0.3.6.</span> <span class="nav-text">transportMode（传输模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）"><span class="nav-number">2.0.3.7.</span> <span class="nav-text">lockWatchdogTimeout（监控锁的看门狗超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#keepPubSubOrder（保持订阅发布顺序）"><span class="nav-number">2.0.3.8.</span> <span class="nav-text">keepPubSubOrder（保持订阅发布顺序）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#performanceMode（高性能模式）"><span class="nav-number">2.0.3.9.</span> <span class="nav-text">performanceMode（高性能模式）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群模式"><span class="nav-number">2.1.</span> <span class="nav-text">集群模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、程序方式"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、程序方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、通过文件配置集群模式"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、通过文件配置集群模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、设置"><span class="nav-number">2.1.3.</span> <span class="nav-text">3、设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nodeAddresses（添加节点地址）"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">nodeAddresses（添加节点地址）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scanInterval（集群扫描间隔时间）"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">scanInterval（集群扫描间隔时间）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slots（分片数量）"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">slots（分片数量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readMode（读取操作的负载均衡模式）"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">readMode（读取操作的负载均衡模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionMode（订阅操作的负载均衡模式）"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">subscriptionMode（订阅操作的负载均衡模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadBalancer（负载均衡算法类的选择）"><span class="nav-number">2.1.3.6.</span> <span class="nav-text">loadBalancer（负载均衡算法类的选择）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）"><span class="nav-number">2.1.3.7.</span> <span class="nav-text">subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）"><span class="nav-number">2.1.3.8.</span> <span class="nav-text">subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slaveConnectionMinimumIdleSize（从节点最小空闲连接数）"><span class="nav-number">2.1.3.9.</span> <span class="nav-text">slaveConnectionMinimumIdleSize（从节点最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slaveConnectionPoolSize（从节点连接池大小）"><span class="nav-number">2.1.3.10.</span> <span class="nav-text">slaveConnectionPoolSize（从节点连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#masterConnectionMinimumIdleSize（主节点最小空闲连接数）"><span class="nav-number">2.1.3.11.</span> <span class="nav-text">masterConnectionMinimumIdleSize（主节点最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#masterConnectionPoolSize（主节点连接池大小）"><span class="nav-number">2.1.3.12.</span> <span class="nav-text">masterConnectionPoolSize（主节点连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）"><span class="nav-number">2.1.3.13.</span> <span class="nav-text">idleConnectionTimeout（连接空闲超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#connectTimeout（连接超时，单位：毫秒）"><span class="nav-number">2.1.3.14.</span> <span class="nav-text">connectTimeout（连接超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timeout（命令等待超时，单位：毫秒）"><span class="nav-number">2.1.3.15.</span> <span class="nav-text">timeout（命令等待超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retryAttempts（命令失败重试次数）"><span class="nav-number">2.1.3.16.</span> <span class="nav-text">retryAttempts（命令失败重试次数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retryInterval（命令重试发送时间间隔，单位：毫秒）"><span class="nav-number">2.1.3.17.</span> <span class="nav-text">retryInterval（命令重试发送时间间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）"><span class="nav-number">2.1.3.18.</span> <span class="nav-text">reconnectionTimeout（重新连接时间间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#failedAttempts（执行失败最大次数）"><span class="nav-number">2.1.3.19.</span> <span class="nav-text">failedAttempts（执行失败最大次数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#password（密码）"><span class="nav-number">2.1.3.20.</span> <span class="nav-text">password（密码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionsPerConnection（单个连接最大订阅数量）"><span class="nav-number">2.1.3.21.</span> <span class="nav-text">subscriptionsPerConnection（单个连接最大订阅数量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clientName（客户端名称）"><span class="nav-number">2.1.3.22.</span> <span class="nav-text">clientName（客户端名称）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslEnableEndpointIdentification（启用SSL终端识别）"><span class="nav-number">2.1.3.23.</span> <span class="nav-text">sslEnableEndpointIdentification（启用SSL终端识别）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslProvider（SSL实现方式）"><span class="nav-number">2.1.3.24.</span> <span class="nav-text">sslProvider（SSL实现方式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslTruststore（SSL信任证书库路径）"><span class="nav-number">2.1.3.25.</span> <span class="nav-text">sslTruststore（SSL信任证书库路径）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslTruststorePassword（SSL信任证书库密码）"><span class="nav-number">2.1.3.26.</span> <span class="nav-text">sslTruststorePassword（SSL信任证书库密码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslKeystore（SSL钥匙库路径）"><span class="nav-number">2.1.3.27.</span> <span class="nav-text">sslKeystore（SSL钥匙库路径）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslKeystorePassword（SSL钥匙库密码）"><span class="nav-number">2.1.3.28.</span> <span class="nav-text">sslKeystorePassword（SSL钥匙库密码）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单Redis节点模式"><span class="nav-number">2.2.</span> <span class="nav-text">单Redis节点模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、程序化配置"><span class="nav-number">2.2.1.</span> <span class="nav-text">1、程序化配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、单节点设置"><span class="nav-number">2.2.2.</span> <span class="nav-text">2、单节点设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#address（节点地址）"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">address（节点地址）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionConnectionMinimumIdleSize（发布和订阅连接的最小空闲连接数）"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">subscriptionConnectionMinimumIdleSize（发布和订阅连接的最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionConnectionPoolSize（发布和订阅连接池大小）"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">subscriptionConnectionPoolSize（发布和订阅连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#connectionMinimumIdleSize（最小空闲连接数）"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">connectionMinimumIdleSize（最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#connectionPoolSize（连接池大小）"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">connectionPoolSize（连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dnsMonitoring（是否启用DNS监测）"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">dnsMonitoring（是否启用DNS监测）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dnsMonitoringInterval（DNS监测时间间隔，单位：毫秒）"><span class="nav-number">2.2.2.7.</span> <span class="nav-text">dnsMonitoringInterval（DNS监测时间间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）-1"><span class="nav-number">2.2.2.8.</span> <span class="nav-text">idleConnectionTimeout（连接空闲超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#connectTimeout（连接超时，单位：毫秒）-1"><span class="nav-number">2.2.2.9.</span> <span class="nav-text">connectTimeout（连接超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timeout（命令等待超时，单位：毫秒）-1"><span class="nav-number">2.2.2.10.</span> <span class="nav-text">timeout（命令等待超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retryAttempts（命令失败重试次数）-1"><span class="nav-number">2.2.2.11.</span> <span class="nav-text">retryAttempts（命令失败重试次数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retryInterval（命令重试发送时间间隔，单位：毫秒）-1"><span class="nav-number">2.2.2.12.</span> <span class="nav-text">retryInterval（命令重试发送时间间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）-1"><span class="nav-number">2.2.2.13.</span> <span class="nav-text">reconnectionTimeout（重新连接时间间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#failedAttempts（执行失败最大次数）-1"><span class="nav-number">2.2.2.14.</span> <span class="nav-text">failedAttempts（执行失败最大次数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#database（数据库编号）"><span class="nav-number">2.2.2.15.</span> <span class="nav-text">database（数据库编号）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#password（密码）-1"><span class="nav-number">2.2.2.16.</span> <span class="nav-text">password（密码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionsPerConnection（单个连接最大订阅数量）-1"><span class="nav-number">2.2.2.17.</span> <span class="nav-text">subscriptionsPerConnection（单个连接最大订阅数量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clientName（客户端名称）-1"><span class="nav-number">2.2.2.18.</span> <span class="nav-text">clientName（客户端名称）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslEnableEndpointIdentification（启用SSL终端识别）-1"><span class="nav-number">2.2.2.19.</span> <span class="nav-text">sslEnableEndpointIdentification（启用SSL终端识别）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslProvider（SSL实现方式）-1"><span class="nav-number">2.2.2.20.</span> <span class="nav-text">sslProvider（SSL实现方式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslTruststore（SSL信任证书库路径）-1"><span class="nav-number">2.2.2.21.</span> <span class="nav-text">sslTruststore（SSL信任证书库路径）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslTruststorePassword（SSL信任证书库密码）-1"><span class="nav-number">2.2.2.22.</span> <span class="nav-text">sslTruststorePassword（SSL信任证书库密码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslKeystore（SSL钥匙库路径）-1"><span class="nav-number">2.2.2.23.</span> <span class="nav-text">sslKeystore（SSL钥匙库路径）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslKeystorePassword（SSL钥匙库密码）-1"><span class="nav-number">2.2.2.24.</span> <span class="nav-text">sslKeystorePassword（SSL钥匙库密码）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、配置文件"><span class="nav-number">2.2.3.</span> <span class="nav-text">3、配置文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哨兵模式"><span class="nav-number">2.3.</span> <span class="nav-text">哨兵模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、程序化配置-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">1、程序化配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、设置"><span class="nav-number">2.3.2.</span> <span class="nav-text">2、设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dnsMonitoringInterval（DNS监控间隔，单位：毫秒）"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">dnsMonitoringInterval（DNS监控间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#masterName（主服务器的名称）"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">masterName（主服务器的名称）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#addSentinelAddress（添加哨兵节点地址）"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">addSentinelAddress（添加哨兵节点地址）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readMode（读取操作的负载均衡模式）-1"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">readMode（读取操作的负载均衡模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionMode（订阅操作的负载均衡模式）-1"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">subscriptionMode（订阅操作的负载均衡模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadBalancer（负载均衡算法类的选择）-1"><span class="nav-number">2.3.2.6.</span> <span class="nav-text">loadBalancer（负载均衡算法类的选择）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）-1"><span class="nav-number">2.3.2.7.</span> <span class="nav-text">subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）-1"><span class="nav-number">2.3.2.8.</span> <span class="nav-text">subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slaveConnectionMinimumIdleSize（从节点最小空闲连接数）-1"><span class="nav-number">2.3.2.9.</span> <span class="nav-text">slaveConnectionMinimumIdleSize（从节点最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slaveConnectionPoolSize（从节点连接池大小）-1"><span class="nav-number">2.3.2.10.</span> <span class="nav-text">slaveConnectionPoolSize（从节点连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#masterConnectionMinimumIdleSize（主节点最小空闲连接数）-1"><span class="nav-number">2.3.2.11.</span> <span class="nav-text">masterConnectionMinimumIdleSize（主节点最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#masterConnectionPoolSize（主节点连接池大小）-1"><span class="nav-number">2.3.2.12.</span> <span class="nav-text">masterConnectionPoolSize（主节点连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）-2"><span class="nav-number">2.3.2.13.</span> <span class="nav-text">idleConnectionTimeout（连接空闲超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#connectTimeout（连接超时，单位：毫秒）-2"><span class="nav-number">2.3.2.14.</span> <span class="nav-text">connectTimeout（连接超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timeout（命令等待超时，单位：毫秒）-2"><span class="nav-number">2.3.2.15.</span> <span class="nav-text">timeout（命令等待超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retryAttempts（命令失败重试次数）-2"><span class="nav-number">2.3.2.16.</span> <span class="nav-text">retryAttempts（命令失败重试次数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retryInterval（命令重试发送时间间隔，单位：毫秒）-2"><span class="nav-number">2.3.2.17.</span> <span class="nav-text">retryInterval（命令重试发送时间间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）-2"><span class="nav-number">2.3.2.18.</span> <span class="nav-text">reconnectionTimeout（重新连接时间间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#failedAttempts（执行失败最大次数）-2"><span class="nav-number">2.3.2.19.</span> <span class="nav-text">failedAttempts（执行失败最大次数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#database（数据库编号）-1"><span class="nav-number">2.3.2.20.</span> <span class="nav-text">database（数据库编号）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#password（密码）-2"><span class="nav-number">2.3.2.21.</span> <span class="nav-text">password（密码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionsPerConnection（单个连接最大订阅数量）-2"><span class="nav-number">2.3.2.22.</span> <span class="nav-text">subscriptionsPerConnection（单个连接最大订阅数量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clientName（客户端名称）-2"><span class="nav-number">2.3.2.23.</span> <span class="nav-text">clientName（客户端名称）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslEnableEndpointIdentification（启用SSL终端识别）-2"><span class="nav-number">2.3.2.24.</span> <span class="nav-text">sslEnableEndpointIdentification（启用SSL终端识别）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslProvider（SSL实现方式）-2"><span class="nav-number">2.3.2.25.</span> <span class="nav-text">sslProvider（SSL实现方式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslTruststore（SSL信任证书库路径）-2"><span class="nav-number">2.3.2.26.</span> <span class="nav-text">sslTruststore（SSL信任证书库路径）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslTruststorePassword（SSL信任证书库密码）-2"><span class="nav-number">2.3.2.27.</span> <span class="nav-text">sslTruststorePassword（SSL信任证书库密码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslKeystore（SSL钥匙库路径）-2"><span class="nav-number">2.3.2.28.</span> <span class="nav-text">sslKeystore（SSL钥匙库路径）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslKeystorePassword（SSL钥匙库密码）-2"><span class="nav-number">2.3.2.29.</span> <span class="nav-text">sslKeystorePassword（SSL钥匙库密码）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、配置文件-1"><span class="nav-number">2.3.3.</span> <span class="nav-text">3、配置文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主从模式"><span class="nav-number">2.4.</span> <span class="nav-text">主从模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、程序化配置-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">1、程序化配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、主从模式设置"><span class="nav-number">2.4.2.</span> <span class="nav-text">2、主从模式设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dnsMonitoringInterval（DNS监控间隔，单位：毫秒）-1"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">dnsMonitoringInterval（DNS监控间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#masterAddress（主节点地址）"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">masterAddress（主节点地址）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#addSlaveAddress（添加从主节点地址）"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">addSlaveAddress（添加从主节点地址）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readMode（读取操作的负载均衡模式）-2"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">readMode（读取操作的负载均衡模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionMode（订阅操作的负载均衡模式）-2"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">subscriptionMode（订阅操作的负载均衡模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadBalancer（负载均衡算法类的选择）-2"><span class="nav-number">2.4.2.6.</span> <span class="nav-text">loadBalancer（负载均衡算法类的选择）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）-2"><span class="nav-number">2.4.2.7.</span> <span class="nav-text">subscriptionConnectionMinimumIdleSize（从节点发布和订阅连接的最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）-2"><span class="nav-number">2.4.2.8.</span> <span class="nav-text">subscriptionConnectionPoolSize（从节点发布和订阅连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slaveConnectionMinimumIdleSize（从节点最小空闲连接数）-2"><span class="nav-number">2.4.2.9.</span> <span class="nav-text">slaveConnectionMinimumIdleSize（从节点最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slaveConnectionPoolSize（从节点连接池大小）-2"><span class="nav-number">2.4.2.10.</span> <span class="nav-text">slaveConnectionPoolSize（从节点连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#masterConnectionMinimumIdleSize（主节点最小空闲连接数）-2"><span class="nav-number">2.4.2.11.</span> <span class="nav-text">masterConnectionMinimumIdleSize（主节点最小空闲连接数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#masterConnectionPoolSize（主节点连接池大小）-2"><span class="nav-number">2.4.2.12.</span> <span class="nav-text">masterConnectionPoolSize（主节点连接池大小）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#idleConnectionTimeout（连接空闲超时，单位：毫秒）-3"><span class="nav-number">2.4.2.13.</span> <span class="nav-text">idleConnectionTimeout（连接空闲超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#connectTimeout（连接超时，单位：毫秒）-3"><span class="nav-number">2.4.2.14.</span> <span class="nav-text">connectTimeout（连接超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timeout（命令等待超时，单位：毫秒）-3"><span class="nav-number">2.4.2.15.</span> <span class="nav-text">timeout（命令等待超时，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retryAttempts（命令失败重试次数）-3"><span class="nav-number">2.4.2.16.</span> <span class="nav-text">retryAttempts（命令失败重试次数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retryInterval（命令重试发送时间间隔，单位：毫秒）-3"><span class="nav-number">2.4.2.17.</span> <span class="nav-text">retryInterval（命令重试发送时间间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reconnectionTimeout（重新连接时间间隔，单位：毫秒）-3"><span class="nav-number">2.4.2.18.</span> <span class="nav-text">reconnectionTimeout（重新连接时间间隔，单位：毫秒）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#failedAttempts（执行失败最大次数）-3"><span class="nav-number">2.4.2.19.</span> <span class="nav-text">failedAttempts（执行失败最大次数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#database（数据库编号）-2"><span class="nav-number">2.4.2.20.</span> <span class="nav-text">database（数据库编号）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#password（密码）-3"><span class="nav-number">2.4.2.21.</span> <span class="nav-text">password（密码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscriptionsPerConnection（单个连接最大订阅数量）-3"><span class="nav-number">2.4.2.22.</span> <span class="nav-text">subscriptionsPerConnection（单个连接最大订阅数量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clientName（客户端名称）-3"><span class="nav-number">2.4.2.23.</span> <span class="nav-text">clientName（客户端名称）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslEnableEndpointIdentification（启用SSL终端识别）-3"><span class="nav-number">2.4.2.24.</span> <span class="nav-text">sslEnableEndpointIdentification（启用SSL终端识别）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslProvider（SSL实现方式）-3"><span class="nav-number">2.4.2.25.</span> <span class="nav-text">sslProvider（SSL实现方式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslTruststore（SSL信任证书库路径）-3"><span class="nav-number">2.4.2.26.</span> <span class="nav-text">sslTruststore（SSL信任证书库路径）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslTruststorePassword（SSL信任证书库密码）-3"><span class="nav-number">2.4.2.27.</span> <span class="nav-text">sslTruststorePassword（SSL信任证书库密码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslKeystore（SSL钥匙库路径）-3"><span class="nav-number">2.4.2.28.</span> <span class="nav-text">sslKeystore（SSL钥匙库路径）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sslKeystorePassword（SSL钥匙库密码）-3"><span class="nav-number">2.4.2.29.</span> <span class="nav-text">sslKeystorePassword（SSL钥匙库密码）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、文件配置主从模式"><span class="nav-number">2.4.3.</span> <span class="nav-text">3、文件配置主从模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、程序接口调用方式"><span class="nav-number">3.</span> <span class="nav-text">三、程序接口调用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#异步执行方式"><span class="nav-number">3.1.</span> <span class="nav-text">异步执行方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步流执行方式"><span class="nav-number">3.2.</span> <span class="nav-text">异步流执行方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单个集合数据分片"><span class="nav-number">4.</span> <span class="nav-text">单个集合数据分片</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、分布式对象"><span class="nav-number">5.</span> <span class="nav-text">四、分布式对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通用对象桶（Object-Bucket）"><span class="nav-number">5.1.</span> <span class="nav-text">通用对象桶（Object Bucket）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制流（Binary-Stream）"><span class="nav-number">5.2.</span> <span class="nav-text">二进制流（Binary Stream）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地理空间对象桶（Geospatial-Bucket）"><span class="nav-number">5.3.</span> <span class="nav-text">地理空间对象桶（Geospatial Bucket）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BitSet"><span class="nav-number">5.4.</span> <span class="nav-text">BitSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子整长形（AtomicLong）"><span class="nav-number">5.5.</span> <span class="nav-text">原子整长形（AtomicLong）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子双精度浮点（AtomicDouble）"><span class="nav-number">5.6.</span> <span class="nav-text">原子双精度浮点（AtomicDouble）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#话题（订阅分发）"><span class="nav-number">5.7.</span> <span class="nav-text">话题（订阅分发）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布隆过滤器（Bloom-Filter）"><span class="nav-number">5.8.</span> <span class="nav-text">布隆过滤器（Bloom Filter）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数估计算法（HyperLogLog）"><span class="nav-number">5.9.</span> <span class="nav-text">基数估计算法（HyperLogLog）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整长型累加器（LongAdder）"><span class="nav-number">5.10.</span> <span class="nav-text">整长型累加器（LongAdder）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双精度浮点累加器（DoubleAdder）"><span class="nav-number">5.11.</span> <span class="nav-text">双精度浮点累加器（DoubleAdder）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#限流器（RateLimiter）"><span class="nav-number">5.12.</span> <span class="nav-text">限流器（RateLimiter）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、分布式集合"><span class="nav-number">6.</span> <span class="nav-text">五、分布式集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、映射（Map）"><span class="nav-number">6.1.</span> <span class="nav-text">1、映射（Map）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#映射（Map）的元素淘汰（Eviction），本地缓存（LocalCache）和数据分片（Sharding）"><span class="nav-number">6.1.1.</span> <span class="nav-text">映射（Map）的元素淘汰（Eviction），本地缓存（LocalCache）和数据分片（Sharding）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#元素淘汰功能（Eviction）"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">元素淘汰功能（Eviction）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本地缓存功能（Local-Cache）"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">本地缓存功能（Local Cache）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据分片功能（Sharding）"><span class="nav-number">6.1.1.3.</span> <span class="nav-text">数据分片功能（Sharding）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#映射持久化方式（缓存策略）"><span class="nav-number">6.1.1.3.1.</span> <span class="nav-text">映射持久化方式（缓存策略）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Read-through策略"><span class="nav-number">6.1.1.3.1.1.</span> <span class="nav-text">Read-through策略</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Write-through（数据同步写入）策略"><span class="nav-number">6.1.1.3.1.2.</span> <span class="nav-text">Write-through（数据同步写入）策略</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Write-behind（数据异步写入）策略"><span class="nav-number">6.1.1.3.1.3.</span> <span class="nav-text">Write-behind（数据异步写入）策略</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射监听器（Map-Listener）"><span class="nav-number">6.1.2.</span> <span class="nav-text">映射监听器（Map Listener）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU有界映射"><span class="nav-number">6.1.3.</span> <span class="nav-text">LRU有界映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、多值映射（Multimap）"><span class="nav-number">6.2.</span> <span class="nav-text">2、多值映射（Multimap）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于集（Set）的多值映射（Multimap）"><span class="nav-number">6.2.1.</span> <span class="nav-text">基于集（Set）的多值映射（Multimap）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">6.2.2.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-1"><span class="nav-number">6.2.3.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于列表（List）的多值映射（Multimap）"><span class="nav-number">6.2.4.</span> <span class="nav-text">基于列表（List）的多值映射（Multimap）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-2"><span class="nav-number">6.2.5.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-3"><span class="nav-number">6.2.6.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多值映射（Multimap）淘汰机制（Eviction）"><span class="nav-number">6.2.7.</span> <span class="nav-text">多值映射（Multimap）淘汰机制（Eviction）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、集（Set）"><span class="nav-number">6.3.</span> <span class="nav-text">3、集（Set）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集（Set）淘汰机制（Eviction）"><span class="nav-number">6.3.1.</span> <span class="nav-text">集（Set）淘汰机制（Eviction）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集（Set）数据分片（Sharding）"><span class="nav-number">6.3.2.</span> <span class="nav-text">集（Set）数据分片（Sharding）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、有序集（SortedSet）"><span class="nav-number">6.4.</span> <span class="nav-text">4、有序集（SortedSet）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、计分排序集（ScoredSortedSet）"><span class="nav-number">6.5.</span> <span class="nav-text">5、计分排序集（ScoredSortedSet）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、字典排序集（LexSortedSet）"><span class="nav-number">6.6.</span> <span class="nav-text">6、字典排序集（LexSortedSet）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、列表（List）"><span class="nav-number">6.7.</span> <span class="nav-text">7、列表（List）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、队列（Queue）"><span class="nav-number">6.8.</span> <span class="nav-text">8、队列（Queue）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、双端队列（Deque）"><span class="nav-number">6.9.</span> <span class="nav-text">9、双端队列（Deque）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、阻塞队列（Blocking-Queue）"><span class="nav-number">6.10.</span> <span class="nav-text">10、阻塞队列（Blocking Queue）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、有界阻塞队列（Bounded-Blocking-Queue）"><span class="nav-number">6.11.</span> <span class="nav-text">11、有界阻塞队列（Bounded Blocking Queue）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-阻塞双端队列（Blocking-Deque）"><span class="nav-number">6.12.</span> <span class="nav-text">12. 阻塞双端队列（Blocking Deque）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-阻塞公平队列（Blocking-Fair-Queue）"><span class="nav-number">6.13.</span> <span class="nav-text">13. 阻塞公平队列（Blocking Fair Queue）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-阻塞公平双端队列（Blocking-Fair-Deque）"><span class="nav-number">6.14.</span> <span class="nav-text">14. 阻塞公平双端队列（Blocking Fair Deque）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-延迟队列（Delayed-Queue）"><span class="nav-number">6.15.</span> <span class="nav-text">15. 延迟队列（Delayed Queue）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-优先队列（Priority-Queue）"><span class="nav-number">6.16.</span> <span class="nav-text">16. 优先队列（Priority Queue）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-优先双端队列（Priority-Deque）"><span class="nav-number">6.17.</span> <span class="nav-text">17. 优先双端队列（Priority Deque）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-优先阻塞队列（Priority-Blocking-Queue）"><span class="nav-number">6.18.</span> <span class="nav-text">18. 优先阻塞队列（Priority Blocking Queue）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-优先阻塞双端队列（Priority-Blocking-Deque）"><span class="nav-number">6.19.</span> <span class="nav-text">19. 优先阻塞双端队列（Priority Blocking Deque）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、分布式锁和同步器"><span class="nav-number">7.</span> <span class="nav-text">六、分布式锁和同步器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-可重入锁（Reentrant-Lock）"><span class="nav-number">7.1.</span> <span class="nav-text">1. 可重入锁（Reentrant Lock）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-公平锁（Fair-Lock）"><span class="nav-number">7.2.</span> <span class="nav-text">2. 公平锁（Fair Lock）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-联锁（MultiLock）"><span class="nav-number">7.3.</span> <span class="nav-text">3. 联锁（MultiLock）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-红锁（RedLock）"><span class="nav-number">7.4.</span> <span class="nav-text">4. 红锁（RedLock）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-读写锁（ReadWriteLock）"><span class="nav-number">7.5.</span> <span class="nav-text">5. 读写锁（ReadWriteLock）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-信号量（Semaphore）"><span class="nav-number">7.6.</span> <span class="nav-text">6. 信号量（Semaphore）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-可过期性信号量（PermitExpirableSemaphore）"><span class="nav-number">7.7.</span> <span class="nav-text">7. 可过期性信号量（PermitExpirableSemaphore）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-闭锁（CountDownLatch）"><span class="nav-number">7.8.</span> <span class="nav-text">8. 闭锁（CountDownLatch）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七、分布式服务"><span class="nav-number">8.</span> <span class="nav-text">七、分布式服务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-分布式远程服务（Remote-Service）"><span class="nav-number">8.1.</span> <span class="nav-text">1. 分布式远程服务（Remote Service）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式远程服务工作流程"><span class="nav-number">8.1.1.</span> <span class="nav-text">分布式远程服务工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送即不管（Fire-and-Forget）模式和应答回执（Ack-Response）模式"><span class="nav-number">8.1.2.</span> <span class="nav-text">发送即不管（Fire-and-Forget）模式和应答回执（Ack-Response）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步调用"><span class="nav-number">8.1.3.</span> <span class="nav-text">异步调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、分布式实时对象（Live-Object）服务"><span class="nav-number">8.2.</span> <span class="nav-text">2、分布式实时对象（Live Object）服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍"><span class="nav-number">8.2.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用方法"><span class="nav-number">8.2.2.</span> <span class="nav-text">使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高级使用方法"><span class="nav-number">8.2.3.</span> <span class="nav-text">高级使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解（Annotation）使用方法"><span class="nav-number">8.2.4.</span> <span class="nav-text">注解（Annotation）使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用限制"><span class="nav-number">8.2.5.</span> <span class="nav-text">使用限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、分布式执行服务（Executor-Service）"><span class="nav-number">8.3.</span> <span class="nav-text">3、分布式执行服务（Executor Service）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">8.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务"><span class="nav-number">8.3.2.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取消任务"><span class="nav-number">8.3.3.</span> <span class="nav-text">取消任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、分布式调度任务服务（Scheduler-Service）"><span class="nav-number">8.4.</span> <span class="nav-text">4、分布式调度任务服务（Scheduler Service）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式调度任务服务概述"><span class="nav-number">8.4.1.</span> <span class="nav-text">分布式调度任务服务概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设定任务计划"><span class="nav-number">8.4.2.</span> <span class="nav-text">设定任务计划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过CRON表达式设定任务计划"><span class="nav-number">8.4.3.</span> <span class="nav-text">通过CRON表达式设定任务计划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取消计划任务"><span class="nav-number">8.4.4.</span> <span class="nav-text">取消计划任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、分布式映射归纳服务（MapReduce）"><span class="nav-number">8.5.</span> <span class="nav-text">5、分布式映射归纳服务（MapReduce）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-1"><span class="nav-number">8.5.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射（Map）类型的使用范例"><span class="nav-number">8.5.2.</span> <span class="nav-text">映射（Map）类型的使用范例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合（Collection）类型的使用范例"><span class="nav-number">8.5.3.</span> <span class="nav-text">集合（Collection）类型的使用范例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八、其他"><span class="nav-number">9.</span> <span class="nav-text">八、其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、对Redis节点的操作"><span class="nav-number">9.1.</span> <span class="nav-text">1、对Redis节点的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-复杂多维对象结构和对象引用的支持"><span class="nav-number">9.2.</span> <span class="nav-text">2. 复杂多维对象结构和对象引用的支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-命令的批量执行"><span class="nav-number">9.3.</span> <span class="nav-text">3. 命令的批量执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Redisson事务"><span class="nav-number">9.4.</span> <span class="nav-text">4. Redisson事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-XA事务（XA-Transactions）"><span class="nav-number">9.5.</span> <span class="nav-text">5. XA事务（XA Transactions）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-脚本执行"><span class="nav-number">9.6.</span> <span class="nav-text">6. 脚本执行</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Copyright</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


</body>
</html>
